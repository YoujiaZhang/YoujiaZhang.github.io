

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E5%B0%8F%E9%BE%99%E7%8C%AB.jpg">
  <link rel="icon" href="/img/%E5%B0%8F%E9%BE%99%E7%8C%AB.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zhang Youjia">
  <meta name="keywords" content="个人博客,blog,学习,Study">
  
    <meta name="description" content="PolarDB Meets Computational Storage. FAST2020 Efficiently Support Analytical Workloads in Cloud-Native Relational Database高效支持云原生关系数据库的复杂查询操作">
  
  
  <title>PolarDB FAST2020 - Yj-Zhang&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mac.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"youjiazhang.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"siteId=17279802","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yj-Zhang&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/%E8%B5%B7%E9%A3%8E%E4%BA%86.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="PolarDB FAST2020">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-18 11:12" pubdate>
        November 18, 2021 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      36 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">PolarDB FAST2020</h1>
            
            <div class="markdown-body">
              <h1 id="PolarDB-Meets-Computational-Storage-FAST2020"><a href="#PolarDB-Meets-Computational-Storage-FAST2020" class="headerlink" title="PolarDB Meets Computational Storage. FAST2020"></a>PolarDB Meets Computational Storage. FAST2020</h1><blockquote>
<p>Efficiently Support Analytical Workloads in Cloud-Native Relational Database<br>高效支持云原生关系数据库的复杂查询操作</p>
</blockquote>
<span id="more"></span>

<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>关系数据库是现代信息技术基础设施的重要组成部分。因此，所有的云供应商都投入了巨大的努力来发展他们的关系数据库服务业务。不出所料，一些云供应商已经开发了自己的云原生关系数据库系统，例如亚马逊极光和阿里巴巴POLARDB。为了实现足够的可扩展性和故障恢复能力，云原生关系数据库自然遵循 <strong>计算与数据存储分离</strong> 的设计原则。同时，它们通常旨在与主流开源关系数据库(例如MySQL和PostgreSQL)兼容，并以比内部同类产品低得多的成本实现 <strong>OLTP</strong> 工作负载的高性能。</p>
<div class="note note-info">
            <p>数据处理大致可以分成两大类：</p><ul><li>联机事务处理 <strong>OLTP</strong>（On-Line Transaction Processing）</li><li>联机分析处理 OLAP（On-Line Analytical Processing）</li></ul><p>OLTP 是专注于面向事务的任务的一类数据处理，通常涉及在数据库中插入，更新或删除少量数据，主要是处理大量用户下的大量事务。OLTP事务实例：在线银行、网上买一本书、预订一张机票、发送一个文本消息、电话推销员输入电话调查结果、呼叫中心员工查看和更新客户的详细信息。</p>
          </div>

<p>云原生关系数据库非常需要充分支持<strong>分析工作负载(analytical workloads)<strong>。正如 Amazon aurora 的作者所指出的，由于云原生关系数据库将计算与数据存储分离，数据库节点和存储节点之间的网络带宽成为稀缺资源。然而，这与涉及密集数据访问的分析工作负载不太匹配。为了最好地服务于OLTP工作负载，云原生关系数据库通常采用行存储模型(或混合行/列模型)。这可能会使网络带宽成为分析工作负载的更大瓶颈。</strong>为了更好地服务于分析工作负载，几乎唯一可行的选择是将数据访问密集型任务(尤其是《表扫描》table scan)从数据库节点卸载(off-load)到存储节点</strong>。这个概念当然不是新的，已经被专有数据库设备(如Oracle Exadata)和开源数据库(如MySQL NDB集群)所采用。尽管概念很简单，但它在云原生数据库环境中的实际实现尤其重要。</p>
<ul>
<li>一方面，每个存储节点必须配备足够的数据处理能力来处理《表扫描》任务。</li>
<li>另一方面，为了保持云原生数据库的成本效益，我们不能大幅(甚至适度)增加存储节点的成本。</li>
</ul>
<p>通过用专用硬件(例如，GPU和FPGA)补充中央处理器，<strong>异构计算架构</strong> 似乎是解决这一数据处理能力与成本困境的一个有吸引力的选择。</p>
<h4 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h4><p>本工作将异构计算应用于POLARDB存储节点，有效支持 **《表扫描》下推(pushdown)<strong>。其关键思想很简单 : 每个POLARDB存储节点将《表扫描》任务从其CPU分配到其数据存储设备。在这个框架下，每个数据存储设备都看做</strong>计算存储驱动器(Computational Storage Drive,CSD)**，可以在I/O路径上执行《表扫描》。与将《表扫描》卸载到专用的独立计算设备(如FPGA/基于GPU的PCIe卡)相比，将《表扫描》分布在所有存储驱动器上，可以最大限度地减少存储/内存层次结构中的数据流量，避免数据处理热点。</p>
<h4 id="两个挑战"><a href="#两个挑战" class="headerlink" title="两个挑战"></a>两个挑战</h4><p>这个简单的概念并不新鲜，而且已经有论文讨论过了。然而，它实际上可行的实现和实际部署仍然完全缺失，至少在公开文献中是这样。这主要是由于难以解决两个挑战:</p>
<ul>
<li>(1) 如何在整个软件层次结构中实际支持《表扫描》下推，</li>
<li>(2) 如何实现具有足够《表扫描》处理能力的低成本计算存储驱动器。</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在通过阿里云上的POLARDB实现这个简单想法的过程中，<strong>我们开发了一套软件/硬件技术来集中解决这两个挑战</strong>。为了减少产品开发周期，同时确保成本效益，计算存储驱动器使用以FPGA为中心的主机管理架构。在每个计算存储驱动器内，一个中档低成本Xilinx FPGA芯片处理闪存控制和《表扫描》。通过高度优化的软硬件设计，每个计算存储驱动器都可以支持对压缩数据进行高吞吐量(即超过2GB/s)的《表扫描》，同时实现与前沿NVMe SSD相当的存储I/O性能。我们开发了各种技术，使POLARDB存储节点能够充分利用计算存储驱动器的能力。本文介绍了这些设计技术并详细阐述了它们的实施，并给出了评价结果以证明其有效性。基于TPC-H查询，我们提取了6个单独的《表扫描》任务，并在一个存储节点上运行这些扫描任务。这样的节点级评估表明，计算存储驱动器可以在很大程度上降低扫描延迟和存储节点的CPU利用率。我们进一步在一个POLARDB云实例上对7个数据库节点和3个存储节点进行了系统级评估。结果表明，该解决方案可以显著降低TPC-H查询延迟。据我们所知，这是在公开文献中首次报道新兴计算存储在生产数据库中的应用。</p>
<div class="note note-info">
            <p>云原生数据库 : 数据库的设计要充分利用云的基础设施。</p>
          </div>


<h2 id="2-背景与动机"><a href="#2-背景与动机" class="headerlink" title="2 背景与动机"></a>2 背景与动机</h2><h3 id="2-1-POLARDB-基本架构"><a href="#2-1-POLARDB-基本架构" class="headerlink" title="2.1 POLARDB: 基本架构"></a>2.1 POLARDB: 基本架构</h3><p>POLARDB是阿里云设计的一个新的云原生OLTP数据库。它的设计目标来自于我们的云客户的真实需求：每个实例的</p>
<ul>
<li>大存储容量(几十TB)</li>
<li>高TPS(Transactions Per Second)</li>
<li>高可伸缩的QoS</li>
<li>高可用性</li>
</ul>
<p><img src="/blog-image/PolarDBFAST20/5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>一写多读</strong> : PolarDB采用分布式集群架构，一个集群版集群包含一个主节点和最多15个只读节点（至少一个，用于保障高可用）。主节点处理读写请求，只读节点仅处理读请求。主节点和只读节点之间采用Active-Active的Failover方式，提供数据库的高可用服务。</li>
<li><strong>计算与存储分离</strong> : PolarDB采用计算与存储分离的设计理念，满足公共云计算环境下根据业务发展弹性扩展集群的刚性需求。数据库的计算节点（Database Engine Server）仅存储元数据，而将数据文件、Redo Log等存储于远端的存储节点（Database Storage Server）。各计算节点之间仅需同步Redo Log相关的元数据信息，极大降低了主节点和只读节点间的复制延迟，而且在主节点故障时，只读节点可以快速切换为主节点。</li>
<li><strong>读写分离</strong> : 读写分离是PolarDB集群版默认提供的一个透明、高可用、自适应的负载均衡能力。通过集群地址，SQL请求自动转发到PolarDB集群版的各个节点，提供聚合、高吞吐的并发SQL处理能力。</li>
<li><strong>高速链路互联</strong> : 数据库的计算节点和存储节点之间采用高速网络互联，并通过RDMA协议进行数据传输，使I/O性能不再成为瓶颈。</li>
<li><strong>共享分布式存储</strong> : 多个计算节点共享一份数据，而不是每个计算节点都存储一份数据，极大降低了用户的存储成本。基于全新打造的分布式块存储（Distributed Storage）和文件系统（Distributed Filesystem），存储容量可以在线平滑扩展，不会受到单个数据库服务器的存储容量限制，可应对上百TB级别的数据规模。</li>
<li><strong>数据多副本、Parallel-Raft协议</strong> : 数据库存储节点的数据采用多副本形式，确保数据的可靠性，并通过Parallel-Raft协议保证数据的一致性。</li>
</ul>
<h3 id="2-2-POLARDB-《表扫描》下推"><a href="#2-2-POLARDB-《表扫描》下推" class="headerlink" title="2.2 POLARDB: 《表扫描》下推"></a>2.2 POLARDB: 《表扫描》下推</h3><p>将《表扫描》从数据库节点卸载到存储节点对于云原生关系数据库有效地处理分析工作负载非常重要。这个概念以存储节点上更重的数据处理负载换取显著减少数据库节点和存储节点之间的网络流量。此外，由于POLARDB采用行存储模型来更好地服务于OLTP工作负载，《表扫描》的面向列特性倾向于要求存储节点具有更高的数据处理能力。<strong>因此，设计的关键问题是如何经济有效地为存储节点配备足够的数据处理能力，以处理额外的《表扫描》任务。</strong></p>
<p>✖ 最直接的选择是简单地扩展每个存储节点，然而这实际上并不可取，主要是由于成本开销。对行存储数据的《表扫描》不适合于现代CPU架构，并且倾向于在很大程度上未充分利用CPU硬件资源(例如，缓存内存和SIMD处理资源)。因此，我们必须更积极地扩展存储节点，以弥补基于CPU实现的低效率。因此，这种直截了当的选择在经济上是没有吸引力的，甚至是不可接受的，特别是当经典的CMOS技术扩展正在迅速接近尾声的时候。</p>
<p>✔ 另一种选择是使用特殊用途的硬件(如FPGA或GPU)来补充存储节点CPU，以更好的成本效益进行《表扫描》。在这种异构计算框架下，传统实践使用集中式异构架构，其中特殊用途的硬件以单个单机FPGA/基于GPU的PCIe卡的形式实现。然而，对于我们的目标系统，这种方法有几个缺点:</p>
<ul>
<li>(1) 高数据流量 : 所有行存储格式的原始数据必须从存储设备获取到FPGA/ 基于GPU的PCIe卡。由于《表扫描》的数据密集型特性，这导致PCIe/DRAM通道上的数据流量非常大。高数据流量会导致大量的能耗开销和工作负载间的干扰。</li>
<li>(2) 数据处理热点 : 每个存储节点包含大量NVMe SSD，每个NVMe SSD可以实现多 GB/s 的数据读吞吐量。</li>
</ul>
<p>因此，《分析处理工作负载》可能触发非常高的聚合原始数据访问吞吐量，远远超过一个PCIe卡的I/O带宽。这可能会使FPGA/ 基于GPU的PCIe卡成为系统瓶颈。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上面的讨论表明<strong>分布式异构架构是一个更好的选择</strong>。如下图所示，通过将《表扫描》直接分发到每个存储驱动器(物理介质)，我们可以消除PCIe/DRAM通道上的高数据流量，并消除系统中的数据处理热点。这种直觉直接促使我们在POLARDB存储节点中开发和部署计算存储驱动器。</p>
<p><img src="/blog-image/PolarDBFAST20/4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-计算存储驱动器-·-CSD"><a href="#2-3-计算存储驱动器-·-CSD" class="headerlink" title="2.3 计算存储驱动器 · CSD"></a>2.3 计算存储驱动器 · CSD</h3><p><strong>简单地说，任何能够在其核心存储职责之外执行数据处理任务的数据存储设备都可以称为计算存储驱动器。</strong> 赋予存储设备额外计算能力的简单概念可以追溯到20多年前。计算存储与CPU互补，形成异构计算系统。与仅使用CPU的同类系统相比，异构计算系统可以为许多应用程序实现更高的性能和能源效率，这一点并不令人惊讶，正如先前的研究所证明的那样。然而，它显然受制于两个成本开销 :</p>
<ul>
<li>(1) 实现计算存储驱动器的硬件成本,</li>
<li>(2) 开发所有必要的硬件和软件解决方案以实现其实际部署的开发成本。</li>
</ul>
<p>尽管经过二十多年的研究，计算存储仍未进入主流市场，这可能是由于缺乏切实合理的效益与成本权衡。</p>
<h4 id="如何降低成本"><a href="#如何降低成本" class="headerlink" title="如何降低成本 ?"></a>如何降低成本 ?</h4><p>为了克服成本障碍，我们选择了<strong>基于FPGA的主机管理计算存储驱动器设计策略</strong>。这可以从两个方面降低开发成本 :</p>
<ul>
<li>(1) 我们使用单一的FPGA在计算存储驱动器内实现闪存控制和计算(即本工作中的《表扫描》)。与基于ASIC的方法相比，FPGA的电路级可编程性可以显著降低计算存储驱动器的开发周期和成本。</li>
<li>(2) 计算存储驱动器完全由主机管理，实现地址映射、请求调度、垃圾回收等功能。它的主机管理特性有助于将计算存储驱动器集成到现有的软件堆栈中。它为设计和优化计算存储驱动器的API提供了很高的灵活性，应用程序可以利用它的可配置计算能力。同时，主机管理的计算存储驱动器作为存储块设备集成到Linux I/O堆栈中，以服务于正常的I/O请求。</li>
</ul>
<p>然而，为了得到其电路级的可编程性，FPGA是昂贵的(例如，现代高端FPGA芯片可能会花费数千美元)，导致计算存储驱动器的硬件成本更高。同时，本工作的目标是部署计算存储驱动器，以成本有效地支持《表扫描》下推。因此，一个关键问题是<strong>如何在实现足够高的存储I/O和《表扫描》处理性能的同时最小化硬件成本开销</strong>，这将在下一节中讨论。</p>
<h2 id="3-设计与实现"><a href="#3-设计与实现" class="headerlink" title="3 设计与实现"></a>3 设计与实现</h2><p>如上所述，虽然应用计算存储来支持《表扫描》下推是一个非常简单的概念，并且在发表的文献中已经得到了很好的讨论，但是它的实际实现和部署仍然是缺失的。我们在POLARDB中实现这一概念的第一手经验表明，将这个简单的想法转化为实际产品面临以下两个主要挑战:</p>
<ol>
<li><strong>如何实际支持跨整个软件层次的《表扫描》下推</strong> : 由用户空间POLARDB存储引擎发起，该存储引擎通过指定文件中的偏移量来访问数据，而《表扫描》在物理上由计算存储驱动器提供，它作为原始块设备运行，并使用LBA(逻辑块地址)管理数据。整个存储I/O堆栈位于POLARDB存储引擎和计算存储驱动器之间。因此，我们必须内聚地增强/修改整个软件/驱动程序堆栈，以便创建一个支持《表扫描》叠加的路径。</li>
<li><strong>实现低成本的计算存储驱动器</strong> : 虽然基于FPGA的设计方法可以显著降低开发成本，但FPGA往往比较昂贵。此外,由于<br>FPGA通常仅工作在200 ~ 300MHz(与之相比，CPU时钟频率为2 ~ 4GHz)，为了实现足够高的性能，我们必须使用大量的电路级实现并行性(因此需要更多的硅资源)。因此，我们必须在我们的实现中开发出能够使用低成本FPGA芯片的解决方案。</li>
</ol>
<p>本节的其余部分将介绍一组跨软件和硬件堆栈的设计技术，这些技术可以解决上述两个主要挑战。</p>
<h3 id="3-1-支持跨整个软件层次的《表扫描》下推"><a href="#3-1-支持跨整个软件层次的《表扫描》下推" class="headerlink" title="3.1 支持跨整个软件层次的《表扫描》下推"></a>3.1 支持跨整个软件层次的《表扫描》下推</h3><p><strong>前端分析处理引擎 PolarDB MPP</strong> ：该分析处理引擎与 MySQL 协议兼容，可以解析、优化和重写使用 AST(抽象语法树)的 SQL 和许多嵌入式优化规则，它将每个 SQL 查询转换为一个 DAG(有向无环图)执行计划，由操作符和数据流拓扑组成。该引擎原生就支持 pushdown</p>
<p>如下图所示，为了启用《表扫描》下推，我们必须适当地增强分析处理引擎下的整个存储堆栈，包括POLARDB存储引擎、PolarFS (POLARDB下的分布式文件系统)和计算存储驱动程序。在下面的文章中，我们将详细介绍跨这三个层实现的增强功能。</p>
<p><img src="/blog-image/PolarDBFAST20/1.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="增强POLARDB存储引擎"><a href="#增强POLARDB存储引擎" class="headerlink" title="增强POLARDB存储引擎"></a>增强POLARDB存储引擎</h4><p>存储引擎 PolarDB Storage Engine：遵循了 LSM-tree 实现，数据被组织成了多个文件，每个文件包含很多块。</p>
<ul>
<li>原有的实现中，存储引擎可以使用存储节点上的 CPU 来处理 《表扫描》 请求，因此 《表扫描》 下推将与底层的 I\O 堆栈无关。</li>
<li>为了利用可计算型存储的特点，需要修改该引擎以便将 《表扫描》 请求下推到 PolarFS 上。存储引擎根据文件中的偏移量访问数据块。每一个 《表扫描》 请求包括：<ul>
<li>要被扫描的数据的定位信息（文件内的偏移量）；</li>
<li>应用《表扫描》的表的 schema；</li>
<li>《表扫描》 的condition。</li>
</ul>
</li>
<li>POLARDB 存储引擎分配一个内存缓冲区来存储从计算存储驱动器返回的数据，每个 《表扫描》 请求都包含这个内存缓冲区的位置</li>
</ul>
<div class="note note-info">
            <p><strong>LSM-Tree</strong> 全称是 Log Structured Merge Tree，是一种分层，有序，面向磁盘的数据结构，其核心思想是充分了利用了“磁盘批量的顺序写要远比随机写性能高出很多”的特点。围绕这一原理进行设计和优化，以此让写性能达到最优，正如我们普通的Log的写入方式，这种结构的写入，全部都是以Append的模式追加，不存在删除和修改。当然有得就有舍，这种结构虽然大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景。故LSM被设计来提供比传统的B+树或者ISAM更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。</p>
          </div>

<h4 id="增强PolarFS"><a href="#增强PolarFS" class="headerlink" title="增强PolarFS"></a>增强PolarFS</h4><p>POLARDB部署在分布式文件系统PolarFS上，该文件系统管理跨所有存储节点的数据存储。每个计算存储驱动器只能对其自身的数据进行《表扫描》，同时以存储引擎数据块为单位进行数据扫描。同时，由于使用了块级压缩，长度可变的压缩块被连续地打包在每个文件中(即，每个压缩块不是4kb对齐)。因此，PolarFS在计算存储驱动器上使用粗粒度的数据分条(4MB分条大小)，以确保大多数数据块完全驻留在一个计算存储驱动器上。在一个压缩块位于两个驱动器之间的罕见情况下，系统将使用存储节点CPU处理相应的扫描操作。</p>
<p>POLARDB存储引擎以偏移量的形式在文件中指定待扫描数据的位置。要扫描的数据可能跨越多个文件，从而跨越多个计算存储驱动器。同时，计算存储驱动器只能以LBAs的形式定位数据。因此，在接收到来自POLARDB存储引擎的每个《表扫描》请求后，PolarFS必须适当地转换该请求，然后将其转发给计算存储驱动程序。因此，我们从以下几个方面对PolarFS进行了增强:</p>
<ul>
<li>(1) 假设要扫描的数据跨越了计算性驱动器，增强的PolarFS将该请求分解为扫描请求，每个请求扫描一个计算性存储驱动器上的数据。</li>
<li>(2) 对于每个扫描请求，将数据位置信息转换为LBAs中的偏移量。</li>
</ul>
<p>如图所示，增强的PolarFS随后将带有转换后的基于 LBA 的位置信息的themscan请求传递给底层的计算存储驱动程序。</p>
<h4 id="增强计算存储驱动程序"><a href="#增强计算存储驱动程序" class="headerlink" title="增强计算存储驱动程序"></a>增强计算存储驱动程序</h4><p>我们的计算存储驱动器完全由内核空间中的主机端驱动程序管理。该驱动程序将每个计算存储驱动器公开为一个块设备。在接收到PolarFS的每个《表扫描》请求后，驱动程序执行以下操作：</p>
<ul>
<li>它首先分析《扫描条件》，并在必要时重新安排扫描条件，以更好地简化基于硬件的扫描处理，从而提高吞吐量。</li>
<li>驱动程序进一步转换将被扫描数据的位置信息从LBA域到物理块地址(PBA)域，其中每个PBA与NAND闪存中的一个固定位置相关联。</li>
</ul>
<p>驱动程序在内部将每个扫描请求划分为许多(非常)小的扫描子任务，这可以达到两个目的:</p>
<ul>
<li>(1) 大的扫描任务可能会占用闪存带宽很长时间，这会导致其他正常的I/O请求延迟更长。通过将大的扫描任务划分为小的子任务，并用正常的I/O请求对它们进行内聚调度，可以缓解这个问题。</li>
<li>(2) 将大的扫描任务划分为小的子任务，有助于减少内部缓冲的硬件资源占用，提高闪存访问的并行性。</li>
</ul>
<p>此外，存储设备的后台操作，特别是**垃圾收集(Garbage Collection，GC)**，可能会严重干扰《表扫描》，从而造成严重的延迟损失。由于所有的flash管理功能都是由主机端驱动程序处理的，所以我们对驱动程序进行了增强，以便它能够内聚地调度GC和《表扫描》，以最小化GC引起的干扰。特别是，在分析处理工作负载繁重的情况下，驱动程序将自适应地减少甚至暂停GC操作。</p>
<h3 id="3-2-降低硬件实现成本"><a href="#3-2-降低硬件实现成本" class="headerlink" title="3.2 降低硬件实现成本"></a>3.2 降低硬件实现成本</h3><p>为了解决计算存储驱动实现成本的挑战，关键是实现FPGA硬件资源利用率的最大化。为了实现这个目标，我们在软件和硬件层中进一步开发了以下技术。</p>
<h4 id="硬件友好的数据块格式"><a href="#硬件友好的数据块格式" class="headerlink" title="硬件友好的数据块格式"></a>硬件友好的数据块格式</h4><p>我们首先修改了 POLARDB 存储引擎的数据块格式，以便于 FPGA 实现《表扫描》。《表扫描》主要涉及各种数据比较操作(如=、≥、≤)。尽管 FPGA 具有电路级的可编程性，但 FPGA 很难实现有效支持多种不同数据类型的比较器。在本工作中，我们修改了 POLARDB 存储引擎，使其以内存可比的格式存储所有的表数据，即可以使用函数 <strong>memcmp()</strong> 来比较数据。因此，计算存储驱动器只需要实现可以执行memcmp()函数的单一类型的比较器，而不考虑表中不同字段中的特定数据类型。通过在 FPGA 中实现类型无关的比较器，这可以在很大程度上减少实现《表扫描》时FPGA资源的使用。</p>
<p><img src="/blog-image/PolarDBFAST20/2.png" srcset="/img/loading.gif" lazyload></p>
<p>为了提高硬件利用率，我们进一步修改了存储引擎的数据块结构。上图(a)展示了原始存储引擎中所使用的数据块格式 : 一个数据块包含了许多已排序的表项，以元信息(即1字节数据压缩类型和4字节CRC)结束。虽然这样的块格式可以很容易地由CPU处理，但它对计算存储驱动器中基于硬件的《表扫描》不友好。我们修改了图中(b)所示的数据块格式，其中我们添加了一个额外的块头，包括1字节的块压缩类型、4字节的键值对数量和4字节的重启键数量(注意，重启键用于在前缀压缩的情况下方便键搜索)。</p>
<p>这种修改后的块格式对基于硬件的《表扫描》更加友好，因为:</p>
<ul>
<li>(1) 计算存储驱动器可以解压每个块并检查CRC，而不需要POLARDB存储引擎传递每个块的大小信息。</li>
<li>(2) 通过在每个块的开始添加 “***# of keys*** ” 和 “***# of restart*** ”字段，硬件可以更方便地处理每个块内的重启和检测内块。</li>
</ul>
<p>这非常适合于硬件的顺序数据处理流程，从而简化了基于FPGA的硬件实现。</p>
<h4 id="FPGA实现"><a href="#FPGA实现" class="headerlink" title="FPGA实现"></a>FPGA实现</h4><p><img src="/blog-image/PolarDBFAST20/3.png" srcset="/img/loading.gif" lazyload></p>
<p>上图显示了我们的FPGA实现的并行和流水线架构。为了降低成本，我们使用一个单一的中档 FPGA 芯片的闪存控制和《表扫描》。FPGA集成了一个强大的软判决LDPC(低密度奇偶校验)编码引擎。这使得低成本的3D TLC(以及未来的QLC) NAND闪存的使用成为可能，这有助于降低整体计算存储驱动器的成本。我们使用并行和流水线的硬件架构来提高《表扫描》处理的吞吐量。如图所示，它包含2个并行的数据解压引擎和4个数据扫描引擎。当前实现支持Snappy解压缩和以下扫描条件 : =，≠，&gt;，≥，&lt;，≤，NULL，和!NULL。</p>
<div class="note note-info">
            <p><strong>LDPC码</strong> : 是麻省理工学院Robert Gallager于1963年在博士论文中提出的一种具有稀疏校验矩阵的分组纠错码。几乎适用于所有的信道，因此成为编码界近年来的研究热点。它的性能逼近香农极限，且描述和实现简单，易于进行理论分析和研究，译码简单且可实行并行操作，适合硬件实现。</p><p><strong>3D NAND</strong> : 是英特尔和镁光的合资企业所研发的一种新兴的闪存类型，通过把内存颗粒堆叠在一起来解决2D或者平面NAND闪存带来的限制。</p><p><strong>SLC</strong> ：全称 Single-Level Cell，每个Cell单元只存储1bit信息，也就是只有0、1两种电压变化，结构简单，电压控制也快速，反映出来的特点就是寿命长，性能强，P/E寿命在1万到10万次之间，但缺点就是容量低，成本高，毕竟一个Cell单元只能存储1bit信息。</p><p><strong>MLC</strong> ：全称是 Multi-Level Cell，它实际上是跟SLC对应的，SLC之外的NAND闪存都是MLC类型，而我们常说的MLC是指2bit MLC。<br>每个cell单元存储2bit信息，电压有000,01,10,11四种变化，所以它比SLC需要更复杂的的电压控制，加压过程用时也变长，意味着写入性能降低了，同时可靠性也下降了，P/E寿命根据不同制程在3000-5000次不等，有的还更低。</p><p><strong>TLC</strong> : 也就是 Trinary-Level Cell，准确来说是3bit MLC，每个cell单元存储3bit信息，电压从000到111有8种变化，容量比MLC再次增加1/3，成本更低，但是架构更复杂，P/E编程时间长，写入速度慢，P/E寿命也降至1000-3000次，部分情况会更低。</p><p><strong>QLC</strong> ：则是Quad-Level Cell，或者叫4bit MLC，电压从0000到1111有16种变化，容量增加了33%，但是写入性能、P/E寿命会再次减少。</p><p><img src="/blog-image/PolarDBFAST20/6.png" srcset="/img/loading.gif" lazyload></p><p><strong>Snappy</strong> 是谷歌开源的一个用来压缩和解压的开发包。相较其他压缩算法速率有明显的优势，官方文档显示在64位i7处理器上，每秒可达200~500MB的压缩速度。</p>
          </div>

<p>为了进一步提高硬件资源利用效率，我们采用了如下所述的简单设计技术。如上所述，所有字段都以内存可比形式存储，因此我们只需要实现类型无关的memcmp 模块来计算每个条件。由于不同的《表扫描》任务的扫描条件数量不同，每个扫描引擎都采用递归架构，以最大限度地提高FPGA的资源利用率。每个扫描引擎包含一个memcmp模块和一个oneRE(结果评估)模块。LetP=∑mi=1(∏nij=1ci,j)表示整体扫描任务，其中每个ci,jis在一个字段上有一个单独的条件。符号∑和∏分别表示逻辑或运算和与运算。使用单个memcmp和remodule，我们用一个条件递归计算谓词，每次jat。TheREmodule检查之前的memcmpoutput(即，到目前为止已经评估的所有theci,j)是否足以确定resultP的值。一旦p(即。，可以确定1或0)，扫描引擎可以立即完成对当前行的计算，并开始对另一行进行工作。这种递归体系结构可以在FPGA硬件资源利用率最佳的情况下处理任意谓词。</p>
<!-- ## 4 评价

本节给出评估结果，以演示此已部署解决方案的有效性。本节的其余部分组织如下:4.1节总结了计算存储驱动器的实验环境和基本存储性能。章节4.2评估和比较了使用cpu或计算存储设备来实现《表扫描》时的《表扫描》性能。第4.3节给出了阿里巴巴云中一个POLARDB实例的TPC-H评估结果，第4.4节给出了进一步的结语。

### 4.1 实验装置

为了成为切实可行的产品，除了提供存储内计算能力外，计算存储驱动器必须具有一流的存储I/O性能(至少可以与领先的普通NVMe ssd相媲美)。我们的计算存储驱动器的存储性能总结如下。每个驱动器使用64层3D TLC NAND闪存芯片。通过PCIe Gen3×4接口，每个驱动器可支持2.2GB/s和3.0GB/s的顺序读写吞吐量。在100%的地址跨度和全触发GC下，每个驱动器可以实现160K和590K随机4KB读写IOPS，与最新的企业级NVMe ssd相媲美。每个计算存储驱动器承载一个中程Xilinx UltraScale+ KU15p FPGA芯片，该芯片处理闪存控制和计算。为了最大限度地提高纠错强度，每个驱动器支持软判决LDPC码解码，解码吞吐量超过3gb /s。性能评估在阿里巴巴云的一个POLARDB实例上进行(7个数据库节点，3个存储节点)。

### 4.2 《表扫描》性能评估

每个计算存储驱动器内的FPGA包含两个Snappy解压引擎和四个数据扫描引擎。解压缩吞吐量随数据压缩性的不同而不同。在压缩比为60%和30%时，两种解压引擎的总解压吞吐量分别为2.3GB/s和2.8GB/s。数据扫描引擎也有可变的吞吐量，这取决于几个运行时参数，例如，表中每一行的大小、表模式和扫描条件。

我们使用TPC-H基准测试中定义的linineitemtable作为测试工具，评估移动《表扫描》对计算存储驱动器的有效性。lineitemtable总共包含16列，其中混合了标识符、整数、十进制、定长和变长字符串等数据类型。为了涵盖广泛的处理复杂性，我们选择了以下6个《表扫描》任务(从不同的TPC-H查询中提取)对一个存储节点进行评估: -->


<h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h3><p>存储内计算是一个非常简单的概念，并且已经在研究社区中得到了很好的讨论。然而，它在实际系统中的实现和部署仍然是难以捉摸的。与此同时，组件级别的显著增益不会转化为系统级别的显著好处，这并不罕见。因此，将存储内计算的简单想法商业化，远远不止实现能够进行某些计算的存储设备，还需要跨软件和硬件层次结构的集成创新。为了将存储内《表扫描》引入到云原生数据库系统，我们开发了跨越存储引擎、文件系统、驱动程序和硬件堆栈的整体解决方案。组件级实验评估结果表明，我们实现的计算存储驱动器可以实现高吞吐量的存储内《表扫描》，从而显著减少主机CPU使用和存储到内存的数据移动。系统级评估结果表明，我们的整体解决方案确实可以将组件级增益带入系统级。系统级评估还确认了实现从数据库节点到存储节点的《表扫描》下推的关键重要性。</p>
<h3 id="5-相关工作"><a href="#5-相关工作" class="headerlink" title="5 相关工作"></a>5 相关工作</h3><p>之前的工作已经深入研究了使用专用硬件(特别是 FPGA 和 GPU )加速数据库以补充 CPU 的前景。<strong>许多先前的工作集中在将分析处理中的《表扫描》卸载到专用的加速器(通常以 PCIe 卡的形式)上</strong>，这些加速器由 FPGA 或 GPU 构建。除了《表扫描》，之前的工作还研究了卸载更复杂的查询处理内核的潜力。然而，尽管有大量的前期工作和多年来令人印象深刻的性能优势，IBM-Netezza 似乎是主流市场上唯一已知的商业上成功的产品。它将数据压缩和《表扫描》卸载到IBM PureData Systems中基于 FPGA 的专用 PCIe 卡中。除了使用独立的加速器来补充 CPU 之外，Oracle 甚至将特殊目的的分析加速单元集成到自己的SPARC CPU中，然而，这显然是一个非常高的开发成本，并且已经被 Oracle 停止了。</p>
<p>新兴的计算存储为实现数据库的异构计算平台提供了新的机会。《Intelligent distributed storage》的作者研究了支持键值存储的计算存储驱动器的设计。之前的工作集中于利用计算存储驱动器实现存储内《表扫描》。虽然之前的工作与本工作的基本概念相同，但有几个明显的区别:</p>
<ul>
<li>(1) <strong>本工作提出了云原生关系数据库环境下的整体系统解决方案</strong>，并在实际生产环境中证明了其有效性。相比之下，之前的工作在一个计算存储驱动器中运行合成查询，而没有与数据库和系统I/O堆栈集成。之前的工作实现了一个基于在单个服务器上运行的修改过的MySQL的原型。它没有考虑与具有计算-存储解耦架构的数据库系统的集成，也没有考虑在一个服务器中使用多个计算存储驱动器。</li>
<li>(2) 前期工作中使用的计算存储驱动器的基本存储I/O性能指标(即顺序吞吐量和IOPS)远远低于前沿商品NVMe SSD。因此，在以前的工作中，系统倾向于更多的 I/O 约束，因此更容易从存储内《表扫描》中受益。与部署前沿商品NVMe SSD的系统相比，之前工作中显示的好处可能会大大减少。</li>
<li>(3) 之前的工作均使用 SSD 控制器内的嵌入式处理器进行数据处理，但无法匹配 SSD 内多 GB/s 的NAND闪存访问带宽，无法实现高吞吐量谓词评估。</li>
<li>(4)数据压缩被广泛应用于数据库中，以降低存储位的成本。因此，计算存储驱动器必须执行数据解压缩，以支持在数据读取路径上的谓词求值。然而，之前的工作并没有考虑到数据解压缩的实现。</li>
</ul>
<h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h3><p>本文报告了一个内聚的跨软件/硬件实现，使阿里巴巴的云原生关系数据库POLARDB能够有效地支持分析工作负载。基本的设计概念是将分析处理中昂贵的《表扫描》操作从CPU分派到计算存储驱动器。与当前异构计算的工业趋势保持一致，其关键思想非常简单，可以追溯到20多年前。然而，在现实世界中，通过合理的利益与成本的权衡来实际实现这个简单的想法是很重要的。<strong>本工作在阿里巴巴POLARDB的框架下，开发了一套横跨整个软硬件栈的设计解决方案，将这一简单的理念在生产云数据库环境中实际实现</strong>。在7个数据库节点和3个存储节点上的POLARDB云实例上的实验结果表明，在总共22个TPC-H查询中，我们的实现可以使12个TPC-H查询的延迟减少30%以上。同时，我们的实现可以减少超过50%的存储到内存的数据移动量12个TPC-H查询。我们希望这项工作将激发更多的研究和开发工作，以研究未来云基础设施如何利用新兴的计算存储驱动器。</p>
<!-- ### 云原生·关系数据库
为了实现足够的可扩展性和故障恢复能力，云原生关系数据库自然遵循**计算与数据存储分离**的设计原则

###  -->
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E5%AD%98%E5%82%A8/">计算存储</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E5%AD%98%E5%82%A8/">计算存储</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/mnist/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MNIST · 手写识别计算器</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/leetcode/leetcode208/">
                        <span class="hidden-mobile">leetcode208-实现 Trie（前缀树）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'YoujiaZhang/commit-Utterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>hexo</span></a> <i class="iconfont icon-plan"></i> <a href="https://YoujiaZhang.github.io" target="_blank" rel="nofollow noopener"><span>Yj-Zhang</span></a> <i class="iconfont icon-love"></i> <a target="_blank" rel="nofollow noopener"><span>D.H.</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?siteId=17279802";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
