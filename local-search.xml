<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python 编程实现 五子棋 AlphaGobang Zero</title>
    <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/AlphaGoZero/"/>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/AlphaGoZero/</url>
    
    <content type="html"><![CDATA[<h1 id="五子棋-AlphaGo-Zero"><a href="#五子棋-AlphaGo-Zero" class="headerlink" title="五子棋 AlphaGo Zero"></a>五子棋 AlphaGo Zero</h1><ul><li>Do you like to play Gobang ?</li><li>Do you want to know how AlphaGo Zero works ?</li><li><strong>Check it out!</strong><span id="more"></span></li></ul><p><strong>AlphaGo Zero</strong> 不同于 AlphaGo Fan 和 AlphaGo Lee。主要体现在如下几个方面：</p><p><img src="/blog-image/AlphaGoZero/0.png"></p><ul><li>第一点也是最重要的一点，AlphaGo Zero只使用强化学习训练。AlphaGo Zero从白板开始学习，不使用人类监督数据，在自我对弈中，进行强化学习训练。</li><li>第二点：只使用棋盘上黑白棋作为输入特征。不需要人工设计的围棋领域的特征。</li><li>第三点：只使用单一的神经网络。不使用分开的策略网络和值网络。</li><li>第四点：使用简单的树搜索，且树搜索只依赖于上述单一的神经网络，同时进行棋面局势评估和走棋动作选择。抛弃了蒙特卡搜索树中的<strong>Rollouts</strong>（AlphaGo 中的 Rollout Policy）。</li></ul><p>为了实现上述目标，AlphaGo Zero 是用了一种新的强化学习训练算法，将蒙特卡罗树搜索树（MCTS）纳入训练阶段。</p><p><strong>本文的全部代码已经放到了 <a href="https://github.com/YoujiaZhang/AlphaGo-Zero-Gobang">GIthub</a> 仓库</strong></p><p><img src="/blog-image/AlphaGoZero/1.gif"></p><h2 id="强化学习-Policy-Iteration"><a href="#强化学习-Policy-Iteration" class="headerlink" title="强化学习 Policy Iteration"></a>强化学习 Policy Iteration</h2><p><strong>网络</strong> ： 深度残差神经网络 $f_θ$，参数为 $θ$。每个卷积层由许多残差块组成。</p><ul><li><strong>输入</strong> ： 只使用棋面的黑白方的棋面特征 (棋面状态 $s$)</li><li><strong>输出</strong> ： $(p,v)=f_θ(s)$，输出下一步动作的概率分布 $p$ 和收益 $v$。<ul><li>$p$ 是一个向量，代表下一步动作的概率分布 $p(a|s)$, $v$ 是一个值，代表当前下棋方获胜的概率。</li></ul></li></ul><p><img src="/blog-image/AlphaGoZero/1.jpg"></p><p><strong>自我对弈提升</strong> ：</p><p>对于每个棋面 $s$, 使用前一轮得到的神经网络 $f_θ$ 来指导 MCTS 。MCTS 会输出每一步走棋的<strong>概率分布</strong>$π$。 $π$比单纯的神经网络 $f_θ$ 输出 $p$ 概率分布更好，能够选择更有水平的走棋。</p><p><img src="/blog-image/AlphaGoZero/2.jpg"></p><div class="note note-info">            <p>因为神经网络可以看作是 1 次预测，而 MCTS 则是多次的调用神经网络进行预测。    </p>          </div>   <p><strong>AI 左右互搏，不断地使用同一个 MCTS 指导下棋</strong>，最终会分出胜负，将最终的获胜方 $z$ 作为一个样本值，视为当前棋面下的收益。当一盘对局结束后，会收集到很多黑白双方的棋盘状态 $s$ ，神经网络根据每一个棋盘状态 $s$ 进行预测：<br>$$(p,v)=f_θ(s)$$<br>学习的目标就是 $(p,v)$ 尽可能的接近于真实的 $(π,z)$，这个可以通过设计损失函数实现。然后，反向传播更新 $f$ 的参数 $θ$，这个新的 $f_{θ’}$ 将在下一轮自我对弈中继续指导 MCTS，使得其变得更健壮。</p><div class="note note-info">            <p>从这个角度来说，MCTS 可以看做是《Policy Iteration 算法》中的 <strong>策略提升操作</strong>（policy improvement operator）。在自我对弈的过程中，不断使用提升过的、基于 MCTS 的策略 $π$ 来进行决策走棋，最终会决出胜负，将最终的获胜方 $z$ 可以看做是《Policy Iteration 算法》中的 <strong>策略评估操作</strong>（policy evaluation operator），即对当前棋面局势的评估。</p><p>这里强化学习算法的关键是在 《Policy Iteration 算法》过程中，不断重复地使用 <strong>policy improvement</strong> 和 <strong>policy evaluation</strong> 挺高MCTS的决策质量。     </p>          </div>   <h3 id="1-自我对弈数据产生过程"><a href="#1-自我对弈数据产生过程" class="headerlink" title="1 自我对弈数据产生过程"></a>1 自我对弈数据产生过程</h3><p>在一场对弈过程中，我们可以得到不同时刻 $t$ 下的棋盘状态 $s_t$ 以及 MCTS 模拟得到的落子概率分布 $π_t$。<br>$$(s_t,π_t)$$<br>这场对弈最终会分出胜负，得到最后的收益 $r_T, T&gt;t$ (回报分数)，$T$ 就是最终时刻。然后将这个收益贴到每一个 $t$ 的 $z_t$ 上，且满足 $z_t=(+r_T)/(-r_T)$（正负号取决于当前对局最终的获胜者），那么我们就得到了多组训练数据：<br>$$(s_t,π_t,z_t)$$</p><div class="note note-info">            <ul><li> $s_t$ 作为 $f_θ$ 的输入</li><li> $(π_t,z_t)$ 作为标签  </li></ul>          </div> <p>通过损失函数使得神经网络 $f$ 的输出 $(p,v)$ 趋近于 $(π_t,z_t)$。$z_t$ 相当于告诉 AI 应该这盘对弈中应该强化那些落子决策，以及弱化那些落子决策。</p><h3 id="2-决策优化过程"><a href="#2-决策优化过程" class="headerlink" title="2 决策优化过程"></a>2 决策优化过程</h3><p>神经网络 $f$ 首先使用随机权重 $θ$ 进行初始化。然后按照上述描述（<strong>自我对弈数据产生过程</strong>）获得了一大堆构造产生的数据$(s_t,π_t,z_t)$ 作为训练数据。接着，$f(θ_i)$ 使用该训练数据进行参数更新，目标是使得新的 $f(θ_{i+1})$ 的输出 $(p,v)=f(θ_{i+1},s)$ 能够拟合 $(π,z)$，也即最小化 $v$ 和 $z$ 之间的误差，最大化 $p$ 和 $π$ 之间的相似性。</p><p>优化损失函授结合了 <strong>MSE</strong> 和 <strong>cross-entropy Loss</strong>（还包括正则化项）</p><p>$$Loss((θ)=(z-v)^2-π^T·log(p)+c||θ||^2$$</p><h2 id="蒙特卡罗树搜索树-MCTS"><a href="#蒙特卡罗树搜索树-MCTS" class="headerlink" title="蒙特卡罗树搜索树 MCTS"></a>蒙特卡罗树搜索树 MCTS</h2><p>蒙特卡洛树搜索（<strong>M</strong>onte <strong>C</strong>arlo <strong>T</strong>ree <strong>S</strong>earch，<strong>MCTS</strong>）是一种启发式搜索算法，由Coulom在2006年首次提出。他在传统的树形搜索算法的基础上采用了 <strong>蒙特卡洛方法</strong> 进行价值评估，从当前状态开始不断进行随机模拟，然后计算出平均回报率作为对当前状态的估计。搜索有选择地进行迭代，根据估计值加深搜索级别的数量。</p><p><img src="/blog-image/AlphaGoZero/3.png"></p><p>MCTS主要包括 4 个步骤。</p><ul><li><strong>选择（Selection）</strong>：从根节点出发，递归地调用子节点选择策略向搜索树的下方延伸，直到访问到一个终止节点或从未访问过的子节点截止。子节点选择策略也被称为树策略（Tree Policy）。</li><li><strong>扩展（Expansion）</strong>：如果当前节点不是终止节点，则根据当前节点的合法动作添加一个或多个子节点。</li><li><strong>模拟（Simulation）</strong>：从扩展出的新节点出发，基于某种策略（默认策略，Default Policy，通常为随机动作）进行模拟、直到游戏（或问题）结束，得到反馈价值。</li><li><strong>更新（Backpropagation）</strong>：将模拟阶段得到的反馈价值，沿着路径自下而上的向上传播，更新沿途每个节点的估值信息。</li></ul><p>通过不断执行上述的四步操作，蒙特卡洛树搜索便可以迭代地构建出一棵局部增长的不对称搜索树。在进行决策时，只需要根据需要从根节点选择最符合条件的节点对应的动作即可。<strong>迭代次数越大，根据大数定律、算法对于每个节点的估值便越准确，进而基于该流程得到的动作越趋近于最优动作</strong>。</p><h1 id="代码设计细节"><a href="#代码设计细节" class="headerlink" title="代码设计细节"></a>代码设计细节</h1><h2 id="设计-棋盘-amp-游戏"><a href="#设计-棋盘-amp-游戏" class="headerlink" title="设计 棋盘&amp;游戏"></a>设计 棋盘&amp;游戏</h2><p>这里主要是我们如何 <strong>描述</strong> 一个棋盘，以及一场游戏。</p><h3 id="1-描述棋盘"><a href="#1-描述棋盘" class="headerlink" title="1 描述棋盘"></a>1 描述棋盘</h3><h4 id="1-1-主要变量"><a href="#1-1-主要变量" class="headerlink" title="1.1 主要变量"></a>1.1 主要变量</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Board.py</span><br><br><span class="hljs-string">width：棋盘宽</span><br><span class="hljs-string">height：棋盘高</span><br><span class="hljs-string">states：一场对局各方落子的记录</span>    <br><span class="hljs-string">——————————————————————————————————————————</span><br><span class="hljs-string">棋盘状态《states》存储在dict中</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">棋盘上的落子行为</span> <br><span class="hljs-bullet">-</span> <span class="hljs-attr">value:</span> <span class="hljs-string">玩家</span><br>&#123;<span class="hljs-attr">38:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">23:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">24:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">36:</span> <span class="hljs-number">2</span>, <span class="hljs-string">···</span> &#125;<br><span class="hljs-string">玩家1</span> <span class="hljs-string">落子</span> <span class="hljs-number">38</span> <span class="hljs-string">位置</span><br><span class="hljs-string">玩家2</span> <span class="hljs-string">落子</span> <span class="hljs-number">23</span> <span class="hljs-string">位置</span> <br><span class="hljs-string">玩家1</span> <span class="hljs-string">落子</span> <span class="hljs-number">24</span> <span class="hljs-string">位置</span><br><span class="hljs-string">玩家2</span> <span class="hljs-string">落子</span> <span class="hljs-number">36</span> <span class="hljs-string">位置</span>  <span class="hljs-string">···</span><br><span class="hljs-string">——————————————————————————————————————————</span><br><span class="hljs-string">n_in_row：n子棋</span><br><span class="hljs-string">players：玩家列表</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-comment"># player1 和 player2</span><br><span class="hljs-string">current_player：当前玩家</span><br><span class="hljs-string">availables：棋盘剩余可落子的空位</span><br><span class="hljs-string">last_move：最新的一次落子</span><br></code></pre></td></tr></table></figure><h4 id="1-2-主要函数"><a href="#1-2-主要函数" class="headerlink" title="1.2 主要函数"></a>1.2 主要函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">Board.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_move</span>(<span class="hljs-params">self, move</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    落子</span><br><span class="hljs-string">    move：落子的位置 一个整数取值范围 0 到 H*W-1</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    self.states[move] = self.current_player<br>    self.availables.remove(move)  <span class="hljs-comment"># 减少一个可以落子的位置</span><br><br>    <span class="hljs-comment"># 切换玩家角色</span><br>    self.current_player = (<br>        self.players[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> self.current_player == self.players[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span> self.players[<span class="hljs-number">1</span>]<br>    )<br>    self.last_move = move <span class="hljs-comment"># 记录上一次落子的位置</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">current_state</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    以当前 玩家player 角度返回当前棋盘</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 使用 4*W*H 存储棋盘的状态</span><br>    square_state = np.zeros((<span class="hljs-number">4</span>, self.width, self.height))<br><br>    <span class="hljs-keyword">if</span> self.states:<br>        moves, players = np.array(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*self.states.items())))<br>        <span class="hljs-comment"># moves 数组</span><br>        <span class="hljs-comment"># 记录着两个玩家交错的落子位置</span><br><br>        move_curr = moves[players == self.current_player] <span class="hljs-comment"># 当前玩家落子的位置</span><br>        move_oppo = moves[players != self.current_player] <span class="hljs-comment"># 对手玩家落子的位置</span><br><br>        square_state[<span class="hljs-number">0</span>][move_curr // self.width, move_curr % self.height] = <span class="hljs-number">1.0</span> <span class="hljs-comment"># 当前玩家所有落子棋盘</span><br>        square_state[<span class="hljs-number">1</span>][move_oppo // self.width, move_oppo % self.height] = <span class="hljs-number">1.0</span> <span class="hljs-comment"># 对手玩家所有落子棋盘</span><br><br>        <span class="hljs-comment"># 标记最近一次落子位置</span><br>        square_state[<span class="hljs-number">2</span>][self.last_move // self.width, self.last_move % self.height] = <span class="hljs-number">1.0</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.states) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        square_state[<span class="hljs-number">3</span>][:, :] = <span class="hljs-number">1.0</span> <br><br>    <span class="hljs-keyword">return</span> square_state[:, ::-<span class="hljs-number">1</span>, :]<br></code></pre></td></tr></table></figure><h3 id="2-描述游戏"><a href="#2-描述游戏" class="headerlink" title="2 描述游戏"></a>2 描述游戏</h3><h4 id="2-1-主要函数"><a href="#2-1-主要函数" class="headerlink" title="2.1 主要函数"></a>2.1 主要函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python">Game.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selfPlay</span>(<span class="hljs-params">self, player, Index=<span class="hljs-number">0</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">    构建一个AI自我博弈，重用搜索树，并存储自玩数据：(棋盘状态, 落子概率, 胜者预测) 以供训练</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    self.board.initBoard() <span class="hljs-comment"># 初始化一个棋盘</span><br>    boards, probs, currentPlayer = [], [], [] <span class="hljs-comment"># 用以存储相关对局信息</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 当前玩家，针对当前棋盘根据MCTS获取下一步的落子行为</span><br>        move, move_probs = player.getAction(self.board, self.flag_is_train)<br>        <br>        <span class="hljs-comment"># 存储下棋的数据</span><br>        boards.append(self.board.current_state())<br>        probs.append(move_probs)<br>        currentPlayer.append(self.board.current_player)<br><br>        <span class="hljs-comment"># 下棋落子</span><br>        self.board.do_move(move)<br><br>        <span class="hljs-comment"># # 展示下棋的过程</span><br>        <span class="hljs-keyword">if</span> self.flag_is_shown:<br>            self.Show(self.board)<br>        <br>        <span class="hljs-comment"># 是否已经结束</span><br>        gameOver, winner = self.board.gameIsOver()<br><br>        <span class="hljs-keyword">if</span> gameOver:<br>            <span class="hljs-comment"># 根据最终游戏的结果，构造用于训练神经网络的《标签》Z</span><br>            winners_z = np.zeros(<span class="hljs-built_in">len</span>(currentPlayer))<br>            <span class="hljs-keyword">if</span> winner != -<span class="hljs-number">1</span>:<br>                winners_z[np.array(currentPlayer) == winner] = <span class="hljs-number">1.0</span><br>                winners_z[np.array(currentPlayer) != winner] = -<span class="hljs-number">1.0</span><br><br>            <span class="hljs-comment"># 重新设置MCTS，初始化了整棵树</span><br>            player.resetMCTS()<br><br>            <span class="hljs-comment"># 在GUI上显示一些相关信息而已</span><br>            <span class="hljs-keyword">if</span> self.flag_is_shown:<br>                <span class="hljs-keyword">if</span> winner != -<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> self.flag_is_train == <span class="hljs-literal">False</span>:<br>                        playerName = <span class="hljs-string">&#x27;you&#x27;</span><br>                        <span class="hljs-keyword">if</span> self.board.current_player != <span class="hljs-number">1</span>:<br>                            playerName = <span class="hljs-string">&#x27;AI&#x27;</span><br>                    <span class="hljs-keyword">else</span>:<br>                        playerName = <span class="hljs-string">&#x27;AI-&#x27;</span>+<span class="hljs-built_in">str</span>(self.board.current_player)<br>                    self.drawText(<span class="hljs-string">&quot;Game end. Winner is :&quot;</span>+<span class="hljs-built_in">str</span>(playerName))<br>                <span class="hljs-keyword">else</span>:<br>                    self.drawText(<span class="hljs-string">&quot;Game end. Tie&quot;</span>)<br><br>            <span class="hljs-comment"># 这个 rect 用来圈（红圈）出最新一次落子的位置</span><br>            self.rect = <span class="hljs-literal">None</span><br><br>            <span class="hljs-comment"># 返回的这些数据都是很有用的 是神经网络的《学习资料》</span><br>            <span class="hljs-keyword">return</span> winner, <span class="hljs-built_in">zip</span>(boards, probs, winners_z)<br></code></pre></td></tr></table></figure><h2 id="设计-神经网络"><a href="#设计-神经网络" class="headerlink" title="设计 神经网络"></a>设计 神经网络</h2><p>主要是辅助 MCTS 进行决策，神经网络的学习过程可以积累棋盘知识，便于复用。<strong>TensorFlow</strong></p><h3 id="1-残差网络"><a href="#1-残差网络" class="headerlink" title="1 残差网络"></a>1 残差网络</h3><p><img src="/blog-image/AlphaGoZero/4.png"></p><h4 id="1-1-基本层-模块化"><a href="#1-1-基本层-模块化" class="headerlink" title="1.1 基本层-模块化"></a>1.1 基本层-模块化</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs nix">PolicyNN.py  Class: ResidualCNN<br><br><span class="hljs-comment"># 卷积层模板</span><br>def ConvLayer(self, input_block, filters, kernel_size):<br>    <span class="hljs-attr">output</span> = Conv2D(<br>        <span class="hljs-attr">filters</span> = filters,              <span class="hljs-comment"># 卷积滤波器个数</span><br>        <span class="hljs-attr">kernel_size</span> = kernel_size,      <span class="hljs-comment"># 卷积滤波器的尺寸 (3,3),(5,5)</span><br>        <span class="hljs-attr">data_format=&quot;channels_first&quot;,</span>   <span class="hljs-comment"># 表示输入张量中维度的顺序</span><br>        <span class="hljs-attr">padding</span> = &#x27;same&#x27;,               <span class="hljs-comment"># 边缘填充</span><br>        <span class="hljs-attr">use_bias=False,</span>                 <span class="hljs-comment"># 该层是否使用偏置向量</span><br>        <span class="hljs-attr">activation=&#x27;linear&#x27;,</span>            <span class="hljs-comment"># 线性激活函数</span><br>        <span class="hljs-attr">kernel_regularizer</span> = l2(self.L2) <span class="hljs-comment"># L2正则化项</span><br>    )(input_block)<br>    <span class="hljs-attr">output</span> = BatchNormalization(<span class="hljs-attr">axis=1)(output)</span> <span class="hljs-comment"># 批量标准化层 </span><br>    <span class="hljs-attr">output</span> = LeakyReLU()(output)<br>    return (output)、<br><br><span class="hljs-comment"># 残差卷积层模板</span><br>def ResLayer(self, input_block, filters, kernel_size):<br>    <span class="hljs-attr">output</span> = Conv2D(<br>        <span class="hljs-attr">filters</span> = filters,              <span class="hljs-comment"># 卷积滤波器个数</span><br>        <span class="hljs-attr">kernel_size</span> = kernel_size,      <span class="hljs-comment"># 卷积滤波器的尺寸 (3,3),(5,5)</span><br>        <span class="hljs-attr">data_format=&quot;channels_first&quot;,</span>   <span class="hljs-comment"># 表示输入张量中维度的顺序</span><br>        <span class="hljs-attr">padding</span> = &#x27;same&#x27;,               <span class="hljs-comment"># 边缘填充</span><br>        <span class="hljs-attr">use_bias=False,</span>                 <span class="hljs-comment"># 该层是否使用偏置向量</span><br>        <span class="hljs-attr">activation=&#x27;linear&#x27;,</span>            <span class="hljs-comment"># 线性激活函数</span><br>        <span class="hljs-attr">kernel_regularizer</span> = l2(self.L2) <span class="hljs-comment"># L2正则化项</span><br>    )(input_block)<br>    <span class="hljs-attr">output</span> = BatchNormalization(<span class="hljs-attr">axis=1)(output)</span> <span class="hljs-comment"># 批量标准化层 </span><br>    <span class="hljs-attr">output</span> = LeakyReLU()(output)                <span class="hljs-comment"># 激活函数</span><br><br>    <span class="hljs-attr">output</span> = Conv2D(<br>        <span class="hljs-attr">filters</span> = filters,              <span class="hljs-comment"># 卷积滤波器个数</span><br>        <span class="hljs-attr">kernel_size</span> = kernel_size,      <span class="hljs-comment"># 卷积滤波器的尺寸 (3,3),(5,5)</span><br>        <span class="hljs-attr">data_format=&quot;channels_first&quot;,</span>   <span class="hljs-comment"># 表示输入张量中维度的顺序</span><br>        <span class="hljs-attr">padding</span> = &#x27;same&#x27;,               <span class="hljs-comment"># 边缘填充</span><br>        <span class="hljs-attr">use_bias=False,</span>                 <span class="hljs-comment"># 该层是否使用偏置向量</span><br>        <span class="hljs-attr">activation=&#x27;linear&#x27;,</span>            <span class="hljs-comment"># 线性激活函数</span><br>        <span class="hljs-attr">kernel_regularizer</span> = l2(self.L2) <span class="hljs-comment"># L2正则化项</span><br>    )(output)<br>    <span class="hljs-attr">output</span> = BatchNormalization(<span class="hljs-attr">axis=1)(output)</span> <span class="hljs-comment"># 批量标准化层 </span><br>    <span class="hljs-attr">output</span> = add([input_block, output])         <span class="hljs-comment"># 拼接输入各个张量的和</span><br>    <span class="hljs-attr">output</span> = LeakyReLU()(output)                <span class="hljs-comment"># 激活函数</span><br>    return (output)<br></code></pre></td></tr></table></figure><h4 id="1-2-预测对象"><a href="#1-2-预测对象" class="headerlink" title="1.2 预测对象"></a>1.2 预测对象</h4><p>$ValueHead$ 是神经网络预测的第 $1$ 个值。也就是在棋盘的某一处落子，未来的收益是多少（赢或者输）。  </p><p>$PolicyHead$ 是神经网络预测的第 $2$ 个值。落子概率分布，有些地方概率大表示《NN认为此处更应该落子》。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs routeros">PolicyNN.py  Class: ResidualCNN<br><br>def ValueHead(self, output):<br>    conv = Conv2D(<br>        filters = 1 ,                  <br>        kernel_size = (1,1) , <br>        <span class="hljs-attribute">data_format</span>=<span class="hljs-string">&quot;channels_first&quot;</span> , <br>        padding = <span class="hljs-string">&#x27;same&#x27;</span>, <br>        <span class="hljs-attribute">use_bias</span>=<span class="hljs-literal">False</span>, <br>        <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;linear&#x27;</span>, <br>        kernel_regularizer = l2(self.L2)<br>    )(output)<br>    conv = BatchNormalization(<span class="hljs-attribute">axis</span>=1)(conv)<br>    conv = LeakyReLU()(conv)<br>    flatten = Flatten()(conv)<br><br>    dense = Dense(<br>        32, # 输出空间维度<br>        <span class="hljs-attribute">use_bias</span>=<span class="hljs-literal">False</span>, <br>        <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;linear&#x27;</span>, <br>        <span class="hljs-attribute">kernel_regularizer</span>=l2(self.L2)<br>    )(flatten)<br>    dense = LeakyReLU()(dense)<br>    dense = Dense(<br>        1, <br>        <span class="hljs-attribute">use_bias</span>=<span class="hljs-literal">False</span>, <br>        <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;tanh&#x27;</span>, <br>        <span class="hljs-attribute">kernel_regularizer</span>=l2(self.L2), <br>        name = <span class="hljs-string">&#x27;ValueHead&#x27;</span><br>    )(dense)<br>    return (dense)<br><br>def PolicyHead(self, output):<br>    conv = Conv2D(<br>        filters = 2, <br>        kernel_size = (1,1), <br>        <span class="hljs-attribute">data_format</span>=<span class="hljs-string">&quot;channels_first&quot;</span>, <br>        padding = <span class="hljs-string">&#x27;same&#x27;</span>, <br>        <span class="hljs-attribute">use_bias</span>=<span class="hljs-literal">False</span>, <br>        <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;linear&#x27;</span>, <br>        kernel_regularizer = l2(self.L2)<br>    )(output)<br>    conv = BatchNormalization(<span class="hljs-attribute">axis</span>=1)(conv)<br>    conv = LeakyReLU()(conv)<br>    conv = Flatten()(conv)<br>    dense = Dense(<br>        self.output_dim, <br>        <span class="hljs-attribute">use_bias</span>=<span class="hljs-literal">False</span>, <br>        <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;softmax&#x27;</span>, <br>        <span class="hljs-attribute">kernel_regularizer</span>=l2(self.L2), <br>        name = <span class="hljs-string">&#x27;PolicyHead&#x27;</span><br>    )(conv)<br>    return (dense)<br></code></pre></td></tr></table></figure><h4 id="1-3-损失函数"><a href="#1-3-损失函数" class="headerlink" title="1.3 损失函数"></a>1.3 损失函数</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gradle">PolicyNN.py  <span class="hljs-keyword">Class</span>: ResidualCNN<br><br>model.<span class="hljs-keyword">compile</span>(<br>    loss=&#123;<br>        <span class="hljs-string">&#x27;ValueHead&#x27;</span>: <span class="hljs-string">&#x27;mean_squared_error&#x27;</span>, <br>        <span class="hljs-string">&#x27;PolicyHead&#x27;</span>: <span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span><br>    &#125;,<br>    optimizer=Adam(),<br>    loss_weights=&#123;<br>        <span class="hljs-string">&#x27;ValueHead&#x27;</span>: <span class="hljs-number">0.5</span>, <br>        <span class="hljs-string">&#x27;PolicyHead&#x27;</span>: <span class="hljs-number">0.5</span><br>    &#125;)<br></code></pre></td></tr></table></figure><ul><li>$ValueHead$ 应该和真实的输赢收益越接近越好，采用 MSE 损失。    </li><li>$PolicyHead$ 应该和真实的概率分布越接近越好，采用 cross-entropy 损失。</li></ul><h3 id="2-决策网络"><a href="#2-决策网络" class="headerlink" title="2 决策网络"></a>2 决策网络</h3><p>决策网络主要的核心还是我们构建的残差网络。由于我们的训练数据集是根据《自我对弈》动态生成的，所以我们还得 <strong>良好</strong> 的存储所收集的数据。</p><p><strong>数据池</strong>。我们始终维护这个数据池的大小（<code>trainDataPoolSize</code>）不变，将新产生的数据加入到数据池中，如果数据池已经满了就会删除掉最久的数据以空出位置。在每次训练神经网络时，我们没有直接使用前一轮自我对弈产生的数据进行训练，而是从数据池中随机地选择（<code>random.sample</code>）一批数据（大小为 <code>trainBatchSize</code>）进行训练。由于大部分抽样数据来自于不同的游戏回合，数据之间的相关性在一定程度上得到了解决。同时，这种方法还可以解决策略的非静止分布问题。使用单轮下棋产生的数据所学到的策略分布之间可能有很大的差异。但如果数据是由多轮比赛产生的，结果就会在一定程度上趋于平稳。</p><p><strong>学习率更新</strong>。根据 <strong>KL散度</strong> 变化情况调整、或根据损失变化调整学习率。</p><p><img src="/blog-image/AlphaGoZero/7.jpg"></p><h4 id="2-1-主要变量"><a href="#2-1-主要变量" class="headerlink" title="2.1 主要变量"></a>2.1 主要变量</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">trainDataPoolSize</span> = <span class="hljs-number">18000</span>*<span class="hljs-number">2</span> <span class="hljs-comment"># 用以存储训练网络的数据</span><br><span class="hljs-attr">trainBatchSize</span> = <span class="hljs-number">1024</span>*<span class="hljs-number">2</span>     <span class="hljs-comment"># 每次从数据池(trainDataPool)中随机采样出的一批训练数据</span><br><br><span class="hljs-attr">trainDataPool</span> = deque(maxlen=trainDataPoolSize) <span class="hljs-comment"># 训练数据池</span><br><br><span class="hljs-attr">kl_targ</span> = <span class="hljs-number">0.02</span><br><span class="hljs-attr">learningRate</span> = <span class="hljs-number">2</span>e-<span class="hljs-number">3</span> <span class="hljs-comment"># 学习率 </span><br><span class="hljs-attr">LRfctor</span> = <span class="hljs-number">1.0</span>       <span class="hljs-comment"># 适应性地调整学习率</span><br></code></pre></td></tr></table></figure><h4 id="2-2-主要函数"><a href="#2-2-主要函数" class="headerlink" title="2.2 主要函数"></a>2.2 主要函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python">PolicyNN.py  Class: PolicyValueNet<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_DataAugmentation</span>(<span class="hljs-params">self, play_data</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    通过旋转和翻转来增加数据集</span><br><span class="hljs-string">    play_data: [(棋盘状态, 落子概率, 胜者预测), ..., ...]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 扩展之后的数据集</span><br>    extendData = []<br>    <span class="hljs-keyword">for</span> board, porbs, winner <span class="hljs-keyword">in</span> play_data:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]:<br>            <span class="hljs-comment"># 逆时针旋转</span><br>            <span class="hljs-comment"># -------------------------------------------------</span><br>            <span class="hljs-comment"># 旋转每一个棋盘棋子状态</span><br>            equi_board = np.array([np.rot90(b,i) <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> board])<br>            <span class="hljs-comment"># 旋转每一个棋盘上的概率分布</span><br>            equi_porbs = np.rot90(np.flipud(porbs.reshape(self.input_dim[<span class="hljs-number">1</span>], self.input_dim[<span class="hljs-number">2</span>])), i)<br>            extendData.append((equi_board, np.flipud(equi_porbs).flatten(), winner)) <span class="hljs-comment"># 扩展数据</span><br>            <br>            <span class="hljs-comment"># 水平翻转</span><br>            <span class="hljs-comment"># -------------------------------------------------</span><br>            equi_board = np.array([np.fliplr(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> equi_board])<br>            equi_porbs = np.fliplr(equi_porbs)<br>            extendData.append((equi_board, np.flipud(equi_porbs).flatten(), winner)) <span class="hljs-comment"># 扩展数据</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">memory</span>(<span class="hljs-params">self, play_data</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    存储训练数据</span><br><span class="hljs-string">    play_data: [(棋盘状态, 落子概率, 胜者预测), ..., ...]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将收集到的自我对弈数据进行《数据增强》</span><br>    play_data = self.get_DataAugmentation(<span class="hljs-built_in">list</span>(play_data)[:])<br>    self.trainDataPool.extend(play_data) <span class="hljs-comment"># 加入训练数据池中</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, scrollText</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        更新预测网络的参数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 从数据池中随即采样一批数据进行训练</span><br>        trainBatchSize = random.sample(self.trainDataPool, self.trainBatchSize)<br>        <br>        <span class="hljs-comment"># trainBatchSize 三元组</span><br>        <span class="hljs-comment"># 棋盘状态 + 落子概率分布 + 胜者预测</span><br>        batchBoard  = [data[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> trainBatchSize]<br>        batchProbs  = [data[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> trainBatchSize]<br>        batchWinner = [data[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> trainBatchSize]<br><br>        <span class="hljs-comment"># 返回这一批训练数据样本的模型预测值</span><br>        <span class="hljs-comment"># 也就是首先记录下当前模型的预测水平</span><br>        batchProbsOld, batchValueOld = self.model.predict_on_batch(np.array(batchBoard))<br><br>        pbar = tqdm(<span class="hljs-built_in">range</span>(self.epochs),ncols=<span class="hljs-number">35</span>)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> pbar:<br>            ···<br>            <span class="hljs-comment"># 根据这批训练数据，对模型进行训练</span><br>            loss = self.train(batchBoard, batchProbs, batchWinner, self.learningRate*self.LRfctor)<br><br>            <span class="hljs-comment"># 返回训练之后模型预测值</span><br>            batchProbsNew, batchValueNew = self.model.predict_on_batch(np.array(batchBoard))<br><br>            <span class="hljs-comment"># 计算Kullback-Leibler散度 恒两个前后两次 概率分布预测值的差异</span><br>            kl = np.mean(np.<span class="hljs-built_in">sum</span>(batchProbsOld * (np.log(batchProbsOld + <span class="hljs-number">1e-10</span>) - np.log(batchProbsNew + <span class="hljs-number">1e-10</span>)),axis=<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">if</span> kl &gt; self.kl_targ * <span class="hljs-number">4</span>:  <span class="hljs-comment"># 如果KL散度严重发散，则提前停止使用</span><br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># 更新学习率</span><br>        <span class="hljs-keyword">if</span> kl &gt; self.kl_targ * <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> self.LRfctor &gt; <span class="hljs-number">0.1</span>:<br>            self.LRfctor /= <span class="hljs-number">1.5</span><br>        <span class="hljs-keyword">elif</span> kl &lt; self.kl_targ / <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> self.LRfctor &lt; <span class="hljs-number">10</span>:<br>            self.LRfctor *= <span class="hljs-number">1.5</span><br>        <br>        <span class="hljs-keyword">return</span> loss<br></code></pre></td></tr></table></figure><h2 id="MCTS"><a href="#MCTS" class="headerlink" title="MCTS"></a>MCTS</h2><h3 id="1-主要步骤"><a href="#1-主要步骤" class="headerlink" title="1 主要步骤"></a>1 主要步骤</h3><h4 id="1-1-选择"><a href="#1-1-选择" class="headerlink" title="1.1 选择"></a>1.1 选择</h4><p>从根节点(root)出发，递归地调用 <strong>子节点选择策略</strong> 向搜索树的下方延伸，直到访问到一个终止节点或从未访问过的子节点截止。子节点选择策略也被称为树策略（Tree Policy），通常使用表达式（如下）作为选择依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">TreeNode.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select</span>(<span class="hljs-params">self, factor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    选择：根据《策略》选择落子动作</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 选择所有孩子中《分数》最高</span><br>    <span class="hljs-comment">#  act_node[1] &lt;TreeNode&gt;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.children.items(), key=<span class="hljs-keyword">lambda</span> act_node: act_node[<span class="hljs-number">1</span>].getValue(factor))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getValue</span>(<span class="hljs-params">self, factor</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算每个节点的《价值》，用以选择</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    self.U = (factor * self.P *np.sqrt(self.father.N_visits) / (<span class="hljs-number">1</span> + self.N_visits))<br>    <span class="hljs-keyword">return</span> self.Q + self.U<br></code></pre></td></tr></table></figure><p>$$f_{select}(x)=\textbf{max}(Q_i+U_i),i=leaf_{each-one}$$</p><p>$$Q_{new}=Q_{old}+\frac{Value_{leaf}-Q_{old}}{N_{visit}}$$</p><p>$$U=a·P·\frac{[(hisFather)N_{visit}]^{1/2}}{N_{visit}+1}$$</p><p>其中 $Q$ 是该节点的估计价值，$Value_{leaf}$ 是神经网络预测的第 $1$ 个值，也就是落子此处未来的收益有多大，$N_{visit}$ 是该节点的访问次数，$P$ 是此节点的落子概率（神经网络预测的第 $2$ 个值），$U$ 是平衡因子，$a$ 就是代码中的 <code>factor</code> 变量，是一个从 $0$ 到正无穷的调节因子。</p><p>$U$ 跟访问次数有关，没有被访问过的节点会被优先考虑，也是增强了探索广度。</p><ul><li>如果 <code>factor</code> 越小，MCTS 搜索中的探索广度就越低，对神经网络预测的先验概率 $P$ 的关注就越少。如果 <code>factor</code> 太大，探索广度就太高了，它太依赖于神经网络预测的先验概率 $P$，它不太重视 MCTS 模拟积累得到的结果。因此，需要一个合理折中的 factor 值。</li></ul><h4 id="1-2-扩展"><a href="#1-2-扩展" class="headerlink" title="1.2 扩展"></a>1.2 扩展</h4><p>如果当前节点是叶子节点（无子），则根据当前节点的所有可能的《动作》添加一个或多个子节点。<br>扩展节点需要提供两个值：<code>action</code>，<code>prob</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">TreeNode.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expand</span>(<span class="hljs-params">self, action_priors</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    扩展：增加叶子节点的孩子</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># action_priors：(落子动作a，该位置的概率p)</span><br>    <span class="hljs-keyword">for</span> action, prob <span class="hljs-keyword">in</span> action_priors:<br>        <span class="hljs-keyword">if</span> action <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.children:<br>            self.children[action] = TreeNode(self, prob)<br></code></pre></td></tr></table></figure><p><code>action</code>，<code>prob</code> 都是通过神经网络根据当前的棋盘预测出来的结果。</p><h4 id="1-3-模拟"><a href="#1-3-模拟" class="headerlink" title="1,3 模拟"></a>1,3 模拟</h4><p>传统的 MCTS 就是通过蒙特卡洛方法随机采样来预测 <code>action</code>，<code>prob</code>。<br>这里我们使用残差网络进行预测。因为神经网络可以积累学习到的知识。</p><h4 id="1-4-更新"><a href="#1-4-更新" class="headerlink" title="1,4 更新"></a>1,4 更新</h4><p>$Value_{leaf}$ 是神经网络预测的价值收益。将叶子节点的 $Value_{leaf}$，沿着路径自下而上的向上传播，更新沿途每个节点的估值信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">TreeNode.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, leaf_value</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    更新：更新节点的数值</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># leaf_value: 从当前选手的身份《评估》叶子节点的价值，也就是走这一步预计带来的收益。</span><br>    self.N_visits += <span class="hljs-number">1</span><br>    self.Q += <span class="hljs-number">1.0</span>*(leaf_value - self.Q) / self.N_visits<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateRecursive</span>(<span class="hljs-params">self, leaf_value</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    回溯：递归更新从叶子到根上的所有节点</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 如果这个节点是有父亲，优先更新该节点的父亲</span><br>    <span class="hljs-keyword">if</span> self.father:<br>        ···<br>        self.father.updateRecursive(-leaf_value)<br>    self.update(leaf_value)<br></code></pre></td></tr></table></figure><hr><h3 id="2-MCTS类"><a href="#2-MCTS类" class="headerlink" title="2 MCTS类"></a>2 MCTS类</h3><p><code>TreeNode.py</code> 中已经将 MCTS 的基本动作设计完成，然后设计 <code>MCTS.py</code>。<strong>MCTS类主要是为AI做出落子决策。</strong></p><h4 id="2-1-推演"><a href="#2-1-推演" class="headerlink" title="2.1 推演"></a>2.1 推演</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python">MCTS.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">playout</span>(<span class="hljs-params">self, state</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    推演： 从根到叶进行推演，在叶上获取一个值，并通过其父级将其传播回来。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    node = self.root<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 如果，是叶子节点就跳出</span><br>        <span class="hljs-keyword">if</span> node.isLeaf():<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 否则</span><br>        <span class="hljs-comment">#   就选择该节点所有孩子中《分数》最高的。</span><br>        <span class="hljs-comment">#       action：落子动作</span><br>        <span class="hljs-comment">#       node：孩子节点</span><br>        action, node = node.select(self.fator)<br>        state.do_move(action)<br>    <span class="hljs-comment"># ---------------------------------------------------</span><br>    <span class="hljs-comment"># 在原本的MCTS中，《评估》操作采用蒙特卡洛的方法，通过随机下棋</span><br>    <span class="hljs-comment"># 模拟走完一次完整棋局 (称为 rollout), 得到胜负结果。模拟的结果反应在 leaf_value 变量中</span><br>    <span class="hljs-comment"># ---------------------------------------------------</span><br>    <span class="hljs-comment"># 根据当前的《状态(棋盘)》使用神经网络预测：下一步所有的动作以及</span><br>    <span class="hljs-comment"># 对应的概率 + 此步未来的收益</span><br>    action_probs, leaf_value = self.policy_NN(state)<br><br>    <span class="hljs-comment"># 检查一下当前《状态》是不是已经分出胜负</span><br>    gameOver, winner = state.gameIsOver()<br><br>    <span class="hljs-comment"># 如果这盘棋还没结束</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> gameOver:<br>        <span class="hljs-comment"># 扩展当前节点</span><br>        node.expand(action_probs)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 平局</span><br>        <span class="hljs-keyword">if</span> winner == -<span class="hljs-number">1</span>:<br>            leaf_value = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果《模拟/预测》的结果，获胜的是当前的玩家，+1分 否则 -1分</span><br>            leaf_value = (<br>                <span class="hljs-number">1.0</span> <span class="hljs-keyword">if</span> winner == state.getCurrentPlayer() <span class="hljs-keyword">else</span> -<span class="hljs-number">1.0</span><br>            )<br>    <br>    <span class="hljs-comment"># 根据神经网络的预测结果 leaf_value</span><br>    <span class="hljs-comment"># 自下而上《更新》叶子</span><br>    node.updateRecursive(-leaf_value)<br></code></pre></td></tr></table></figure><p>推演（<code>playout</code>）就是一整套 MCTS 动作，<strong>选择–&gt;模拟–&gt;扩展–&gt;更新</strong>。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">action_probs, leaf_value = <span class="hljs-literal">self</span>.policy_NN(<span class="hljs-keyword">state</span>) <span class="hljs-comment">#此处体现了神经网络是如何指导蒙特卡罗搜索的。</span><br></code></pre></td></tr></table></figure><h4 id="2-2-落子"><a href="#2-2-落子" class="headerlink" title="2.2 落子"></a>2.2 落子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">MCTS.py<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMoveProbs</span>(<span class="hljs-params">self, state, flag_is_train</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    获取落子依据：按顺序进行所有推演(playout)，并返回可用操作(落子)及其相应的概率。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># state：当前游戏棋盘的状态。</span><br>    <span class="hljs-comment"># 在（0，1）中控制探测(exploration)程序</span><br>    exploration = <span class="hljs-number">1.0</span> <span class="hljs-keyword">if</span> flag_is_train <span class="hljs-keyword">else</span> <span class="hljs-number">1e-3</span><br><br>    <span class="hljs-comment"># 根据当前棋盘状态，经过 simulations 次数的模拟</span><br>    <span class="hljs-comment"># 构建出了一个 MCTS 树，根节点是依托于当前棋盘。</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.simulations):<br>        state_copy = copy.deepcopy(state)<br>        self.playout(state_copy)<br><br>    <span class="hljs-comment"># 根据 MCTS 根节点，获取下一步落子的决策</span><br>    act_visits = [(act, node.N_visits) <span class="hljs-keyword">for</span> act, node <span class="hljs-keyword">in</span> self.root.children.items()]<br>    acts, visits = <span class="hljs-built_in">zip</span>(*act_visits)<br>    act_probs = softmax(<span class="hljs-number">1.0</span>/exploration * np.log(np.array(visits) + <span class="hljs-number">1e-10</span>))<br><br>    <span class="hljs-comment"># 落子的位置 + 每一个位置的胜率</span><br>    <span class="hljs-keyword">return</span> acts, act_probs<br></code></pre></td></tr></table></figure><p>其中 <code>simulations</code> 为推演的次数，根据大数定律推演的次数越多，对未来的估计就会越准确（<strong>大数定律</strong>）。但是尽管当推演次数足够多时，该算法会收敛，但收敛速度不佳。当推演结束之后，就可以获取根节点（root）所有孩子中得分最高的那个地方行动（落子）。</p><h4 id="2-3-继承-amp-更新-root"><a href="#2-3-继承-amp-更新-root" class="headerlink" title="2.3 继承&amp;更新 root"></a>2.3 继承&amp;更新 root</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updateMCTS</span>(<span class="hljs-params">self, move</span>):</span><br>    <span class="hljs-keyword">if</span> move <span class="hljs-keyword">in</span> self.root.children:<br>        <span class="hljs-comment"># 延续这棵树，更新树根</span><br>        self.root = self.root.children[move]<br>        self.root.father = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 只有当整个对局结束，才重置整棵MCTS</span><br>        self.root = TreeNode(<span class="hljs-literal">None</span>, <span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure><ul><li>在AI自我对弈中，只有当对弈结束时，MCTS才会初始化，否则就会一直沿用同一颗树进行落子决策 <strong>《同一个人左右互搏》</strong></li><li>在于AI对战过程中，AI每走一步就根据当前棋盘建立一棵树，树高为2（root + children），选择一处进行落子，并使 MCTS 才会初始化。</li></ul><h3 id="3-AI-player"><a href="#3-AI-player" class="headerlink" title="3 AI player"></a>3 AI player</h3><p>封装一个完整的AI玩家 主要的动作就一个《落子》</p><h4 id="3-1-落子"><a href="#3-1-落子" class="headerlink" title="3.1 落子"></a>3.1 落子</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def getAction(self, <span class="hljs-keyword">board, </span>flag_is_train):<br>    <span class="hljs-comment"># 获得当前棋盘中可以落子的地方</span><br>    emptySpacesBoard = <span class="hljs-keyword">board.availables</span><br><span class="hljs-keyword"></span><br>    <span class="hljs-comment"># move_probs 的尺寸是整个棋盘的大小</span><br>    <span class="hljs-comment"># 每一个格子上存放着此处落子的概率</span><br>    <span class="hljs-keyword">move_probs </span>= np.zeros(<span class="hljs-keyword">board.width </span>* <span class="hljs-keyword">board.height)</span><br><span class="hljs-keyword"></span><br>    if len(emptySpacesBoard) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 基于 MCTS 获取下一步的落子行为，以及对应每一个位置胜率</span><br>        acts, probs = self.MCTS.getMoveProbs(<span class="hljs-keyword">board, </span>flag_is_train)<br>        <span class="hljs-keyword">move_probs[list(acts)] </span>= probs<br>        <br>        if flag_is_train:<br>            <span class="hljs-comment"># 添加《Dirichlet Noise》进行探索（自我对弈训练所需）</span><br>            <span class="hljs-keyword">move </span>= np.random.choice( <span class="hljs-comment"># 随机抽取</span><br>                acts, <span class="hljs-comment"># 落子行为</span><br>                p=<span class="hljs-number">0</span>.<span class="hljs-number">75</span>*probs + <span class="hljs-number">0</span>.<span class="hljs-number">25</span>*np.random.<span class="hljs-keyword">dirichlet(0.3*np.ones(len(probs)))</span><br><span class="hljs-keyword"></span>            )<br>            <span class="hljs-comment"># 自下而上更新根节点并重用 MCTS</span><br>            <span class="hljs-comment"># AI 相当于是《同一个人左右互搏》使用同一棵MCTS进行对我对弈</span><br>            self.MCTS.updateMCTS(<span class="hljs-keyword">move)</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">        else:</span><br>            <span class="hljs-comment"># 非训练</span><br>            <span class="hljs-comment"># ------------------------------------</span><br>            <span class="hljs-comment"># 更新根节点并使用默认的temp=1e-3重用搜索树</span><br>            <span class="hljs-comment"># 这几乎等同于选择prob最高的移动</span><br>            <span class="hljs-keyword">move </span>= np.random.choice(acts, p=probs)<br>            <span class="hljs-comment"># 重置 MCTS</span><br>            self.MCTS.updateMCTS(-<span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-comment"># 依据概率选择下一步落子的位置，以及当前棋盘的所有位置的概率（分布）</span><br>        return <span class="hljs-keyword">move, </span><span class="hljs-keyword">move_probs</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">    else:</span><br>        print(<span class="hljs-string">&quot;WARNING: the board is full&quot;</span>)<br></code></pre></td></tr></table></figure><p>值得一提的是，当 AI 根据当前的棋盘获取了全局落子决策的时候，AI不是简单进行依概率 <code>probs</code> 采样，而是加入了 <strong>《Dirichlet Noise》</strong> 。</p><ul><li>噪声比为 $0.0$ ：没有任何噪声，这可能使得训练期间的广度探索的程度很低，不能完全搜寻巨大的状态空间，导致最终性能不佳。</li><li>噪声比为 $0.8$ ：可能是噪声比例太大，AI无法起到“深入钻研”的效果，精力太过分散。</li></ul><p>所以我们需要选择合适的噪声比例。</p><p><strong>附录：</strong><br><img src="/blog-image/AlphaGoZero/5.png"></p><blockquote><p>The Dirichlet distribution is parameterised by the vector α, which has the same number of elements K as our multinomial parameter θ. So you can interpret p(θ|α) as answering the question “what is the probability density associated with multinomial distribution θ, given that our Dirichlet distribution has parameter α.”<br><img src="/blog-image/AlphaGoZero/6.png"><br>PS: Dirichlet distribution on a 2-simplex (equilateral triangle) for different values of α.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MNIST · 手写识别计算器</title>
    <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/mnist/"/>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/mnist/</url>
    
    <content type="html"><![CDATA[<h1 id="MNIST-·-手写识别计算器"><a href="#MNIST-·-手写识别计算器" class="headerlink" title="MNIST · 手写识别计算器"></a>MNIST · 手写识别计算器</h1><ul><li>扩展 MNIST 数据，新增 +, -, ×, ÷ 以及 (, )</li><li>CNN 可视化</li><li>python GUI<!-- more --></li></ul><p>使用 TensorFlow 构建一个简单的卷积神经网络，并使用 MNIST 数据集训练它识别手写数字。在 MNIST 数据集上训练分类器可以看作是图像识别的 “<strong>hello world</strong>”。MNIST 包含 70,000 张手写数字图像: 60,000 训练集，10,000 测试集。都是灰度图像，28x28像素的，并且居中的，以减少预处理和加快运行。</p><div class="note note-success">            <p><strong>那么，为了增强应用的可用性，我们能不能改善一下 ，让其能处理常见的数学表达式呢？</strong></p>          </div><p>这要求我们的应用既能识别数字和符号，又能识别同时出现的多个字符：首先对于多个数字这种情况，我们很自然地想到，既然MNIST模型已经能很好地识别单个数字，那我们只需要把多个数字分开，一个一个地让 MNIST 模型进行识别就好了；对于识别其他数学符号，我们可以尝试通过扩展 MNIST 模型的识别范围，也即扩展 MNIST 数据集来实现。两者合二为一，就是一种非常可行的解决方案。这样，我们就引入了两个新的子问题：</p><ul><li>MNIST 数据集扩展</li><li>分割多个手写字符</li></ul><p>最终实现的样子如下图所示，<strong>本文的全部代码已经放到了 <a href="https://github.com/YoujiaZhang/MNIST-Calculator-Handwriting-recognition">GIthub</a> 仓库</strong></p><p><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/0.jpg"></p><h2 id="MNIST-数据集扩展"><a href="#MNIST-数据集扩展" class="headerlink" title="MNIST 数据集扩展"></a>MNIST 数据集扩展</h2><p>在原始 MNIST 数据集中我们看到整数 0-9 被用来标记对应的图形。因为我们此处要解决的是多分类问题，解决这类问题的一个先决条件就是我们必须为每个分类提供一一对应的标记。我们很容易就想到用诸如 10、11、12 来标记加号、减号、乘号等图形类别。</p><p>扩展数据集 33895  <strong><a href="https://github.com/YoujiaZhang/MNIST-Calculator-Handwriting-recognition/blob/master/models/cfs.tar.xz">数据集位置</a></strong></p><table><thead><tr><th>add</th><th align="center">mul</th><th align="center">div</th><th align="center">sub</th><th align="center">(</th><th>)</th></tr></thead><tbody><tr><td><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/add.jpg"></td><td align="center"><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/mul.jpg"></td><td align="center"><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/div.jpg"></td><td align="center"><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/sub.jpg"></td><td align="center"><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/(.jpg"></td><td><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/).jpg"></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python">train.ipynb<br><br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> queue<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getListFiles</span>(<span class="hljs-params">path</span>):</span><br>    ret = []<br>    <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(path):  <br>        <span class="hljs-keyword">for</span> filespath <span class="hljs-keyword">in</span> files:<br>            ret.append(os.path.join(root,filespath)) <br>    <span class="hljs-keyword">return</span> ret<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_images_labels</span>():</span><br>    operators = [<span class="hljs-string">&#x27;plus&#x27;</span>, <span class="hljs-string">&#x27;sub&#x27;</span>, <span class="hljs-string">&#x27;mul&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>]<br>    images = <span class="hljs-literal">None</span><br>    labels = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> i, op <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(operators):<br>        image_file_list = getListFiles(<span class="hljs-string">&#x27;./cfs/&#x27;</span> + op + <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在载入 &#x27;</span> + op + <span class="hljs-string">&#x27; 运算符...&#x27;</span>)<br>        <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> tqdm(image_file_list):<br>            image = cv2.imread(filename, <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> image.shape != (<span class="hljs-number">28</span>, <span class="hljs-number">28</span>):<br>                image = cv2.resize(image, (<span class="hljs-number">28</span>, <span class="hljs-number">28</span>))<br>            image = np.resize(image, (<span class="hljs-number">1</span>, <span class="hljs-number">28</span> * <span class="hljs-number">28</span>))<br>            image = (<span class="hljs-number">255</span> - image) / <span class="hljs-number">255</span><br>            label = np.zeros((<span class="hljs-number">1</span>, <span class="hljs-number">10</span> + <span class="hljs-built_in">len</span>(operators)))<br>            label[<span class="hljs-number">0</span>][<span class="hljs-number">10</span> + i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> images <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                images = image<br>                labels = label<br>            <span class="hljs-keyword">else</span>:<br>                images = np.r_[images, image]<br>                labels = np.r_[labels, label]<br>    <span class="hljs-keyword">return</span> images, labels<br><br>op_images, op_labels = get_images_labels()<br>op_images = op_images.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>,<span class="hljs-number">28</span>)<br><br><br><span class="hljs-comment"># 正在载入 plus 运算符...</span><br><span class="hljs-comment"># 100%|██████████| 5059/5059 [00:21&lt;00:00, 230.02it/s]</span><br><span class="hljs-comment"># 正在载入 sub 运算符...</span><br><span class="hljs-comment"># 100%|██████████| 6500/6500 [01:20&lt;00:00, 81.24it/s]</span><br><span class="hljs-comment"># 正在载入 mul 运算符...</span><br><span class="hljs-comment"># 100%|██████████| 5102/5102 [01:42&lt;00:00, 49.97it/s]</span><br><span class="hljs-comment"># 正在载入 div 运算符...</span><br><span class="hljs-comment"># 100%|██████████| 4234/4234 [01:51&lt;00:00, 37.97it/s]</span><br><span class="hljs-comment"># 正在载入 ( 运算符...</span><br><span class="hljs-comment"># 100%|██████████| 6500/6500 [03:39&lt;00:00, 29.56it/s]</span><br><span class="hljs-comment"># 正在载入 ) 运算符...</span><br><span class="hljs-comment"># 100%|██████████| 6500/6500 [04:40&lt;00:00, 23.19it/s]</span><br></code></pre></td></tr></table></figure><h2 id="分割多个手写字符"><a href="#分割多个手写字符" class="headerlink" title="分割多个手写字符"></a>分割多个手写字符</h2><p>我们写了一个算式，如下图所示：</p><p><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/out.png"></p><p>针对上面的图片，我们需要有效的识别出每一个符号。针对此场景的特殊性（只有黑白两种颜色）我们可以考虑使用无监督聚类算法进行类别划分。K-MEANS 是比较流行得到聚类算法，操作简单，运行快速，实现容易。但是这个算法并不适合我们这个场景，<strong>因为 K-MEANS 需要事先确定分几个类</strong>，这个是不太好实现的和判断。(不过也不是不可以)</p><p>为了解决这个问题我们可以使用 <strong>DBSCAN</strong> 算法，这是一种著名的基于密度聚类的算法。因为我们手写的字符，局部的笔画是密集的；而字符与字符之间是相对稀疏的，所以这种算法可以使用。</p><p><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/dbscan.gif"></p><p><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/DBSCAN.png"></p><p>分类效果还是不错的。然后我们需要将每一个识别出来的符号进行提取，并且处理为 28*28 尺寸的图片便于我们模型的输入。我们将每一个分割后的图片输入模型进行预测，我们将预测的符号类别、预测概率以及符号在原图中的位置进行标注，结果为：</p><p><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/current.png"></p><h2 id="CNN-可视化"><a href="#CNN-可视化" class="headerlink" title="CNN 可视化"></a>CNN 可视化</h2><p>深度学习模型虽然具有很好的预测效果，但其内部的预测原理通常难以解释，往往被看作为是**黑盒模型(Black box)**。我们使用遮盖法对模型的决策依据进行量化，基本思想：如果将输入特征的值改变会增加模型输出结果的误差，则该特征认为是重要的，因为模型依赖该特征为依据执行预测。反之，如果将特征的值改变模型输出结果的误差很小(或与原结果基本相同)，则该特征不重要，模型不依赖该特征。</p><p>我们选择符号 <strong>“9”</strong> 进行解释性计算，其结果如下图所示：</p><p><img src="/blog-image/MNIST%E8%AE%A1%E7%AE%97%E5%99%A8/CNN.png"></p><p>将每一个像素点的 <strong>预测贡献度(重要性)</strong> 在原图上进行可视化展示, 总共有 28*28 个贡献度数值。数值越大图中 <strong>橙色小圆点</strong> 的 size 就越大,颜色也越重。</p><h2 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h2><p>我们一般通过 <strong>后缀表达式(逆波兰式)</strong> 进行求值，因为对后缀表达式求值比直接对中缀表达式求值简单很多。<strong>中缀表达式</strong> 不仅依赖运算符的优先级，而且还要处理括号，而后缀表达式中已经考虑了运算符的优先级，且没有括号。主要分为两个步骤：</p><ol><li>把中缀表达式转换为后缀表达式</li><li>对后缀表达式求值</li></ol><h3 id="4-1-中缀转后缀"><a href="#4-1-中缀转后缀" class="headerlink" title="4.1 中缀转后缀"></a>4.1 中缀转后缀</h3><p>利用一个 <strong>栈</strong> (存放操作符) 和一个<strong>Output</strong>，从左到右读入中缀表达式：</p><ul><li>如果字符是操作数，将它添加到 Output。</li><li>如果字符是操作符，从栈中弹出操作符，到 Output 中，直到遇到左括号 或 优先级较低的操作符(并不弹出)。然后把这个操作符 push 入栈。</li><li>如果字符是左括号，无理由入栈。</li><li>如果字符是右括号，从栈中弹出操作符，到 Output 中，直到遇到左括号。(左括号只弹出，不放入输出字符串)</li><li>中缀表达式读完以后，如果栈不为空，从栈中弹出所有操作符并添加到 Output 中。</li></ul><h3 id="4-2-计算后缀表达式"><a href="#4-2-计算后缀表达式" class="headerlink" title="4.2 计算后缀表达式"></a>4.2 计算后缀表达式</h3><p>使用一个栈，从左到右读入后缀表达式：</p><ul><li>如果字符是操作数，把它压入堆栈。</li><li>如果字符是操作符，从栈中弹出两个操作数，执行相应的运算，然后把结果压入堆栈。(如果不能连续弹出两个操作数，说明表达式不正确)</li><li>当表达式扫描完以后，栈中存放的就是最后的计算结果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PolarDB FAST2020</title>
    <link href="/%E8%AE%A1%E7%AE%97%E5%AD%98%E5%82%A8/PolarDB%E7%BB%93%E5%90%88%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%AD%98%E5%82%A8%EF%BC%9A%E9%AB%98%E6%95%88%E6%94%AF%E6%8C%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/"/>
    <url>/%E8%AE%A1%E7%AE%97%E5%AD%98%E5%82%A8/PolarDB%E7%BB%93%E5%90%88%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%AD%98%E5%82%A8%EF%BC%9A%E9%AB%98%E6%95%88%E6%94%AF%E6%8C%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="PolarDB-Meets-Computational-Storage-FAST2020"><a href="#PolarDB-Meets-Computational-Storage-FAST2020" class="headerlink" title="PolarDB Meets Computational Storage. FAST2020"></a>PolarDB Meets Computational Storage. FAST2020</h1><blockquote><p>Efficiently Support Analytical Workloads in Cloud-Native Relational Database<br>高效支持云原生关系数据库的复杂查询操作</p></blockquote><span id="more"></span><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>关系数据库是现代信息技术基础设施的重要组成部分。因此，所有的云供应商都投入了巨大的努力来发展他们的关系数据库服务业务。不出所料，一些云供应商已经开发了自己的云原生关系数据库系统，例如亚马逊极光和阿里巴巴POLARDB。为了实现足够的可扩展性和故障恢复能力，云原生关系数据库自然遵循 <strong>计算与数据存储分离</strong> 的设计原则。同时，它们通常旨在与主流开源关系数据库(例如MySQL和PostgreSQL)兼容，并以比内部同类产品低得多的成本实现 <strong>OLTP</strong> 工作负载的高性能。</p><div class="note note-info">            <p>数据处理大致可以分成两大类：</p><ul><li>联机事务处理 <strong>OLTP</strong>（On-Line Transaction Processing）</li><li>联机分析处理 OLAP（On-Line Analytical Processing）</li></ul><p>OLTP 是专注于面向事务的任务的一类数据处理，通常涉及在数据库中插入，更新或删除少量数据，主要是处理大量用户下的大量事务。OLTP事务实例：在线银行、网上买一本书、预订一张机票、发送一个文本消息、电话推销员输入电话调查结果、呼叫中心员工查看和更新客户的详细信息。</p>          </div><p>云原生关系数据库非常需要充分支持<strong>分析工作负载(analytical workloads)<strong>。正如 Amazon aurora 的作者所指出的，由于云原生关系数据库将计算与数据存储分离，数据库节点和存储节点之间的网络带宽成为稀缺资源。然而，这与涉及密集数据访问的分析工作负载不太匹配。为了最好地服务于OLTP工作负载，云原生关系数据库通常采用行存储模型(或混合行/列模型)。这可能会使网络带宽成为分析工作负载的更大瓶颈。</strong>为了更好地服务于分析工作负载，几乎唯一可行的选择是将数据访问密集型任务(尤其是《表扫描》table scan)从数据库节点卸载(off-load)到存储节点</strong>。这个概念当然不是新的，已经被专有数据库设备(如Oracle Exadata)和开源数据库(如MySQL NDB集群)所采用。尽管概念很简单，但它在云原生数据库环境中的实际实现尤其重要。</p><ul><li>一方面，每个存储节点必须配备足够的数据处理能力来处理《表扫描》任务。</li><li>另一方面，为了保持云原生数据库的成本效益，我们不能大幅(甚至适度)增加存储节点的成本。</li></ul><p>通过用专用硬件(例如，GPU和FPGA)补充中央处理器，<strong>异构计算架构</strong> 似乎是解决这一数据处理能力与成本困境的一个有吸引力的选择。</p><h4 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h4><p>本工作将异构计算应用于POLARDB存储节点，有效支持 **《表扫描》下推(pushdown)<strong>。其关键思想很简单 : 每个POLARDB存储节点将《表扫描》任务从其CPU分配到其数据存储设备。在这个框架下，每个数据存储设备都看做</strong>计算存储驱动器(Computational Storage Drive,CSD)**，可以在I/O路径上执行《表扫描》。与将《表扫描》卸载到专用的独立计算设备(如FPGA/基于GPU的PCIe卡)相比，将《表扫描》分布在所有存储驱动器上，可以最大限度地减少存储/内存层次结构中的数据流量，避免数据处理热点。</p><h4 id="两个挑战"><a href="#两个挑战" class="headerlink" title="两个挑战"></a>两个挑战</h4><p>这个简单的概念并不新鲜，而且已经有论文讨论过了。然而，它实际上可行的实现和实际部署仍然完全缺失，至少在公开文献中是这样。这主要是由于难以解决两个挑战:</p><ul><li>(1) 如何在整个软件层次结构中实际支持《表扫描》下推，</li><li>(2) 如何实现具有足够《表扫描》处理能力的低成本计算存储驱动器。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在通过阿里云上的POLARDB实现这个简单想法的过程中，<strong>我们开发了一套软件/硬件技术来集中解决这两个挑战</strong>。为了减少产品开发周期，同时确保成本效益，计算存储驱动器使用以FPGA为中心的主机管理架构。在每个计算存储驱动器内，一个中档低成本Xilinx FPGA芯片处理闪存控制和《表扫描》。通过高度优化的软硬件设计，每个计算存储驱动器都可以支持对压缩数据进行高吞吐量(即超过2GB/s)的《表扫描》，同时实现与前沿NVMe SSD相当的存储I/O性能。我们开发了各种技术，使POLARDB存储节点能够充分利用计算存储驱动器的能力。本文介绍了这些设计技术并详细阐述了它们的实施，并给出了评价结果以证明其有效性。基于TPC-H查询，我们提取了6个单独的《表扫描》任务，并在一个存储节点上运行这些扫描任务。这样的节点级评估表明，计算存储驱动器可以在很大程度上降低扫描延迟和存储节点的CPU利用率。我们进一步在一个POLARDB云实例上对7个数据库节点和3个存储节点进行了系统级评估。结果表明，该解决方案可以显著降低TPC-H查询延迟。据我们所知，这是在公开文献中首次报道新兴计算存储在生产数据库中的应用。</p><div class="note note-info">            <p>云原生数据库 : 数据库的设计要充分利用云的基础设施。</p>          </div><h2 id="2-背景与动机"><a href="#2-背景与动机" class="headerlink" title="2 背景与动机"></a>2 背景与动机</h2><h3 id="2-1-POLARDB-基本架构"><a href="#2-1-POLARDB-基本架构" class="headerlink" title="2.1 POLARDB: 基本架构"></a>2.1 POLARDB: 基本架构</h3><p>POLARDB是阿里云设计的一个新的云原生OLTP数据库。它的设计目标来自于我们的云客户的真实需求：每个实例的</p><ul><li>大存储容量(几十TB)</li><li>高TPS(Transactions Per Second)</li><li>高可伸缩的QoS</li><li>高可用性</li></ul><p><img src="/blog-image/PolarDBFAST20/5.png"></p><ul><li><strong>一写多读</strong> : PolarDB采用分布式集群架构，一个集群版集群包含一个主节点和最多15个只读节点（至少一个，用于保障高可用）。主节点处理读写请求，只读节点仅处理读请求。主节点和只读节点之间采用Active-Active的Failover方式，提供数据库的高可用服务。</li><li><strong>计算与存储分离</strong> : PolarDB采用计算与存储分离的设计理念，满足公共云计算环境下根据业务发展弹性扩展集群的刚性需求。数据库的计算节点（Database Engine Server）仅存储元数据，而将数据文件、Redo Log等存储于远端的存储节点（Database Storage Server）。各计算节点之间仅需同步Redo Log相关的元数据信息，极大降低了主节点和只读节点间的复制延迟，而且在主节点故障时，只读节点可以快速切换为主节点。</li><li><strong>读写分离</strong> : 读写分离是PolarDB集群版默认提供的一个透明、高可用、自适应的负载均衡能力。通过集群地址，SQL请求自动转发到PolarDB集群版的各个节点，提供聚合、高吞吐的并发SQL处理能力。</li><li><strong>高速链路互联</strong> : 数据库的计算节点和存储节点之间采用高速网络互联，并通过RDMA协议进行数据传输，使I/O性能不再成为瓶颈。</li><li><strong>共享分布式存储</strong> : 多个计算节点共享一份数据，而不是每个计算节点都存储一份数据，极大降低了用户的存储成本。基于全新打造的分布式块存储（Distributed Storage）和文件系统（Distributed Filesystem），存储容量可以在线平滑扩展，不会受到单个数据库服务器的存储容量限制，可应对上百TB级别的数据规模。</li><li><strong>数据多副本、Parallel-Raft协议</strong> : 数据库存储节点的数据采用多副本形式，确保数据的可靠性，并通过Parallel-Raft协议保证数据的一致性。</li></ul><h3 id="2-2-POLARDB-《表扫描》下推"><a href="#2-2-POLARDB-《表扫描》下推" class="headerlink" title="2.2 POLARDB: 《表扫描》下推"></a>2.2 POLARDB: 《表扫描》下推</h3><p>将《表扫描》从数据库节点卸载到存储节点对于云原生关系数据库有效地处理分析工作负载非常重要。这个概念以存储节点上更重的数据处理负载换取显著减少数据库节点和存储节点之间的网络流量。此外，由于POLARDB采用行存储模型来更好地服务于OLTP工作负载，《表扫描》的面向列特性倾向于要求存储节点具有更高的数据处理能力。<strong>因此，设计的关键问题是如何经济有效地为存储节点配备足够的数据处理能力，以处理额外的《表扫描》任务。</strong></p><p>✖ 最直接的选择是简单地扩展每个存储节点，然而这实际上并不可取，主要是由于成本开销。对行存储数据的《表扫描》不适合于现代CPU架构，并且倾向于在很大程度上未充分利用CPU硬件资源(例如，缓存内存和SIMD处理资源)。因此，我们必须更积极地扩展存储节点，以弥补基于CPU实现的低效率。因此，这种直截了当的选择在经济上是没有吸引力的，甚至是不可接受的，特别是当经典的CMOS技术扩展正在迅速接近尾声的时候。</p><p>✔ 另一种选择是使用特殊用途的硬件(如FPGA或GPU)来补充存储节点CPU，以更好的成本效益进行《表扫描》。在这种异构计算框架下，传统实践使用集中式异构架构，其中特殊用途的硬件以单个单机FPGA/基于GPU的PCIe卡的形式实现。然而，对于我们的目标系统，这种方法有几个缺点:</p><ul><li>(1) 高数据流量 : 所有行存储格式的原始数据必须从存储设备获取到FPGA/ 基于GPU的PCIe卡。由于《表扫描》的数据密集型特性，这导致PCIe/DRAM通道上的数据流量非常大。高数据流量会导致大量的能耗开销和工作负载间的干扰。</li><li>(2) 数据处理热点 : 每个存储节点包含大量NVMe SSD，每个NVMe SSD可以实现多 GB/s 的数据读吞吐量。</li></ul><p>因此，《分析处理工作负载》可能触发非常高的聚合原始数据访问吞吐量，远远超过一个PCIe卡的I/O带宽。这可能会使FPGA/ 基于GPU的PCIe卡成为系统瓶颈。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>上面的讨论表明<strong>分布式异构架构是一个更好的选择</strong>。如下图所示，通过将《表扫描》直接分发到每个存储驱动器(物理介质)，我们可以消除PCIe/DRAM通道上的高数据流量，并消除系统中的数据处理热点。这种直觉直接促使我们在POLARDB存储节点中开发和部署计算存储驱动器。</p><p><img src="/blog-image/PolarDBFAST20/4.png"></p><h3 id="2-3-计算存储驱动器-·-CSD"><a href="#2-3-计算存储驱动器-·-CSD" class="headerlink" title="2.3 计算存储驱动器 · CSD"></a>2.3 计算存储驱动器 · CSD</h3><p><strong>简单地说，任何能够在其核心存储职责之外执行数据处理任务的数据存储设备都可以称为计算存储驱动器。</strong> 赋予存储设备额外计算能力的简单概念可以追溯到20多年前。计算存储与CPU互补，形成异构计算系统。与仅使用CPU的同类系统相比，异构计算系统可以为许多应用程序实现更高的性能和能源效率，这一点并不令人惊讶，正如先前的研究所证明的那样。然而，它显然受制于两个成本开销 :</p><ul><li>(1) 实现计算存储驱动器的硬件成本,</li><li>(2) 开发所有必要的硬件和软件解决方案以实现其实际部署的开发成本。</li></ul><p>尽管经过二十多年的研究，计算存储仍未进入主流市场，这可能是由于缺乏切实合理的效益与成本权衡。</p><h4 id="如何降低成本"><a href="#如何降低成本" class="headerlink" title="如何降低成本 ?"></a>如何降低成本 ?</h4><p>为了克服成本障碍，我们选择了<strong>基于FPGA的主机管理计算存储驱动器设计策略</strong>。这可以从两个方面降低开发成本 :</p><ul><li>(1) 我们使用单一的FPGA在计算存储驱动器内实现闪存控制和计算(即本工作中的《表扫描》)。与基于ASIC的方法相比，FPGA的电路级可编程性可以显著降低计算存储驱动器的开发周期和成本。</li><li>(2) 计算存储驱动器完全由主机管理，实现地址映射、请求调度、垃圾回收等功能。它的主机管理特性有助于将计算存储驱动器集成到现有的软件堆栈中。它为设计和优化计算存储驱动器的API提供了很高的灵活性，应用程序可以利用它的可配置计算能力。同时，主机管理的计算存储驱动器作为存储块设备集成到Linux I/O堆栈中，以服务于正常的I/O请求。</li></ul><p>然而，为了得到其电路级的可编程性，FPGA是昂贵的(例如，现代高端FPGA芯片可能会花费数千美元)，导致计算存储驱动器的硬件成本更高。同时，本工作的目标是部署计算存储驱动器，以成本有效地支持《表扫描》下推。因此，一个关键问题是<strong>如何在实现足够高的存储I/O和《表扫描》处理性能的同时最小化硬件成本开销</strong>，这将在下一节中讨论。</p><h2 id="3-设计与实现"><a href="#3-设计与实现" class="headerlink" title="3 设计与实现"></a>3 设计与实现</h2><p>如上所述，虽然应用计算存储来支持《表扫描》下推是一个非常简单的概念，并且在发表的文献中已经得到了很好的讨论，但是它的实际实现和部署仍然是缺失的。我们在POLARDB中实现这一概念的第一手经验表明，将这个简单的想法转化为实际产品面临以下两个主要挑战:</p><ol><li><strong>如何实际支持跨整个软件层次的《表扫描》下推</strong> : 由用户空间POLARDB存储引擎发起，该存储引擎通过指定文件中的偏移量来访问数据，而《表扫描》在物理上由计算存储驱动器提供，它作为原始块设备运行，并使用LBA(逻辑块地址)管理数据。整个存储I/O堆栈位于POLARDB存储引擎和计算存储驱动器之间。因此，我们必须内聚地增强/修改整个软件/驱动程序堆栈，以便创建一个支持《表扫描》叠加的路径。</li><li><strong>实现低成本的计算存储驱动器</strong> : 虽然基于FPGA的设计方法可以显著降低开发成本，但FPGA往往比较昂贵。此外,由于<br>FPGA通常仅工作在200 ~ 300MHz(与之相比，CPU时钟频率为2 ~ 4GHz)，为了实现足够高的性能，我们必须使用大量的电路级实现并行性(因此需要更多的硅资源)。因此，我们必须在我们的实现中开发出能够使用低成本FPGA芯片的解决方案。</li></ol><p>本节的其余部分将介绍一组跨软件和硬件堆栈的设计技术，这些技术可以解决上述两个主要挑战。</p><h3 id="3-1-支持跨整个软件层次的《表扫描》下推"><a href="#3-1-支持跨整个软件层次的《表扫描》下推" class="headerlink" title="3.1 支持跨整个软件层次的《表扫描》下推"></a>3.1 支持跨整个软件层次的《表扫描》下推</h3><p><strong>前端分析处理引擎 PolarDB MPP</strong> ：该分析处理引擎与 MySQL 协议兼容，可以解析、优化和重写使用 AST(抽象语法树)的 SQL 和许多嵌入式优化规则，它将每个 SQL 查询转换为一个 DAG(有向无环图)执行计划，由操作符和数据流拓扑组成。该引擎原生就支持 pushdown</p><p>如下图所示，为了启用《表扫描》下推，我们必须适当地增强分析处理引擎下的整个存储堆栈，包括POLARDB存储引擎、PolarFS (POLARDB下的分布式文件系统)和计算存储驱动程序。在下面的文章中，我们将详细介绍跨这三个层实现的增强功能。</p><p><img src="/blog-image/PolarDBFAST20/1.png"></p><h4 id="增强POLARDB存储引擎"><a href="#增强POLARDB存储引擎" class="headerlink" title="增强POLARDB存储引擎"></a>增强POLARDB存储引擎</h4><p>存储引擎 PolarDB Storage Engine：遵循了 LSM-tree 实现，数据被组织成了多个文件，每个文件包含很多块。</p><ul><li>原有的实现中，存储引擎可以使用存储节点上的 CPU 来处理 《表扫描》 请求，因此 《表扫描》 下推将与底层的 I\O 堆栈无关。</li><li>为了利用可计算型存储的特点，需要修改该引擎以便将 《表扫描》 请求下推到 PolarFS 上。存储引擎根据文件中的偏移量访问数据块。每一个 《表扫描》 请求包括：<ul><li>要被扫描的数据的定位信息（文件内的偏移量）；</li><li>应用《表扫描》的表的 schema；</li><li>《表扫描》 的condition。</li></ul></li><li>POLARDB 存储引擎分配一个内存缓冲区来存储从计算存储驱动器返回的数据，每个 《表扫描》 请求都包含这个内存缓冲区的位置</li></ul><div class="note note-info">            <p><strong>LSM-Tree</strong> 全称是 Log Structured Merge Tree，是一种分层，有序，面向磁盘的数据结构，其核心思想是充分了利用了“磁盘批量的顺序写要远比随机写性能高出很多”的特点。围绕这一原理进行设计和优化，以此让写性能达到最优，正如我们普通的Log的写入方式，这种结构的写入，全部都是以Append的模式追加，不存在删除和修改。当然有得就有舍，这种结构虽然大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于写多读少的场景。故LSM被设计来提供比传统的B+树或者ISAM更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。</p>          </div><h4 id="增强PolarFS"><a href="#增强PolarFS" class="headerlink" title="增强PolarFS"></a>增强PolarFS</h4><p>POLARDB部署在分布式文件系统PolarFS上，该文件系统管理跨所有存储节点的数据存储。每个计算存储驱动器只能对其自身的数据进行《表扫描》，同时以存储引擎数据块为单位进行数据扫描。同时，由于使用了块级压缩，长度可变的压缩块被连续地打包在每个文件中(即，每个压缩块不是4kb对齐)。因此，PolarFS在计算存储驱动器上使用粗粒度的数据分条(4MB分条大小)，以确保大多数数据块完全驻留在一个计算存储驱动器上。在一个压缩块位于两个驱动器之间的罕见情况下，系统将使用存储节点CPU处理相应的扫描操作。</p><p>POLARDB存储引擎以偏移量的形式在文件中指定待扫描数据的位置。要扫描的数据可能跨越多个文件，从而跨越多个计算存储驱动器。同时，计算存储驱动器只能以LBAs的形式定位数据。因此，在接收到来自POLARDB存储引擎的每个《表扫描》请求后，PolarFS必须适当地转换该请求，然后将其转发给计算存储驱动程序。因此，我们从以下几个方面对PolarFS进行了增强:</p><ul><li>(1) 假设要扫描的数据跨越了计算性驱动器，增强的PolarFS将该请求分解为扫描请求，每个请求扫描一个计算性存储驱动器上的数据。</li><li>(2) 对于每个扫描请求，将数据位置信息转换为LBAs中的偏移量。</li></ul><p>如图所示，增强的PolarFS随后将带有转换后的基于 LBA 的位置信息的themscan请求传递给底层的计算存储驱动程序。</p><h4 id="增强计算存储驱动程序"><a href="#增强计算存储驱动程序" class="headerlink" title="增强计算存储驱动程序"></a>增强计算存储驱动程序</h4><p>我们的计算存储驱动器完全由内核空间中的主机端驱动程序管理。该驱动程序将每个计算存储驱动器公开为一个块设备。在接收到PolarFS的每个《表扫描》请求后，驱动程序执行以下操作：</p><ul><li>它首先分析《扫描条件》，并在必要时重新安排扫描条件，以更好地简化基于硬件的扫描处理，从而提高吞吐量。</li><li>驱动程序进一步转换将被扫描数据的位置信息从LBA域到物理块地址(PBA)域，其中每个PBA与NAND闪存中的一个固定位置相关联。</li></ul><p>驱动程序在内部将每个扫描请求划分为许多(非常)小的扫描子任务，这可以达到两个目的:</p><ul><li>(1) 大的扫描任务可能会占用闪存带宽很长时间，这会导致其他正常的I/O请求延迟更长。通过将大的扫描任务划分为小的子任务，并用正常的I/O请求对它们进行内聚调度，可以缓解这个问题。</li><li>(2) 将大的扫描任务划分为小的子任务，有助于减少内部缓冲的硬件资源占用，提高闪存访问的并行性。</li></ul><p>此外，存储设备的后台操作，特别是**垃圾收集(Garbage Collection，GC)**，可能会严重干扰《表扫描》，从而造成严重的延迟损失。由于所有的flash管理功能都是由主机端驱动程序处理的，所以我们对驱动程序进行了增强，以便它能够内聚地调度GC和《表扫描》，以最小化GC引起的干扰。特别是，在分析处理工作负载繁重的情况下，驱动程序将自适应地减少甚至暂停GC操作。</p><h3 id="3-2-降低硬件实现成本"><a href="#3-2-降低硬件实现成本" class="headerlink" title="3.2 降低硬件实现成本"></a>3.2 降低硬件实现成本</h3><p>为了解决计算存储驱动实现成本的挑战，关键是实现FPGA硬件资源利用率的最大化。为了实现这个目标，我们在软件和硬件层中进一步开发了以下技术。</p><h4 id="硬件友好的数据块格式"><a href="#硬件友好的数据块格式" class="headerlink" title="硬件友好的数据块格式"></a>硬件友好的数据块格式</h4><p>我们首先修改了 POLARDB 存储引擎的数据块格式，以便于 FPGA 实现《表扫描》。《表扫描》主要涉及各种数据比较操作(如=、≥、≤)。尽管 FPGA 具有电路级的可编程性，但 FPGA 很难实现有效支持多种不同数据类型的比较器。在本工作中，我们修改了 POLARDB 存储引擎，使其以内存可比的格式存储所有的表数据，即可以使用函数 <strong>memcmp()</strong> 来比较数据。因此，计算存储驱动器只需要实现可以执行memcmp()函数的单一类型的比较器，而不考虑表中不同字段中的特定数据类型。通过在 FPGA 中实现类型无关的比较器，这可以在很大程度上减少实现《表扫描》时FPGA资源的使用。</p><p><img src="/blog-image/PolarDBFAST20/2.png"></p><p>为了提高硬件利用率，我们进一步修改了存储引擎的数据块结构。上图(a)展示了原始存储引擎中所使用的数据块格式 : 一个数据块包含了许多已排序的表项，以元信息(即1字节数据压缩类型和4字节CRC)结束。虽然这样的块格式可以很容易地由CPU处理，但它对计算存储驱动器中基于硬件的《表扫描》不友好。我们修改了图中(b)所示的数据块格式，其中我们添加了一个额外的块头，包括1字节的块压缩类型、4字节的键值对数量和4字节的重启键数量(注意，重启键用于在前缀压缩的情况下方便键搜索)。</p><p>这种修改后的块格式对基于硬件的《表扫描》更加友好，因为:</p><ul><li>(1) 计算存储驱动器可以解压每个块并检查CRC，而不需要POLARDB存储引擎传递每个块的大小信息。</li><li>(2) 通过在每个块的开始添加 “***# of keys*** ” 和 “***# of restart*** ”字段，硬件可以更方便地处理每个块内的重启和检测内块。</li></ul><p>这非常适合于硬件的顺序数据处理流程，从而简化了基于FPGA的硬件实现。</p><h4 id="FPGA实现"><a href="#FPGA实现" class="headerlink" title="FPGA实现"></a>FPGA实现</h4><p><img src="/blog-image/PolarDBFAST20/3.png"></p><p>上图显示了我们的FPGA实现的并行和流水线架构。为了降低成本，我们使用一个单一的中档 FPGA 芯片的闪存控制和《表扫描》。FPGA集成了一个强大的软判决LDPC(低密度奇偶校验)编码引擎。这使得低成本的3D TLC(以及未来的QLC) NAND闪存的使用成为可能，这有助于降低整体计算存储驱动器的成本。我们使用并行和流水线的硬件架构来提高《表扫描》处理的吞吐量。如图所示，它包含2个并行的数据解压引擎和4个数据扫描引擎。当前实现支持Snappy解压缩和以下扫描条件 : =，≠，&gt;，≥，&lt;，≤，NULL，和!NULL。</p><div class="note note-info">            <p><strong>LDPC码</strong> : 是麻省理工学院Robert Gallager于1963年在博士论文中提出的一种具有稀疏校验矩阵的分组纠错码。几乎适用于所有的信道，因此成为编码界近年来的研究热点。它的性能逼近香农极限，且描述和实现简单，易于进行理论分析和研究，译码简单且可实行并行操作，适合硬件实现。</p><p><strong>3D NAND</strong> : 是英特尔和镁光的合资企业所研发的一种新兴的闪存类型，通过把内存颗粒堆叠在一起来解决2D或者平面NAND闪存带来的限制。</p><p><strong>SLC</strong> ：全称 Single-Level Cell，每个Cell单元只存储1bit信息，也就是只有0、1两种电压变化，结构简单，电压控制也快速，反映出来的特点就是寿命长，性能强，P/E寿命在1万到10万次之间，但缺点就是容量低，成本高，毕竟一个Cell单元只能存储1bit信息。</p><p><strong>MLC</strong> ：全称是 Multi-Level Cell，它实际上是跟SLC对应的，SLC之外的NAND闪存都是MLC类型，而我们常说的MLC是指2bit MLC。<br>每个cell单元存储2bit信息，电压有000,01,10,11四种变化，所以它比SLC需要更复杂的的电压控制，加压过程用时也变长，意味着写入性能降低了，同时可靠性也下降了，P/E寿命根据不同制程在3000-5000次不等，有的还更低。</p><p><strong>TLC</strong> : 也就是 Trinary-Level Cell，准确来说是3bit MLC，每个cell单元存储3bit信息，电压从000到111有8种变化，容量比MLC再次增加1/3，成本更低，但是架构更复杂，P/E编程时间长，写入速度慢，P/E寿命也降至1000-3000次，部分情况会更低。</p><p><strong>QLC</strong> ：则是Quad-Level Cell，或者叫4bit MLC，电压从0000到1111有16种变化，容量增加了33%，但是写入性能、P/E寿命会再次减少。</p><p><img src="/blog-image/PolarDBFAST20/6.png"></p><p><strong>Snappy</strong> 是谷歌开源的一个用来压缩和解压的开发包。相较其他压缩算法速率有明显的优势，官方文档显示在64位i7处理器上，每秒可达200~500MB的压缩速度。</p>          </div><p>为了进一步提高硬件资源利用效率，我们采用了如下所述的简单设计技术。如上所述，所有字段都以内存可比形式存储，因此我们只需要实现类型无关的memcmp 模块来计算每个条件。由于不同的《表扫描》任务的扫描条件数量不同，每个扫描引擎都采用递归架构，以最大限度地提高FPGA的资源利用率。每个扫描引擎包含一个memcmp模块和一个oneRE(结果评估)模块。LetP=∑mi=1(∏nij=1ci,j)表示整体扫描任务，其中每个ci,jis在一个字段上有一个单独的条件。符号∑和∏分别表示逻辑或运算和与运算。使用单个memcmp和remodule，我们用一个条件递归计算谓词，每次jat。TheREmodule检查之前的memcmpoutput(即，到目前为止已经评估的所有theci,j)是否足以确定resultP的值。一旦p(即。，可以确定1或0)，扫描引擎可以立即完成对当前行的计算，并开始对另一行进行工作。这种递归体系结构可以在FPGA硬件资源利用率最佳的情况下处理任意谓词。</p><!-- ## 4 评价本节给出评估结果，以演示此已部署解决方案的有效性。本节的其余部分组织如下:4.1节总结了计算存储驱动器的实验环境和基本存储性能。章节4.2评估和比较了使用cpu或计算存储设备来实现《表扫描》时的《表扫描》性能。第4.3节给出了阿里巴巴云中一个POLARDB实例的TPC-H评估结果，第4.4节给出了进一步的结语。### 4.1 实验装置为了成为切实可行的产品，除了提供存储内计算能力外，计算存储驱动器必须具有一流的存储I/O性能(至少可以与领先的普通NVMe ssd相媲美)。我们的计算存储驱动器的存储性能总结如下。每个驱动器使用64层3D TLC NAND闪存芯片。通过PCIe Gen3×4接口，每个驱动器可支持2.2GB/s和3.0GB/s的顺序读写吞吐量。在100%的地址跨度和全触发GC下，每个驱动器可以实现160K和590K随机4KB读写IOPS，与最新的企业级NVMe ssd相媲美。每个计算存储驱动器承载一个中程Xilinx UltraScale+ KU15p FPGA芯片，该芯片处理闪存控制和计算。为了最大限度地提高纠错强度，每个驱动器支持软判决LDPC码解码，解码吞吐量超过3gb /s。性能评估在阿里巴巴云的一个POLARDB实例上进行(7个数据库节点，3个存储节点)。### 4.2 《表扫描》性能评估每个计算存储驱动器内的FPGA包含两个Snappy解压引擎和四个数据扫描引擎。解压缩吞吐量随数据压缩性的不同而不同。在压缩比为60%和30%时，两种解压引擎的总解压吞吐量分别为2.3GB/s和2.8GB/s。数据扫描引擎也有可变的吞吐量，这取决于几个运行时参数，例如，表中每一行的大小、表模式和扫描条件。我们使用TPC-H基准测试中定义的linineitemtable作为测试工具，评估移动《表扫描》对计算存储驱动器的有效性。lineitemtable总共包含16列，其中混合了标识符、整数、十进制、定长和变长字符串等数据类型。为了涵盖广泛的处理复杂性，我们选择了以下6个《表扫描》任务(从不同的TPC-H查询中提取)对一个存储节点进行评估: --><h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h3><p>存储内计算是一个非常简单的概念，并且已经在研究社区中得到了很好的讨论。然而，它在实际系统中的实现和部署仍然是难以捉摸的。与此同时，组件级别的显著增益不会转化为系统级别的显著好处，这并不罕见。因此，将存储内计算的简单想法商业化，远远不止实现能够进行某些计算的存储设备，还需要跨软件和硬件层次结构的集成创新。为了将存储内《表扫描》引入到云原生数据库系统，我们开发了跨越存储引擎、文件系统、驱动程序和硬件堆栈的整体解决方案。组件级实验评估结果表明，我们实现的计算存储驱动器可以实现高吞吐量的存储内《表扫描》，从而显著减少主机CPU使用和存储到内存的数据移动。系统级评估结果表明，我们的整体解决方案确实可以将组件级增益带入系统级。系统级评估还确认了实现从数据库节点到存储节点的《表扫描》下推的关键重要性。</p><h3 id="5-相关工作"><a href="#5-相关工作" class="headerlink" title="5 相关工作"></a>5 相关工作</h3><p>之前的工作已经深入研究了使用专用硬件(特别是 FPGA 和 GPU )加速数据库以补充 CPU 的前景。<strong>许多先前的工作集中在将分析处理中的《表扫描》卸载到专用的加速器(通常以 PCIe 卡的形式)上</strong>，这些加速器由 FPGA 或 GPU 构建。除了《表扫描》，之前的工作还研究了卸载更复杂的查询处理内核的潜力。然而，尽管有大量的前期工作和多年来令人印象深刻的性能优势，IBM-Netezza 似乎是主流市场上唯一已知的商业上成功的产品。它将数据压缩和《表扫描》卸载到IBM PureData Systems中基于 FPGA 的专用 PCIe 卡中。除了使用独立的加速器来补充 CPU 之外，Oracle 甚至将特殊目的的分析加速单元集成到自己的SPARC CPU中，然而，这显然是一个非常高的开发成本，并且已经被 Oracle 停止了。</p><p>新兴的计算存储为实现数据库的异构计算平台提供了新的机会。《Intelligent distributed storage》的作者研究了支持键值存储的计算存储驱动器的设计。之前的工作集中于利用计算存储驱动器实现存储内《表扫描》。虽然之前的工作与本工作的基本概念相同，但有几个明显的区别:</p><ul><li>(1) <strong>本工作提出了云原生关系数据库环境下的整体系统解决方案</strong>，并在实际生产环境中证明了其有效性。相比之下，之前的工作在一个计算存储驱动器中运行合成查询，而没有与数据库和系统I/O堆栈集成。之前的工作实现了一个基于在单个服务器上运行的修改过的MySQL的原型。它没有考虑与具有计算-存储解耦架构的数据库系统的集成，也没有考虑在一个服务器中使用多个计算存储驱动器。</li><li>(2) 前期工作中使用的计算存储驱动器的基本存储I/O性能指标(即顺序吞吐量和IOPS)远远低于前沿商品NVMe SSD。因此，在以前的工作中，系统倾向于更多的 I/O 约束，因此更容易从存储内《表扫描》中受益。与部署前沿商品NVMe SSD的系统相比，之前工作中显示的好处可能会大大减少。</li><li>(3) 之前的工作均使用 SSD 控制器内的嵌入式处理器进行数据处理，但无法匹配 SSD 内多 GB/s 的NAND闪存访问带宽，无法实现高吞吐量谓词评估。</li><li>(4)数据压缩被广泛应用于数据库中，以降低存储位的成本。因此，计算存储驱动器必须执行数据解压缩，以支持在数据读取路径上的谓词求值。然而，之前的工作并没有考虑到数据解压缩的实现。</li></ul><h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h3><p>本文报告了一个内聚的跨软件/硬件实现，使阿里巴巴的云原生关系数据库POLARDB能够有效地支持分析工作负载。基本的设计概念是将分析处理中昂贵的《表扫描》操作从CPU分派到计算存储驱动器。与当前异构计算的工业趋势保持一致，其关键思想非常简单，可以追溯到20多年前。然而，在现实世界中，通过合理的利益与成本的权衡来实际实现这个简单的想法是很重要的。<strong>本工作在阿里巴巴POLARDB的框架下，开发了一套横跨整个软硬件栈的设计解决方案，将这一简单的理念在生产云数据库环境中实际实现</strong>。在7个数据库节点和3个存储节点上的POLARDB云实例上的实验结果表明，在总共22个TPC-H查询中，我们的实现可以使12个TPC-H查询的延迟减少30%以上。同时，我们的实现可以减少超过50%的存储到内存的数据移动量12个TPC-H查询。我们希望这项工作将激发更多的研究和开发工作，以研究未来云基础设施如何利用新兴的计算存储驱动器。</p><!-- ### 云原生·关系数据库为了实现足够的可扩展性和故障恢复能力，云原生关系数据库自然遵循**计算与数据存储分离**的设计原则###  -->]]></content>
    
    
    <categories>
      
      <category>计算存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 实现 Merkle 树</title>
    <link href="/uncategorized/python%E5%AE%9E%E7%8E%B0merkle%E6%A0%91/"/>
    <url>/uncategorized/python%E5%AE%9E%E7%8E%B0merkle%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="MerkleTree"><a href="#MerkleTree" class="headerlink" title="MerkleTree"></a>MerkleTree</h1><p>python 实现 Merkle 树，可视化，快速查询，增删优化</p><span id="more"></span><p><strong>本文的全部代码已经放到了 <a href="https://github.com/YoujiaZhang/MerkleTree">GIthub</a> 仓库</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vala">from MerkleTree import *<br><br><span class="hljs-meta"># 构建一颗Merkle树</span><br>mt = MerkleTree()<br><span class="hljs-meta"># 构建数据 -&gt; nodeData</span><br>nodeData = []<br><span class="hljs-meta"># 构建一棵树，方法选择 imbalance</span><br>mt.build_merkle_tree(nodeData, way=<span class="hljs-string">&#x27;imbalance&#x27;</span>)<br><span class="hljs-meta"># 展示</span><br>mt.show()<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/init.svg"></p><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import <span class="hljs-built_in">random</span><br><br><span class="hljs-comment"># 随机构建一个数据</span><br><span class="hljs-built_in">num</span> = <span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>,<span class="hljs-number">99</span>)<br><span class="hljs-comment"># 添加到树中</span><br>mt.<span class="hljs-built_in">add</span>(str(<span class="hljs-built_in">num</span>))<br><span class="hljs-comment"># 展示</span><br>mt.show()<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/add.svg"></p><p>Merkle 树可以看作一棵搜索树，目前有很多树数据结构的平衡优化算法，但是问题是这些平衡算法都会破坏树节点的左右孩子关系，那么就不得不重新计算大量的 hash 值，多少有些麻烦，为了避免这种情况的发生，我们在插入数据的时候希望尽可能的维持原本的树高，插入结果如下图所示。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 多添加一些节点，构造 10 个节点</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">num</span> = <span class="hljs-built_in">random</span>.randint(<span class="hljs-number">1</span>,<span class="hljs-number">99</span>)<br>    mt.<span class="hljs-built_in">add</span>(str(<span class="hljs-built_in">num</span>))<br><br><span class="hljs-comment"># 展示</span><br>mt.show()<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/add2.svg"></p><p>我们看到了，一棵“枝繁叶茂”的树。我们可以在树中标记出新增的节点，最近一次新增加的节点使用红色进行标注，如下图所示：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">mt.<span class="hljs-built_in">compare</span>()<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/compare.svg"></p><p>图中显示最右边的两个节点为最后一次添加到树中的。我们还可以显示每一次添加节点的情况，同一批加入的节点标注为某一个颜色(纵向)。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mt.compare(<span class="hljs-attribute">showHistory</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/compare2.svg"></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><a href="/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>（Bloom Filter）可以快速验证一个集合中是否不存在某一个元素，但是无法完全验证一个元素是否一定存在。而且集合中的数据越多，误报的概率也越大。同时，传统的 Merkle 树可以通过 Merkle 证明路径验证某个元素是否存在，但是却又无法验证某个元素是否不存在。我们希望找到一种方法可以快速确定某个元素是否（不）存在于集合之中。我们从密码学中的 RSA 算法获得启发，结合 <a href="https://leetcode-cn.com/problems/group-anagrams/"><strong>Leetcode 49. 字母异位词分组</strong></a> 的实际应用，我们设计如下方案：</p><ul><li>为每一个 “叶子” 随机生成一个素数 $p$</li><li>自下而上的，父节点的 “数” 为子节点 “数” 的乘积</li></ul><p>那么根节点的“数”就是整棵树所有素数的积，如果我们查询一个数据 $t$ 是否存在于 Merkle 树，只需用根节点的“数”除以目标 $t$ 对应的素数 $p$，如果可以整除就说明 $t$ <strong>存在</strong>于树上，否则就说明 $t$ <strong>不存在</strong>于树上。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 获取整棵树所有数据自己的素数id</span><br>mt.getTreePrime()<br><br><span class="hljs-meta"># [<span class="hljs-string">&#x27;227&#x27;</span>, <span class="hljs-string">&#x27;331&#x27;</span>, <span class="hljs-string">&#x27;797&#x27;</span>, <span class="hljs-string">&#x27;941&#x27;</span>, <span class="hljs-string">&#x27;877&#x27;</span>, <span class="hljs-string">&#x27;191&#x27;</span>, <span class="hljs-string">&#x27;173&#x27;</span>, <span class="hljs-string">&#x27;577&#x27;</span>, <span class="hljs-string">&#x27;563&#x27;</span>, <span class="hljs-string">&#x27;409&#x27;</span>, <span class="hljs-string">&#x27;353&#x27;</span>]</span><br><br><span class="hljs-meta"># 根据知道的素数id 就可以</span><br>mynode, proofPath = mt.search(mt.getTreePrime()[<span class="hljs-number">5</span>])<br><br><span class="hljs-meta"># 展示</span><br>mt.show(mynode)<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/search.svg"></p><p><em><strong>proofPath</strong></em> 变量中存放着证明这个节点真实存在的 <strong>Merkle 路径</strong>。</p><h2 id="Merkle-路径验证"><a href="#Merkle-路径验证" class="headerlink" title="Merkle 路径验证"></a>Merkle 路径验证</h2><p>任何一个人都可以验证 <strong>Merkle 路径</strong> 是否正确，即证明某个区块上是否存在一笔交易。我们对得到的 Merkle 路径进行验证。通过将得到的 <em><strong>proofPath</strong></em> 变量输入 <code>merkle_path</code> 函数中能够可视化展示此路径是否正确。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 验证一下路径是否满足条件<br>mt.merkle<span class="hljs-constructor">_path(<span class="hljs-params">proofPath</span>)</span><br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/merklePath.svg"></p><p>我们可以看到这个路径是正确的，每一个节点对应的 hash 值都没有被篡改。所以，在自下而上进行 hash 运算的时候不会出现不一致的问题，验证通过。图中颜色解释：</p><ul><li><strong>橙色</strong>：表示需要提供给 “请求者” 的作证 hash 值。</li><li><strong>蓝色</strong>：“请求者” 想要证明存在的节点。</li><li><strong>绿色</strong>：hash 值验证成功的节点。</li></ul><p>当我们将橙色的节点们发送给 “请求者” 的时候，可能会遇到 <strong>数据被篡改</strong> 的情况。这时候，我们可以再次验证，观察能否检测出篡改行为。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 篡改第 3 号节点的 hash 数据</span><br><span class="hljs-attribute">proofPath_2</span> = mt.tampering_test(proofPath,<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 验证一下</span><br><span class="hljs-attribute">mt</span>.merkle_path(proofPath_<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/merklePath2.svg"></p><p>我们发现确实是检测出了不一致现象，当我们修改 <strong>节点2</strong> 的 hash 值后，从节点 2 开始就无法计算出正确的 hash 值，所以最终会导致根节点 hash 值不一致。图中颜色解释：</p><ul><li><strong>灰色</strong>：表示被篡改 hash 值的节点。</li><li><strong>红色</strong>：验证 hash 值不一致。</li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当树中的数据不再需要的时候，留着它会占用位置，但是如果删除掉其中某个数据，再重新建树，需要计算大量的hash值。为了避免这个问题，我们这棵树可以删除需要删除的节点，同时又<strong>保证整棵树的高度尽可能的小</strong>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 删除这棵树的一个节点</span><br>mt.<span class="hljs-builtin-name">remove</span>(mt.getTreePrime()[4])<br>mt.show()<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/delete.svg"></p><p>删除操作之后的，我们看到了第 4 个节点已经被删除了，我们还可以继续进行删除或者添加节点。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"># 连续五次删除第<span class="hljs-number">3</span>个节点<br>for <span class="hljs-selector-tag">i</span> in range(<span class="hljs-number">5</span>):<br>    mt.<span class="hljs-built_in">remove</span>(mt.<span class="hljs-built_in">getTreePrime</span>()[<span class="hljs-number">2</span>])<br>mt.<span class="hljs-built_in">show</span>()<br></code></pre></td></tr></table></figure><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/delete2.svg"></p><p>删除大量节点之后，这棵树仍会维持满足条件的最小高度。最小的高度可以保证增加、查询和删除操作的最小代价。<br>我们可以继续检查一下整棵树的 hash 值是否维持正确。</p><p><img src="/blog-image/python%E5%AE%9E%E7%8E%B0MT/delete3.svg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode208-实现 Trie（前缀树）</title>
    <link href="/leetcode/leetcode208/"/>
    <url>/leetcode/leetcode208/</url>
    
    <content type="html"><![CDATA[<h1 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h1><p>Trie，又称<strong>前缀树</strong>或<strong>字典树</strong>，是用于快速处理字符串的问题，能做到快速查找到一些字符串上的信息。另外，Trie 树在实现高效的同时，会损耗更多的空间，所以 Trie 是一种以空间换时间的算法。Trie 这个术语来自于 retrieval。根据词源学，Trie 的发明者 Edward Fredkin 把它读作 /ˈtriː/ “tree”。但是，其他作者把它读作 /ˈtraɪ/ “try”。Trie 可以看作是一个 <strong>确定有限状态自动机（DFA）</strong>，尽管边上的符号一般是隐含在分支的顺序中的。</p><span id="more"></span><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p><img src="/blog-image/Trie%E6%A0%91/Trie%E6%A0%B7%E5%AD%90.jpg"></p><p>如上图所示，我们构建了一个 Trie 树。插入的单词为：“to、tea、ted、ten、in、inn、and”。</p><ul><li><strong>查询</strong>：如果我们要查询 “and” 是否存在时，我们可以由根节点一路向下搜寻，找到 “a”、“n”、“d”。但是，当我们想要查询 “an” 是否存在时，同样的情况我们会落在一个未插入单词的节点上，这表示这棵树中没有包含 “an” 这个单词。</li><li><strong>插入</strong>：如果我们想要插入 “inside” 这个单词，我们就可以沿着 Trie 树寻找 “inside” 中的最大前缀。搜寻结果为 “in”，那么我们就给 “n” 节点的依次插入 “s、i、d、e”，同时在最后的 “e” 节点处标记为绿色。</li></ul><div class="note note-info">            <p>Trie 查询和插入的时间复杂度都为 $\textrm{O}(len(str))$</p>          </div><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h3><ul><li>可以在 Trie 中存储很多单词作为 “字典”。可以查找其他的未知字符串是否出现过以及出现频率。 </li><li>给定的 1000 万字符串中包含了好很多重复的，构建 Tire 树可以去重。</li></ul><h3 id="寻找热门查询"><a href="#寻找热门查询" class="headerlink" title="寻找热门查询"></a>寻找热门查询</h3><p>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节。假设目前有 1000 万个记录，这些查询串的重复度比较高，虽然总数是 1000 万，但是如果去除重复，不超过 300 万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>通过先序遍历整个 Trie 树，可以得到所有字符串的字典序。</p><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>Trie 树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵 Trie 树上时，我们可以快速得到某些字符串的公共前缀。</p><p>例子 ：给出 N 个小写英文字母串，以及 Q 个询问，即询问某两个串的最长公共前缀的长度是多少？<br>解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。</p><h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><h3 id="辅助数据结构"><a href="#辅助数据结构" class="headerlink" title="辅助数据结构"></a>辅助数据结构</h3><p>如后缀树，AC自动机等，后缀树可以用于全文搜索。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.children = [<span class="hljs-literal">None</span>] * <span class="hljs-number">26</span><br>        self.isEnd = <span class="hljs-literal">False</span>  <span class="hljs-comment">#是否插入单词</span><br>    <br>    <span class="hljs-comment"># 寻找前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchPrefix</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; &quot;Trie&quot;:</span><br>        node = self <span class="hljs-comment"># 节点为自己本身</span><br>        <br>        <span class="hljs-comment"># 遍历前缀字符串</span><br>        <span class="hljs-comment">#   如果字符串中的第 i 个字符存在在当前node的子节点数组中，children[i] yes!</span><br>        <span class="hljs-comment">#       那就向下走到 children[i]</span><br>        <span class="hljs-comment">#   否则返回 None 表示 Trie 树中没有这个路径</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-comment"># 遍历结束</span><br>        <span class="hljs-comment"># 当前的节点就是保存了前缀字符串最后一个字符的node。</span><br><br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> prefix:<br>            ch = <span class="hljs-built_in">ord</span>(ch) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.children[ch]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            node = node.children[ch]<br>        <span class="hljs-keyword">return</span> node<br><br>    <span class="hljs-comment"># 插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        node = self <br><br>        <span class="hljs-comment"># 遍历待插入字符串</span><br>        <span class="hljs-comment">#   如果字符串中的第 i 个字符不存在在当前node的子节点数组中，children[i] no!</span><br>        <span class="hljs-comment">#       那就为 children[i] 构造新的 Trie 节点 </span><br>        <span class="hljs-comment">#   向下走到 children[i]</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-comment"># 遍历结束</span><br>        <span class="hljs-comment"># 当前的节点就是保存了前缀字符串最后一个字符的node</span><br>        <span class="hljs-comment"># 修改 isEnd 标记为 True</span><br><br>        <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> word:<br>            ch = <span class="hljs-built_in">ord</span>(ch) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.children[ch]:<br>                node.children[ch] = Trie()<br>            node = node.children[ch]<br>        node.isEnd = <span class="hljs-literal">True</span><br><br>    <span class="hljs-comment"># 查找单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        node = self.searchPrefix(word)<br>        <span class="hljs-comment"># 只有当最后一个字符的节点存在，并且 isEnd 标记为真，查询成功</span><br>        <span class="hljs-keyword">return</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> node.isEnd<br><br>    <span class="hljs-comment"># 查找前缀</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startsWith</span>(<span class="hljs-params">self, prefix: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-comment"># 只有当最后一个字符的节点存在，查询成功</span><br>        <span class="hljs-keyword">return</span> self.searchPrefix(prefix) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 分支合并</title>
    <link href="/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6/"/>
    <url>/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-分支合并"><a href="#Git-分支合并" class="headerlink" title="Git 分支合并"></a>Git 分支合并</h1><p>从一个提交对象上衍生出不同的分支是一件好事情。因为这样可以让团队中更多的人同时参与到项目的开发之中，大大提高了开发效率。关键就在于，如何合体呢？如何将每一个人的工作友好的组合在一起而不产生混乱呢？这就是合并需要考虑的事情了。</p><span id="more"></span><h2 id="如何合并两个文件"><a href="#如何合并两个文件" class="headerlink" title="如何合并两个文件"></a>如何合并两个文件</h2><p>比如老师给了一个代码文件，布置作业：需要让同学们进行改进。同一个小组的 $Alice$ 和 $Bob$ 都拿到了这个原始代码并进行了修改工作。那么他们在给老师提交作业的时候，如何合并两个人的工作呢？</p><h3 id="能直接合并吗？"><a href="#能直接合并吗？" class="headerlink" title="能直接合并吗？"></a>能直接合并吗？</h3><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%BA%8C%E8%80%85%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94.jpg"></p><p>很明显这个是不能直接合并的。就上图展示的情况而言，Git 是无法得知第 15 行代码究竟是谁修改的，或许根本就没有人修改过这行代码，再获取这行代码都被他们修改过。</p><h3 id="三向合并"><a href="#三向合并" class="headerlink" title="三向合并"></a>三向合并</h3><p>所以我们就需要一个参考，即<strong>三向合并</strong>。$Ailce$ 和 $Bob$ 肯定有一个共同的参考版本 <strong>Base</strong>，然后他们分别基于这个 Base 做进一步的修改。那么只要结合这个 Base 的内容，Git 就可以很清楚的知道到底是谁修改这个这行代码，从而合并。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%B8%89%E8%80%85%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94.jpg"></p><p>从上图中我们可以看到，原来是 $Ailce$ 修改这个代码，Git 就会保留 $Ailce$ 的内容 <code>Num = 10;</code>。</p><p>当然也有可能出现这种情况就是三方对应位置上的代码都不一样，这就产生了<strong>冲突</strong>，这种只能人为的进行取舍了。</p><h2 id="Git-合并策略"><a href="#Git-合并策略" class="headerlink" title="Git 合并策略"></a>Git 合并策略</h2><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-3.jpg"></p><p>了解完怎么合并两个文件之后，我们来看一个使用 <code>git merge</code> 来做分支合并。如上图所示，将 master 分支合并到 feature 分支上，会新增一个 commit 节点来记录这次合并。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 第一种方式</span><br>git checkout feature<br>git merge <span class="hljs-keyword">master</span><br><br><span class="hljs-title"># 第二种方式</span><br><span class="hljs-title">git</span> merge <span class="hljs-keyword">master</span> <span class="hljs-title">feature</span><br></code></pre></td></tr></table></figure><p>Git 会有很多合并策略，其中常见的是 Fast-forward、Recursive 、Ours、Theirs、Octopus。下面分别介绍不同合并策略的原理以及应用场景。默认 Git 会帮你自动挑选合适的合并策略，如果你需要强制指定，使用 <code>git merge -s &lt;策略名字&gt;</code>。</p><h3 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast-forward"></a>Fast-forward</h3><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-2.jpg"></p><p>Fast-forward 是最简单的一种合并策略，如上图中将 some feature 分支合并进 master 分支，Git 只需要将 master 分支的指向移动到最后一个 commit 节点上</p><p>Fast-forward 是 Git 在合并两个没有分叉的分支时的默认行为，如果不想要这种表现，想明确记录下每次的合并，可以使用 <code>git merge --no-ff</code>。</p><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><p>Recursive 是 Git 分支合并策略中最重要也是最常用的策略，是 Git 在合并两个有分叉的分支时的默认行为。其算法可以简单描述为：递归寻找路径最短的唯一共同祖先节点，然后以其为 Base 节点进行递归三向合并。说起来有点绕，下面通过例子来解释。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-4.jpg"></p><p>如上图所示，我们想要合并 master 分支和 Feature 分支。这个时候需要找到他们的共同祖先节点（黄色），接着进行三向合并得到新的提交对象。然而，实际中的提交情况看是“错综复杂”的，提交节点之间相互可能会交叉那么就出现下面展示的这种情况。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-5.jpg"></p><p>面对这种情况下，Git 就开始寻找两个分支的共同祖先节点。如果这个时候 Git 会说话肯定就要吐槽了，Git：“俩祖先 ？？？，这家子有够乱的”。中国有句话说得好，五百年前是一家，如果当前找到的若干平级的祖先，那么在往上一直寻找祖先的祖先，直到二者出现一个共同的祖先。具体操作就是：</p><ul><li>Step 1. 首先一直溯源找到公共的那个节点</li><li>Step 2. 以这个公共节点为 Base，对下一级的平级祖先节点进行合并</li><li>Step 3. 合并的建立临时快照，形成了一个“虚拟祖先”</li><li>Step 4. 然后以“虚拟祖先”为新的公共节点，跳转到 Step 2</li></ul><p>通过上面这个操作就可以“递归”地把两个分支各自往上的所有节点都进行了合并形成一个“虚拟祖先”，基于此就可以进行平常情况下的合并操作了。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-6.jpg"></p><div class="note note-info">            <p>值得一提的是，出现多个满足条件的共同祖先的现象被称为 <strong>Criss-Cross 现象</strong>。虽然它并不一定经常发生，但是对于那些存在时间很长，拓扑结构很复杂的分支，还是很有可能会出现的。</p>          </div><h3 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h3><p>和 Recursive 策略类似，Resolve 策略是另一种解决两个分支间合并问题的策略，同样也是采用的“三向合并”算法。关于它的介绍，网络上资料不多。只知道它是在 Recursive 策略出现之前，Git 合并时所采用的默认策略。和 Recursive策略不同的是，<strong>它在处理 Criss-Cross 情况时，会在多个满足条件的共同祖先里选取其中一个作为合并的 Base</strong>）。在某些情况下，如果使用 Recursive 策略作为默认策略进行合并时遇到了问题，也可以尝试选择 Resolve 策略。</p><h3 id="Ours-amp-Theirs"><a href="#Ours-amp-Theirs" class="headerlink" title="Ours &amp; Theirs"></a>Ours &amp; Theirs</h3><p>Ours 和 Theirs 这两种合并策略也是比较简单的，简单来说就是保留双方的历史记录，但完全忽略掉这一方的文件变更。这其实也是一种处理 <strong>冲突</strong> 的方法。我们可以告诉 Git 谁的应该被保留而谁的应该被丢弃。</p><ul><li>ours 保留当前分支的内容</li><li>Theirs 保留不是当前分支的内容</li></ul><p>此外，当你同时尝试了两个方案，分别在分支是 dev1 和 dev2 上，最后经过测试你选用了 dev2 这个方案。但你不想丢弃 dev1 的这样一个尝试，希望把它合入主干方便后期查看，这个时候你就可以在 dev2 分支中执行 <code>git merge -s ours dev1</code>。（保留我们的（ours）丢弃 dev1）</p><h4 id="Recursive-中的参数"><a href="#Recursive-中的参数" class="headerlink" title="Recursive 中的参数"></a>Recursive 中的参数</h4><p>Recursive 策略中有一个可以指定的参数就是 <code>-Xours</code> 和 <code>-Xtheirs</code>。正如前面所说，这其实是在面对 <strong>冲突</strong> 时的一种针对策略，总不能尬在原地啥也不做吧。如果合并很顺利没有发现冲突，那就成功完成合并；如果有冲突了，就会根据指定的参数就行相应的处理：要么舍弃自己，要么舍弃别人。</p><h4 id="危险的-Theirs"><a href="#危险的-Theirs" class="headerlink" title="危险的 Theirs"></a>危险的 Theirs</h4><p>Git 在以前的版本里是有 Theirs 策略的，但后来它被去掉了。其实道理也很简单，因为它太危险了。正如 Ours 策略会毫不犹豫地丢弃被合并分支上的修改，Theirs 策略也会毫不犹豫的丢弃当前分支上的修改。这相当于自己在当前分支上所做的工作全部丢掉了！</p><h3 id="Octopus"><a href="#Octopus" class="headerlink" title="Octopus"></a>Octopus</h3><p>当我们希望一次性合并超过两个分支的时候，使用两两合并的策略其实也不是不可以，就是有点繁杂，需要产生大量的提交节点，别人一看：“哦吼，这么多提交一定是做了很多新的吧”，结果仔细一看发现备注上都是“Merge”，直接笑死。Octopus（章鱼）就是专门解决这个问题的。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-7.jpg"></p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>git rebase 也是一种经常被用来做合并的方法，其与 git merge 的最大区别是，他会更改变更历史对应的 commit 节点。rebase 本质上就是丢弃已有的提交记录，创建新的提交记录，从内容上看是完全一样的，但提交历史却改变了。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5-8.jpg"></p><p>对提交历史的修改是需要谨慎的。如果我们已经把提交推送到远程，而其他人又从远程下载了我们的提交，并在这个基础上工作。这个时候，如果我们又利用 rebase 修改了提交记录，并再次推送到远程，那么其他人就不得不重新合并他们之前的工作了。</p><h4 id="如何看待-rebase-篡改提交历史？"><a href="#如何看待-rebase-篡改提交历史？" class="headerlink" title="如何看待 rebase 篡改提交历史？"></a>如何看待 rebase 篡改提交历史？</h4><p>关于Git的提交历史，有两种观点。</p><ol><li>一种观点认为，它如实的记录了人们的实际操作，所以不应该被“篡改”</li><li>另一种观点认为，多人协作开发的时候，提交历史的作用是把项目如何演化的过程展示给其他人看，所以没必要把全部细节都暴露出来。比如，像一些很细微的修改记录，类似整个提交历史中的某些中间状态，这些提交记录是可以去掉的。</li></ol><p>支持后一种观点就是人们通常使用 rebase 修改提交历史的原因或依据。</p><h4 id="如何正确使用？"><a href="#如何正确使用？" class="headerlink" title="如何正确使用？"></a>如何正确使用？</h4><p>关于什么时候可以使用 rebase 的问题，一般的建议是：</p><p>如果你还没有把提交推送到远程 Git 库，rebase 是没问题的。因为，所有改动，包括对提交历史的改动都只发生在本地，不会对别人造成影响。而且，那样做还有助于在把提交推送到远程之前，让提交历史变得更加清晰。这个在开源项目的开发里是很常见的。比如：</p><p>假设你以 Contributor 的身份在为某个开源项目贡献代码。一般我们会从原项目那里 fork 一份出来形成自己的 Git 库，然后在自己的 Git 库上新开一个分支，在分支上进行开发。要提交修改的时候，先把修改 rebase 到远程的 origin/master上（自己的 Git 库），然后再以 Pull Request 的方式提交到原项目，让这个项目的 Maintainer 来 Review。如果我们使用了 rebase，那么 Maintainer 在合并修改的时候就会很轻松，他不需要做任何复杂的集成，只要简单地做一个 Fast-Forward Merge 就可以了。</p><p>但是，如果你的改动已经被推送到了远程 Git 库，并且其他人已经开始在这个基础上继续他们的工作时，那就最好不要轻易做 rebase 了。</p>]]></content>
    
    
    <categories>
      
      <category>版本管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习总结</title>
    <link href="/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git 是一个分布式版本控制软件，最初由 $Linus$ $Benedict$ $Torvalds$ 创作，于 2005 年以 GPL 发布。最初目的是为更好地管理 Linux 内核开发而设计。应注意的是，这与 GNU Interactive Tools（一个类似 Norton Commander 界面的文件管理器）不同。</p><p>Git 最初的开发动力来自于 BitKeeper 和 Monotone。Git 最初只是作为一个可以被其他前端（比如 Cogito 或 Stgit）包装的后端而开发的，但后来 Git 内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用 Git 进行版本控制，其中包括Linux 内核、X.Org 服务器和 OLPC 内核等项目的开发流程。</p><span id="more"></span><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。<strong>有利于管理多人协同开发项目</strong>。</p><h3 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h3><p><strong>Git</strong><br><strong>SVN</strong>（Subversion）<br><strong>CVS</strong>（Concurrent Version System）<br><strong>VSS</strong>（Micorosoft Visual SourceSafe）<br><strong>TFS</strong>（Team Foundation Server）<br>Visual Studio Online<br>目前使用最广泛的就是 Git 和 SVN</p><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>比如我们要写毕业论文了，为了跟踪我们论文的完成进度，我们就会写出很多不同的版本：论文1.0、论文2.0、论文最终版等等。如果出现什么问题或者后悔了，就可以“回滚”到以前的历史版本。</p><p>目前有很多的本地版本控制系统，大多都是采用某种简单的数据库来记录文件的更新差异。</p><p>其中最流行的一种叫做 <strong>RCS</strong>，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 <code>rcs</code> 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化—）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p>一个人维护好自己写的项目只要做事条理清晰，基本上都是可以将项目迭代管理的很好的。但是要是多人协作怎么办呢？<strong>需要形成一个共识</strong>。</p><p>于是就有了专门针对这种问题诞生的工具：集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）该系统可以让协同工作的人们都通过客户端连到这台服务器上，获取最新的文件 or 提交更新。</p><ul><li>优点：可以轻松地集中管理各方协同</li><li>缺点：如果服务器坏了或者故障了，会影响整个项目的开发进度，严重一点的甚至会失去整个项目的数据文件，需要不定期备份服务器。</li></ul><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>为了集中式管理的问题，人们设计出了分布式的版本控制系统（Distributed Version Control System，简称 DVCS）。客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。藉此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p><h3 id="Git-与-SVN-对比"><a href="#Git-与-SVN-对比" class="headerlink" title="Git 与 SVN 对比"></a>Git 与 SVN 对比</h3><p>SVN 是集中式版本控制系统，版本数据存放在中央服务器中，工作时需要先从中央服务器获取最新的版本，然后工作更新之后将自己更新的版本再一次的发送到服务器中，完成同步。</p><p>Git 是<strong>目前全世界最（没有之一）先进的分布式版本控制系统</strong>，每一个协作者手上都有完整的版本数据库，更有利于各方协同并行开发。</p><h2 id="Git-发展历史"><a href="#Git-发展历史" class="headerlink" title="Git 发展历史"></a>Git 发展历史</h2><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p><strong>Linux 内核开源项目</strong> 有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间，数十年如一日）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper（赞助） 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，<strong>两周左右的时间</strong> 开发出自己的版本系统。他们对新的系统制订了若干目标：</p><ul><li>速度很快</li><li>设计简单</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全分布式</li><li>有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</li></ul><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。</p><h2 id="Git基础理论"><a href="#Git基础理论" class="headerlink" title="Git基础理论"></a>Git基础理论</h2><h3 id="四个工作区"><a href="#四个工作区" class="headerlink" title="四个工作区"></a>四个工作区</h3><p>Git 本地有三个工作区</p><ul><li>工作目录 Working Directory</li><li>暂存区 Stage/Index</li><li>资源库 Repository</li></ul><p>此外，结合 Git 远程仓库一共是四个，他们之间的关系如下图所示。<br><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%9B%E4%B8%AA%E5%8C%BA.jpg"></p><ul><li><p><strong>工作区（working）</strong> ：当你 <code>git clone</code> 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p></li><li><p><strong>暂存区（staging）</strong> ： 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作 Index，不过一般说法还是叫暂存区。</p></li><li><p><strong>本地仓库（local）</strong> ：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库。</p></li><li><p><strong>远程仓库（remote）</strong> ：以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。</p></li></ul><h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 工作目录下的每一个文件都将处于下面的某一个状态中：</p><ul><li>Untracked</li><li>Tracked<ul><li>Unmodify（未修改）</li><li>Modified（已修改）</li><li>Staged（已暂存）</li></ul></li></ul><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%B8%89%E4%B8%AA%E7%8A%B6%E6%80%81.jpg"></p><ul><li><strong>Untracked 未跟踪</strong>，此时文件还在工作区中，没有加入 git 仓库不参与版本控制，通过 <code>git add</code> 将状态修改为 Staged。</li><li><strong>Unmodify 未修改</strong>，文件已入库同步了，即库中的文件快照与本地工作区的文件内容完全一致。这时我们可以继续编辑文件，那么它的状态会变为 Modified；当然我们也可以使用 <code>git rm</code> 将其移除版本库变成 Untracked。</li><li><strong>Modified 已修改</strong>，已经修改过得文件可以进一步添加到暂存区状态变为 Staged；此外，也可以使用 <code>git checkout</code> 放弃修改状态返回到 Unmodify。</li><li><strong>Staged 已暂存</strong>，执行 <code>git commit</code> 将修改的文件同步到库中，这时仓库的文件和本地文件保持一致，状态变为Unmodify。执行 <code>git reset HEAD filename</code> 取消暂存状态变为 Modified。</li></ul><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>了解了 Git 的四个区和三种状态之后我们看看在本地，Git 具体是怎么让文件在文件夹中反复横跳的。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/git%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.jpg"></p><ul><li><strong>Directory</strong>：使用 Git 管理的一个文件夹，也是一个仓库。</li><li><strong>WorkSpace</strong>：需要通过 Git 进行版本控制的文件夹和文件。</li><li><strong>.git</strong>：存放 Git 管理信息的目录，初始化仓库的时候自动创建。<ul><li><strong>HEAD</strong>：是一个指针，指向正在工作的本地分支，也就是分支的一个别名。</li><li><strong>config</strong>：项目的配置信息，<code>git config</code> 命令会改动它。</li><li><strong>description</strong>：项目的描述信息。</li><li><strong>hooks</strong>：系统默认钩子脚本目录。</li><li><strong>index</strong>：索引文件。</li><li><strong>objects</strong>：Git 本地仓库的所有对象（commits, trees, blobs, tags）。</li><li><strong>refs</strong>：标识你项目里的每个分支指向了哪个提交（commit）。</li><li><strong>logs</strong>：各个 refs 的历史信息。</li></ul></li><li><strong>Stash</strong>：隐藏，是一个工作状态保存栈，用于保存/恢复 WorkSpace 中的临时状态。</li></ul><p>其实 git 就是一个内容寻址的文件系统，通过 key-value 的方式查找数据（key-value data store），我们可以向 Git 仓库中插入 <strong>任意类型</strong> 的内容，它会返回一个唯一的 key ，通过该键可以在任意时刻再次取回该内容。所有的内容都作为<strong>对象</strong>被存储在 objects 文件夹中。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/sha-1.jpg"></p><h4 id="blob-保存文件内容"><a href="#blob-保存文件内容" class="headerlink" title="blob 保存文件内容"></a>blob 保存文件内容</h4><p><code>git hash-object</code> 命令把 test.txt 的当前内容压缩为二进制文件，称为一个 Git 对象，并保存在 <code>.git/objects</code> 文件夹中。这个命令还会计算当前内容（待存储的数据外加一个头部信息（header））的 SHA-1 哈希值（长度40的字符串）。其中，哈希值（校验和）的前 2 个字符用于命名子目录，余下的 38 个字符则用作文件名。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># .git/objects 文件夹内容</span><br>.<br>├── 3b<br>│   └── 18e512dba79e4c8300dd08aeb37f8e728b8dad<br>├── <span class="hljs-builtin-name">info</span><br>└── pack<br></code></pre></td></tr></table></figure><p>一旦你将内容存储在了对象数据库中，那么可以通过 <code>cat-file</code> 命令从 Git 那里取回数据。 这个命令简直就是一把剖析 Git 对象的瑞士军刀。 为 <code>cat-file</code> 指定 <code>-p</code> 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> cat-file -p d<span class="hljs-number">670460</span>b<span class="hljs-number">4</span>b<span class="hljs-number">4</span>aece<span class="hljs-number">5915</span>caf<span class="hljs-number">5</span>c<span class="hljs-number">68</span>d<span class="hljs-number">12</span>f<span class="hljs-number">560</span>a<span class="hljs-number">9</span>fe<span class="hljs-number">3</span>e<span class="hljs-number">4</span><br><span class="hljs-comment"># hello world</span><br></code></pre></td></tr></table></figure><p>值得一提的是，上面的这种操作可以存储任何数据内容形式的文件，但是无法体现出 <strong>文件名</strong> 的信息，那么这种类型的对象我们称之为 <strong>数据对象（blob object）</strong>。</p><h4 id="tree-保存文件名-文件结构"><a href="#tree-保存文件名-文件结构" class="headerlink" title="tree 保存文件名/文件结构"></a>tree 保存文件名/文件结构</h4><p>另一种 Git 对象，树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。 Git 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。 所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。 一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。 例如，某项目当前对应的最新树对象可能是这样的：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vala">git cat-file -p master^&#123;tree&#125;<br><span class="hljs-meta"># 100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</span><br><span class="hljs-meta"># 100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</span><br><span class="hljs-meta"># 040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</span><br></code></pre></td></tr></table></figure><p><code>master^&#123;tree&#125;</code> 语法表示 master 分支上最新的提交所指向的树对象。其中我们发现 lib 也是一个树对象：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> cat-file -p <span class="hljs-number">99</span>f<span class="hljs-number">1</span>a<span class="hljs-number">6</span>d<span class="hljs-number">12</span>cb<span class="hljs-number">4</span>b<span class="hljs-number">6</span>f<span class="hljs-number">19</span>c<span class="hljs-number">8655</span>fca<span class="hljs-number">46</span>c<span class="hljs-number">3</span>ecf<span class="hljs-number">317074</span>e<span class="hljs-number">0</span><br><span class="hljs-comment"># 100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</span><br></code></pre></td></tr></table></figure><p><strong>如何创建一个 tree 对象</strong><br>Git 根据某一时刻暂存区（即 index 区域）所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> update-index --add --cacheinfo <span class="hljs-number">100644</span> <span class="hljs-number">83</span>baae<span class="hljs-number">61804</span>e<span class="hljs-number">65</span>cc<span class="hljs-number">73</span>a<span class="hljs-number">7201</span>a<span class="hljs-number">7252750</span>c<span class="hljs-number">76066</span>a<span class="hljs-number">30</span> test.txt<br></code></pre></td></tr></table></figure><ul><li><code>git update-index</code>：更新暂存区的状态</li><li><code>--add</code>：将这个最新版本的文件添加到暂存区中</li><li><code>--cacheinfo</code>：将要添加的文件可能位于 Git 数据库中，而不是位于当前目录下。</li></ul><p>我们可以通过 <code>git write-tree</code> 命令将暂存区内容（文件结构）写入一个树对象。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> write-tree<br><span class="hljs-comment"># c3b8bb102afeca86037d5b5dd89ceeb0090eae9d</span><br><br><span class="hljs-attribute">git</span> cat-file -t c<span class="hljs-number">3</span>b<span class="hljs-number">8</span>bb<span class="hljs-number">102</span>afeca<span class="hljs-number">86037</span>d<span class="hljs-number">5</span>b<span class="hljs-number">5</span>dd<span class="hljs-number">89</span>ceeb<span class="hljs-number">0090</span>eae<span class="hljs-number">9</span>d <br><span class="hljs-comment"># tree</span><br><br><span class="hljs-attribute">git</span> cat-file -p c<span class="hljs-number">3</span>b<span class="hljs-number">8</span>bb<span class="hljs-number">102</span>afeca<span class="hljs-number">86037</span>d<span class="hljs-number">5</span>b<span class="hljs-number">5</span>dd<span class="hljs-number">89</span>ceeb<span class="hljs-number">0090</span>eae<span class="hljs-number">9</span>d <br><span class="hljs-comment"># 100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dadtest.txt</span><br></code></pre></td></tr></table></figure><h4 id="commit-提交对象"><a href="#commit-提交对象" class="headerlink" title="commit 提交对象"></a>commit 提交对象</h4><p>暂存区的内容如果修改了（文件内容或者文件结构）那么对应保存（快照）下来的 tree 对象就会改变。但是，我们是需要跟踪不同阶段的快照的，相当于一个日志，记录何时何地何人创造了这个快照，以及为什么创造这个快照。那么这个就需要在其 <strong>提交</strong> 的时候保存下来，生成一个提交对象（commit object）。</p><p>可以通过调用 <code>commit-tree</code> 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> &#x27;first commit&#x27; | git commit-tree c<span class="hljs-number">3</span>b<span class="hljs-number">8</span>bb<span class="hljs-number">102</span>afeca<span class="hljs-number">86037</span>d<span class="hljs-number">5</span>b<span class="hljs-number">5</span>dd<span class="hljs-number">89</span>ceeb<span class="hljs-number">0090</span>eae<span class="hljs-number">9</span>d -p &lt;父提交的SHA-<span class="hljs-number">1</span>&gt;<br><span class="hljs-comment"># fb9cbc804df44600a82b601a8688a91b9bb66aaf</span><br></code></pre></td></tr></table></figure><p>由于创建时间和作者不同，每次生成的提交对象会得到不同的散列值。 </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> cat-file -p fb<span class="hljs-number">9</span>cbc<span class="hljs-number">804</span>df<span class="hljs-number">44600</span>a<span class="hljs-number">82</span>b<span class="hljs-number">601</span>a<span class="hljs-number">8688</span>a<span class="hljs-number">91</span>b<span class="hljs-number">9</span>bb<span class="hljs-number">66</span>aaftree c<span class="hljs-number">3</span>b<span class="hljs-number">8</span>bb<span class="hljs-number">102</span>afeca<span class="hljs-number">86037</span>d<span class="hljs-number">5</span>b<span class="hljs-number">5</span>dd<span class="hljs-number">89</span>ceeb<span class="hljs-number">0090</span>eae<span class="hljs-number">9</span>d<br><br><span class="hljs-comment"># tree c3b8bb102afeca86037d5b5dd89ceeb0090eae9d</span><br><span class="hljs-comment"># (可选) parent fb9cbc804df44600a82b601a8688a91b9bb66aaf</span><br><span class="hljs-comment"># author YoujiaZhang &lt;127671784@qq.com&gt; 1635498017 +0800</span><br><span class="hljs-comment"># committer YoujiaZhang &lt;127671784@qq.com&gt; 1635498017 +0800</span><br><br><span class="hljs-comment"># first commit</span><br></code></pre></td></tr></table></figure><p>提交对象的格式很简单：</p><ul><li>它先指定一个顶层树对象，代表当前项目快照</li><li>然后是可能存在的父提交</li><li>之后是作者/提交者信息（依据你的 user.name 和 user.email 配置来设定，外加一个时间戳）</li><li>留空一行，最后是提交注释。</li></ul><p>然后我们就可以通过 <code>git log</code> 查看 Git 提交历史。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vala">git log --stat <span class="hljs-number">426</span>b187<br><br><span class="hljs-meta"># commit 426b18701088fe92755e62ce63a138984cafc994</span><br><span class="hljs-meta"># Author: YoujiaZhang &lt;127671784@qq.com&gt;</span><br><span class="hljs-meta"># Date:   Fri Oct 29 17:08:05 2021 +0800</span><br><span class="hljs-meta"># </span><br><span class="hljs-meta">#     first commit</span><br><span class="hljs-meta"># </span><br><span class="hljs-meta"># commit fb9cbc804df44600a82b601a8688a91b9bb66aaf</span><br><span class="hljs-meta"># Author: YoujiaZhang &lt;127671784@qq.com&gt;</span><br><span class="hljs-meta"># Date:   Fri Oct 29 17:00:17 2021 +0800</span><br><span class="hljs-meta"># </span><br><span class="hljs-meta">#     first commit</span><br><span class="hljs-meta"># </span><br><span class="hljs-meta">#  test.txt | 1 +</span><br><span class="hljs-meta">#  1 file changed, 1 insertion(+)</span><br></code></pre></td></tr></table></figure><p>我们通过这些底层的操作，就完成了一次 Git 提交历史的创建。这其实就是每次我们运行 <code>git add</code> 和 <code>git commit</code> 命令时，Git 所做的工作。</p><ul><li>将被改写的文件保存为数据对象</li><li>更新暂存区</li><li>记录树对象</li><li>创建一个指明了顶层树对象和父提交的提交对象。</li></ul><p>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区（Index）的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库（objects）中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作 <code>git commit</code> 时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新，即 master 最新指向的目录树就是提交时原暂存区的目录树。</p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 </p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%88%86%E6%94%AF.jpg"></p><p><strong>Git 的分支，其实本质上仅仅是指向 “提交对象” 的可变指针。</strong> Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。</p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>我们可以使用 <code>git branch</code> 命令创建一个新的分支（也就是创建一个新的可移动的指针）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch testing</span><br></code></pre></td></tr></table></figure><p>这样的话，在当前所在的提交对象（commit 3）上就多了一个新的指针。我们可以创造很多分支指向不同的提交对象上，但是总得有一个焦点吧，那么我们就用 <strong>HEAD</strong> 指向当前所在的分支。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF.jpg"></p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>我们可以使用 <code>git checkout</code> 命令切换 HEAD 指向的分支。比如，<code>git checkout testing</code>，那么 HEAD 就指向了刚刚我们创建的 testing 分支了。</p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>我们通过不断地执行 <code>git branch\checkout\commit</code> 就会产生很多不同的分支分叉。</p><p><img src="/blog-image/Git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6.jpg"></p><p>当我们多人协作开发一个项目的时候，并行出很多的分支是合理的也是高效的。但是，我们总有“胜利会师”的时候，那么 git 是什么处理不同分支之间的合并工作的呢？请看 <a href="/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/Git%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6/">git分支合并</a>。</p><h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化一个新的仓库。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs stata">git init<br># 已初始化空的 Git 仓库于 /home/XXX/Desktop/WorkSpace/.git/<br><br># .git 的文件结构<br>.<br>├── branches<br>├── config<br>├── description<br>├── HEAD<br>├── hooks<br>│   ├── applypatch-msg.<span class="hljs-keyword">sample</span><br>│   ├── commit-msg.<span class="hljs-keyword">sample</span><br>│   ├── fsmonitor-watchman.<span class="hljs-keyword">sample</span><br>│   ├── <span class="hljs-keyword">post</span>-<span class="hljs-keyword">update</span>.<span class="hljs-keyword">sample</span><br>│   ├── pre-applypatch.<span class="hljs-keyword">sample</span><br>│   ├── pre-commit.<span class="hljs-keyword">sample</span><br>│   ├── prepare-commit-msg.<span class="hljs-keyword">sample</span><br>│   ├── pre-push.<span class="hljs-keyword">sample</span><br>│   ├── pre-rebase.<span class="hljs-keyword">sample</span><br>│   ├── pre-receive.<span class="hljs-keyword">sample</span><br>│   └── <span class="hljs-keyword">update</span>.<span class="hljs-keyword">sample</span><br>├── info<br>│   └── exclude<br>├── objects<br>│   ├── info<br>│   └── pack<br>└── refs<br>    ├── heads<br>    └── tags<br></code></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>从已有的 Git 仓库中 clone（克隆，复制）到本地</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># SSH</span><br>git clone ssh:<span class="hljs-regexp">//u</span>ser@domain.com/repo.git<br><br><span class="hljs-comment"># HTTP</span><br>git clone http:<span class="hljs-regexp">//</span>domain.com<span class="hljs-regexp">/user/</span>repo.git<br></code></pre></td></tr></table></figure><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>将工作区的文件添加到暂存区中</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 把指定文件添加到暂存区</span><br>git <span class="hljs-builtin-name">add</span> xxx<br><br><span class="hljs-comment"># 把当前所有修改添加到暂存区</span><br>git <span class="hljs-builtin-name">add</span> .<br><br><span class="hljs-comment"># 把所有修改添加到暂存区</span><br>git <span class="hljs-builtin-name">add</span> -A<br></code></pre></td></tr></table></figure><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>显示工作区及暂存区域中不同状态的文件。 其中包含了已修改但未暂存，或已经暂存但没有提交的文件。</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>当需要查看任意两棵树（快照）的差异时，可以使用 <code>git diff</code> 命令。 此命令可以查看工作区与暂存区的差异（<code>git diff</code> 默认的做法）；也可以查看暂存区与最后提交之间的差异（<code>git diff --staged</code>），或者比较两个提交记录的差异（<code>git diff master branchB</code>）</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将所有通过 <code>git add</code> 暂存的文件内容在数据库中创建一个持久的快照，然后将当前分支上的分支指针移到其之上。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>用来根据传递的动作参数来执行撤销操作。 它可以移动 HEAD 指针并且可选的改变 index 或者暂存区，如果你使用 <code>--hard</code> 参数，我们甚至可以改变工作区的内容。 如果错误地为这个命令附加后面的参数，我们可能会丢失手头上的工作。</p><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p>用来从工作区中移除不想要的文件的命令。 可以是编译的临时文件或者合并冲突的文件。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>可以列出你所有的分支、创建新分支、删除分支及重命名分支。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>用来切换分支，或者检出内容到工作目录。</p><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>用来展示一个项目的可达历史记录，从最近的提交快照起。 默认情况下，它只显示你当前所在分支的历史记录，但是可以显示不同的甚至多个头记录或分支以供遍历。 此命令通常也用来在提交记录级别显示两个或多个分支之间的差异。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>该命令可以与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后存储在你本地数据库中。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>基本上就是 <code>git fetch</code> 和 <code>git merge</code> 命令的组合体，Git 从你指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>用来与另一个仓库通信，计算你本地数据库与远程仓库的差异，然后将差异推送到另一个仓库中。 它需要有另一个仓库的写权限，因此这通常是需要验证的。</p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>该命令是一个是你远程仓库记录的管理工具。 它允许你将一个长的 URL 保存成一个简写的句柄，例如 origin ，这样你就可以不用每次都输入他们了。 你可以有多个这样的句柄，<code>git remote</code> 可以用来添加，修改，及删除它们。</p><h3 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h3><p>可以以一种简单的人类可读的方式来显示一个 Git 对象。 你一般使用此命令来显示一个标签或一个提交的信息。</p>]]></content>
    
    
    <categories>
      
      <category>版本管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>版本管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NPM 包管理工具</title>
    <link href="/%E5%89%8D%E7%AB%AF/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Node%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/%E5%89%8D%E7%AB%AF/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Node%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="NPM-包管理工具"><a href="#NPM-包管理工具" class="headerlink" title="NPM 包管理工具"></a>NPM 包管理工具</h1><h2 id="认识-NPM"><a href="#认识-NPM" class="headerlink" title="认识 NPM"></a>认识 NPM</h2><p><strong>NPM</strong>（Node Package Manager，即node包管理器），是 nodejs 的包管理工具。npm 的出现，使得前端开发者可以更好的引用别人的代码，还可以很方便的分享自己的代码。并且可以很轻松的更新自己分享出去的代码。如果学过 java，那一定对maven 并不陌生，npm 和 maven 功能上大体相同，可以毫不夸张的说，npm 就是 nodejs 中的 maven。</p><span id="more"></span><p>常见的使用场景有以下几种：</p><ul><li>允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li><li>允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。</li></ul><p>npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p><h2 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h2><h3 id="生成配置文件-npm-init"><a href="#生成配置文件-npm-init" class="headerlink" title="生成配置文件 npm init"></a>生成配置文件 npm init</h3><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vala">npm init<br><br><span class="hljs-meta"># name &gt; 模块（包）名称</span><br><span class="hljs-meta"># version &gt; 模块版本</span><br><span class="hljs-meta"># description &gt; 模块描述</span><br><span class="hljs-meta"># enter point &gt; 入口文件</span><br><span class="hljs-meta"># test command &gt; 测试命令</span><br><span class="hljs-meta"># git repository &gt; git仓库地址</span><br><span class="hljs-meta"># keywords &gt; 关键词</span><br><span class="hljs-meta"># author &gt; 作者</span><br><span class="hljs-meta"># license &gt; 开源声明</span><br></code></pre></td></tr></table></figure><p>npm 最基本的一个命令，就是 <code>npm init</code> ，输入这个命令后，npm 会向用户提问一系列问题，用来初始化生成一个新的 package.json 文件，如果你觉得不用修改默认配置，一路回车就可以了。输入完基本信息后，npm会生成对应的配置文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;npmtest&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><p>npm 命令运行时会读取当前目录的 package.json 文件和解释这个文件，这个文件基于 <a href="http://wiki.commonjs.org/wiki/Packages/1.1">Packages/1.1</a> 规范。在这个文件里你可以定义你的应用名称( name )、应用描述( description )、关键字( keywords )、版本号( version )、应用的配置项( config )、主页( homepage )、作者( author )、资源仓库地址( repository )、bug的提交地址( bugs )，授权方式( licenses )、目录( directories )、应用入口文件( main )、命令行文件( bin )、应用依赖模块( dependencies )、开发环境依赖模块( devDependencies )、运行引擎( engines )和脚本( scripts )等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;A testing package&quot;</span>,<br>    <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;YoujiaZhang&quot;</span>,<br><br>    <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;express&quot;</span>: <span class="hljs-string">&quot;1.x.x&quot;</span>,<br>        <span class="hljs-attr">&quot;ejs&quot;</span>: <span class="hljs-string">&quot;0.4.2&quot;</span>,<br>        <span class="hljs-attr">&quot;redis&quot;</span>: <span class="hljs-string">&quot;&gt;= 0.6.7&quot;</span><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;vows&quot;</span>: <span class="hljs-string">&quot;0.5.x&quot;</span><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;index&quot;</span>,<br><br>    <span class="hljs-attr">&quot;bin&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;./bin/test.js&quot;</span><br>    &#125;,<br><br>    <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;node -v&quot;</span>,<br>        <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;dir&quot;</span>,<br>    &#125;,<br><br>    <span class="hljs-attr">&quot;engines&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;node&quot;</span>: <span class="hljs-string">&quot;0.4.x&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>version -包的版本号</p><ul><li><strong>“5.0.3”</strong> 表示安装指定的版本</li><li><strong>“~5.0.3”</strong> 表示安装5.0.X中最新的版本</li><li><strong>“^5.0.3”</strong> 表示安装5.X.X中最新的版本</li></ul></li><li><p>homepage -包的官网URL</p></li><li><p>contributors -包的其他贡献者</p></li><li><p>dependencies -运行时依赖包列表</p><ul><li>如果依赖包没有安装，npm会自动将依赖包安装在 node_module 目录下。</li></ul></li><li><p>devDependencies -开发时依赖包列表</p><ul><li>开发环境依赖包，主要是在开发环境中用到的依赖包，用命令 npm 的命令 install 或 link 加上参数 <code>—dev</code> 安装到当前模块的 node_modules 目录下。</li></ul></li><li><p>repository -包代码存放的地方的类型</p><ul><li>例如：git、svn。</li></ul></li><li><p>main -指定了程序的主入口文件</p><ul><li>当通过 <code>require(&#39;moduleName&#39;)</code> 引用该模块的时候，就会加载这个入口文件。这个字段的默认值是模块根目录下面的 index.js。</li></ul></li><li><p>scripts -可运行的脚本</p><ul><li>“test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1”</li><li>我们在调用 <code>npm run test</code> 的时候就会执行test脚本，即运行对应的命令。</li></ul></li></ol><div class="note note-info">            <p><strong>dependencies 和 devDependencies 的对比</strong></p><ul><li>dependencies：当别人引用我们使用到的包的时候，包内的依赖包也会被下载下来。</li><li>devDependencies：在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。</li></ul>          </div><h3 id="根据配置文件的安装-npm-install"><a href="#根据配置文件的安装-npm-install" class="headerlink" title="根据配置文件的安装 npm install"></a>根据配置文件的安装 npm install</h3><p>当 $Alice$ 把她的项目传送给 $Bob$ 时，会给对方自己写的代码。但是并不会将 $Alice$ 自己的扩展包拷贝给对方。那么 $Bob$ 就需要先安装可以运行这份代码的相关依赖包，怎么办呢？<strong>不用担心，因为 package.json 文件已经记录了。</strong> 使用如下命令，就会将配置文件记录的依赖全部安装到位。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h2 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h2><p>安装了某个模块，就可以在代码中用 require 命令加载这个模块。新的ES6可以使用import导入包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> backbone = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;backbone&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(backbone.VERSION)<br></code></pre></td></tr></table></figure><p>没有 webpack 之前搜寻整个 node_modules 目标来定位每一个包的路径再手动添加到我们 HTML 文件中（相当的麻烦）</p><p>大多数编程语言都会提供从一个文件导入另一个文件代码的机制。然而 JavaScript 最初设计时并没有这个特性，因为 JavaScript 原本是为了在浏览器端运行而设计的，并没有权限获取计算机客户端的文件系统（安全考虑）。所以很长一段时间以来，组织多个文件的 JavaScript 代码就是把每个文件下载下来，变量是全局共享的。</p><p>CommonJS 中很大一部分便是对模块系统的规范<br>使用 require 语句导入包</p><h2 id="npm-基本操作"><a href="#npm-基本操作" class="headerlink" title="npm 基本操作"></a>npm 基本操作</h2><h3 id="npm-set"><a href="#npm-set" class="headerlink" title="npm set"></a>npm set</h3><p>用于设置环境变量<code>npm set &lt;key&gt;=&lt;value&gt;</code></p><h3 id="npm-info"><a href="#npm-info" class="headerlink" title="npm info"></a>npm info</h3><p>可以查看每个模块的具体信息，比如查看 jQuery 的信息。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">jquery@<span class="hljs-number">3.6</span>.<span class="hljs-number">0</span> | MIT | <span class="hljs-attribute">deps</span>: none | <span class="hljs-attribute">versions</span>: <span class="hljs-number">53</span><br>JavaScript library for DOM operations<br><span class="hljs-attribute">https</span>://jquery.com<br><br><span class="hljs-attribute">keywords</span>: jquery, javascript, browser, library<br><br>dist<br>.<span class="hljs-attribute">tarball</span>: <span class="hljs-attribute">https</span>://registry.npmjs.org/jquery/-/jquery-<span class="hljs-number">3.6</span>.<span class="hljs-number">0</span>.tgz<br>.<span class="hljs-attribute">shasum</span>: c72a09f15c1bdce142f49dbf1170bdf8adac2470<br>.<span class="hljs-attribute">integrity</span>: sha512-JVzAR/AjBvVt2BmYhxRCSYysDsPcssdmTFnzyLEts9qNwmjmu4JTAMYubEfwVOSwpQ1I1sKKFcxhZCI2buerfw==<br>.<span class="hljs-attribute">unpackedSize</span>: <span class="hljs-number">1.3</span> MB<br><br><span class="hljs-attribute">maintainers</span>:<br>- dmethvin &lt;dave.methvin<span class="hljs-keyword">@gmail</span>.com&gt;<br>- timmywil &lt;<span class="hljs-number">4</span>timmywil<span class="hljs-keyword">@gmail</span>.com&gt;<br>- mgol &lt;m.goleb<span class="hljs-keyword">@gmail</span>.com&gt;<br>- openjsfoundation &lt;npm<span class="hljs-keyword">@openjsf</span>.org&gt;<br><br><span class="hljs-attribute">dist-tags</span>:<br><span class="hljs-attribute">beta</span>: <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span>    <span class="hljs-attribute">latest</span>: <span class="hljs-number">3.6</span>.<span class="hljs-number">0</span>  <br><br>published <span class="hljs-number">7</span> months ago by timmywil &lt;<span class="hljs-number">4</span>timmywil<span class="hljs-keyword">@gmail</span>.com&gt;<br></code></pre></td></tr></table></figure><h3 id="npm-search"><a href="#npm-search" class="headerlink" title="npm search"></a>npm search</h3><p>命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式，例如搜索“jquery”。会展示所有包含 “jquery” 字符串的信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NAME</span>                      | DESCRIPTION          | AUTHOR          | DATE       | VERSION  | KEYWORDS                         <br><span class="hljs-attribute">jquery</span>                    | JavaScript library…  | =dmethvin…      | <span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">02</span> | <span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">0</span>    | jquery javascript browser library<br><span class="hljs-attribute">cheerio</span>                   | Tiny, fast, and…     | =mattmueller…   | <span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">08</span> | <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>-r… | htmlparser jquery selector scraper parser html<br><span class="hljs-attribute">object</span>.assign             | ES<span class="hljs-number">6</span> spec-compliant…  | =ljharb         | <span class="hljs-number">2020</span>-<span class="hljs-number">10</span>-<span class="hljs-number">31</span> | <span class="hljs-number">4</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>    | Object.assign assign ES<span class="hljs-number">6</span> extend $.extend jQuery _.extend Underscore es-shim API polyfill s<br><span class="hljs-attribute">jquery</span>-ui                 | A curated set of…    | =scott.gonzalez… | <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">07</span> | <span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span>   | <br><span class="hljs-attribute">ua</span>-parser-js              | Detect Browser,…     | =faisalman      | <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">27</span> | <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>    | user-agent parser browser engine os device cpu jquery-plugin ecosystem:jquery<br><span class="hljs-attribute">papaparse</span>                 | Fast and powerful…   | =mholt =pokoli  | <span class="hljs-number">2021</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> | <span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>    | csv parser parse parsing delimited text data auto-detect comma tab pipe file filereader st<br><span class="hljs-attribute">jquery</span>-migrate            | Migrate older…       | =krinkle…       | <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">17</span> | <span class="hljs-number">3</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>    | jquery javascript browser plugin migrate<br><span class="hljs-attribute">crawler</span>                   | Crawler is a web…    | =sylvinus…      | <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">23</span> | <span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span>    | dom javascript crawling spider scraper scraping jquery crawler nodejs<br><span class="hljs-attribute">jquery</span>-validation         | Client-side form…    | =jzaefferer…    | <span class="hljs-number">2021</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span> | <span class="hljs-number">1</span>.<span class="hljs-number">19</span>.<span class="hljs-number">3</span>   | jquery jquery-plugin forms validation validate<br><span class="hljs-attribute">inputmask</span>                 | Inputmask is a…      | =robinherbots   | <span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span> | <span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span>    | form input inputmask jquery jquery-plugin mask plugins<br><span class="hljs-attribute">urijs</span>                     | URI.js is a…         | =rodneyrehm     | <span class="hljs-number">2021</span>-<span class="hljs-number">07</span>-<span class="hljs-number">14</span> | <span class="hljs-number">1</span>.<span class="hljs-number">19</span>.<span class="hljs-number">7</span>   | uri url urn uri mutation url mutation uri manipulation url manipulation uri template url t<br><span class="hljs-attribute">bootstrap</span>-select          | The jQuery plugin…   | =caseyjhol      | <span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">26</span> | <span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">18</span>  | javascript jquery form bootstrap dropdown select replacement<br><span class="hljs-attribute">jquery</span>-timepicker         | Enhances standard…   | =wvega          | <span class="hljs-number">2016</span>-<span class="hljs-number">05</span>-<span class="hljs-number">23</span> | <span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">3</span>    | timepicker time picker calendar dropdown input form<br><span class="hljs-attribute">jquery</span>-externalize        | Externalize is a…    | =dreamseer      | <span class="hljs-number">2021</span>-<span class="hljs-number">05</span>-<span class="hljs-number">12</span> | <span class="hljs-number">4</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>    | links window jquery-plugin ecosystem:jquery<br><span class="hljs-attribute">suggestions</span>-jquery        | DaData.ru…           | =antonz =dunal  | <span class="hljs-number">2021</span>-<span class="hljs-number">08</span>-<span class="hljs-number">02</span> | <span class="hljs-number">21</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>   | <br><span class="hljs-attribute">pwstrength</span>-bootstrap      | jQuery plugin for…   | =ablanco        | <span class="hljs-number">2021</span>-<span class="hljs-number">06</span>-<span class="hljs-number">01</span> | <span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>    | bootstrap password strength meter jquery-plugin ecosystem:jquery<br><span class="hljs-attribute">bootstrap</span>-maxlength       | A visual feedback…   | =mimo<span class="hljs-number">84</span>         | <span class="hljs-number">2021</span>-<span class="hljs-number">04</span>-<span class="hljs-number">28</span> | <span class="hljs-number">1</span>.<span class="hljs-number">10</span>.<span class="hljs-number">1</span>   | form maxlength html<span class="hljs-number">5</span> input feedback jquery-plugin jquery bootstrap bs<br></code></pre></td></tr></table></figure><h3 id="npm-list"><a href="#npm-list" class="headerlink" title="npm list"></a>npm list</h3><p>会以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npmtest@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span> <span class="hljs-regexp">/home/</span>XXX<span class="hljs-regexp">/Desktop/</span>npmTest<br>└── jquery@<span class="hljs-number">3.6</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="npm-update"><a href="#npm-update" class="headerlink" title="npm update"></a>npm update</h3><p>更新已安装模块 <code>npm update &lt;packageName&gt;</code></p><h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><p>使用 npm 安装包的命令格式为： <code>npm [install/i] [package_name]</code></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"># 本地安装<br>npm install &lt;<span class="hljs-keyword">package</span> <span class="hljs-title">name&gt;</span><br><br># 全局安装<br>npm install -g &lt;<span class="hljs-keyword">package</span> <span class="hljs-title">name&gt;</span><br>npm install -globel &lt;<span class="hljs-keyword">package</span> <span class="hljs-title">name&gt;</span><br></code></pre></td></tr></table></figure><p><code>npm install</code> 也支持直接输入 Github 代码库地址。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/package/</span>path.git<br>npm install git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/package/</span>path.git<span class="hljs-comment">#0.1.0</span><br></code></pre></td></tr></table></figure><p>安装之前，<code>npm install</code> 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也不会重新安装。</p><p>如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 <code>-f</code> 或 <code>–force</code> 参数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install &lt;packageName&gt; <span class="hljs-comment">--force</span><br></code></pre></td></tr></table></figure><p>虽然最新版本是以前旧版本的更新，但是在某些情况下最新的不一定是最合适的。所以我们希望安装指定的版本而不是默认安装最新的。我们可以在模块名后面加上 <strong>@</strong> 和版本号</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jquery@latest</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jquery@1.2.2</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jquery@&quot;&gt;=0.1.0 </span>&lt;<span class="hljs-number">0</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">–<span class="hljs-built_in">save</span>：模块名将被添加到 <span class="hljs-built_in">dependencies</span>，可以简化为参数-S。<br>–<span class="hljs-built_in">save</span>-dev：模块名将被添加到 devDependencies，可以简化为参数-D。<br></code></pre></td></tr></table></figure><h4 id="本地安装与全局安装"><a href="#本地安装与全局安装" class="headerlink" title="本地安装与全局安装"></a>本地安装与全局安装</h4><p>npm 在默认情况下会从 <a href="http://npmjs.org/">http://npmjs.org</a> 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。</p><p>如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p><p>我们在使用 supervisor 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 supervisor 。</p><p>这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 supervisor 来启动服务了。</p><p>supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。</p><p><strong>一般来说，全局安装只适用于工具模块</strong>，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为<strong>本地模式不会注册 PATH 环境变量</strong>。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。</p><div class="note note-info">            <p><strong>本地安装</strong>：</p><ul><li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li><li>可以通过 require() 来引入本地安装的包。</li></ul><p><strong>全局安装</strong>：</p><ul><li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li><li>可以直接在命令行里使用。</li></ul>          </div><h3 id="npm-run"><a href="#npm-run" class="headerlink" title="npm run"></a>npm run</h3><p>npm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件中的 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&quot;scripts&quot;: &#123;<br>    &quot;<span class="hljs-keyword">build</span><span class="hljs-string">&quot;: &quot;</span>npm run <span class="hljs-keyword">build</span>-js &amp;&amp; npm run <span class="hljs-keyword">build</span>-css<span class="hljs-string">&quot;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>字符串 “build” 对应的命令为：上面的写法是先运行 <code>npm run build-js</code>，然后再运行 <code>npm run build-css</code>，两个命令中间用 <strong>&amp;&amp;</strong> 连接。如果希望两个命令同时平行执行，它们中间可以用 <strong>&amp;</strong> 连接。</p><p>写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">cd</span> site/main<br>browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js<br></code></pre></td></tr></table></figure><p>假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。<code>&quot;build-js&quot;: &quot;bin/build.sh&quot;</code></p><div class="note note-info">            <p>npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。<br>npm 内置了两个命令简写：</p><ul><li><code>npm test</code> 等同于执行 <code>npm run test</code></li><li><code>npm start</code> 等同于执行 <code>npm run start</code></li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>包管理工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器</title>
    <link href="/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><span id="more"></span><h2 id="为什么需要布隆过滤器？"><a href="#为什么需要布隆过滤器？" class="headerlink" title="为什么需要布隆过滤器？"></a>为什么需要布隆过滤器？</h2><p>在软件设计时，我们经常要判断一个元素是否在一个集合中。</p><ul><li>网络爬虫时，一个网址是否已经被访问过</li><li>一个邮件地址是否在黑名单中应该被过滤掉</li><li>在文字处理软件中某个英文单词是否拼写正确</li><li>用户的名字是否在一个名单中</li></ul><p>一个直接的方法是，将集合中的所有元素都存储在计算机中（如保存在<strong>链表、树、哈希表</strong>等数据结构）。当要判断一个新元素的时候，直接跟集合中的已存储元素对比即可判断元素是否在集合中。但是，当随着加入的数据量增加，我们需要存储元素的空间就越来越大，而且检索速度也会开始变慢。链表、树、哈希表的数据结构检索时间复杂度分别为：$\rm O(N)$、$\rm O(logN)$、$\rm O(N/k)$。</p><p>举个例子，像 Gmail 这种邮件服务提供商，要过滤垃圾邮件。如果采用上面说的方法，将垃圾邮件加入到哈希表中，那至少要加入数 <strong>10亿</strong> 的垃圾邮件地址。每存储一个亿的 email 地址，就需要 <strong>1.6GB</strong>（8·2·1亿 =1.6GB，将一个 email 地址转换成一个 8 字节的信息指纹并存入到<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a>中。由于**哈希表的存储效率一般只有 50%**，所以实际存储一个 email 地址需要 16 字节，一个亿的 email 地址就大概需要 1.6GB 的内存空间，如果存储几十亿的 email 地址，就可能需要几十上百的内存空间）。</p><p>所以传统的存储方法要求要大量的存储空间。而采用布隆过滤器，<strong>它只需要哈希表的 1/8 或 1/4 的大小</strong>（也就是只需要 200MB 或 400MB 的空间）就可以解决问题。</p><div class="note note-info">            <p><strong>分析</strong><br><strong>Q</strong>：为什么 Hash 表的存储效率通常小于 50%？<br><strong>A</strong>：常用于频繁进行 key-value 模式的查找中（查找模式，如匹配查找）。哈希表最大的优点在于查找速度快，但存储时可能发生 collision（对撞）。哈希表大多使用 <strong>开地址法</strong> 来解决 Hash 对撞，此时查找的时间复杂度计算公式取决于$\rm times$：<br>$$ \textrm{times} = \frac{1}{(1 - k/m)}$$</p><p>其中，$k$ 与 $m$ 分别表示存储的记录数与哈希表的长度，即装填因子 $α$ (load factor)。故，若哈希表半满，即：<br>$$\frac{k}{m} \geq \frac{1}{2}$$<br>则每次的查找的次数可能会 $\textrm{times} \geq 2$，因此，为了保证哈希表在 key-value 查找模式中的优势，**一般其存储效率不会超过50%**。</p>          </div><h2 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h2><p>布隆过滤器是一个基于 $m$ 位的比特向量（$b_1,b_2…,b_m$），这些比特向量的初始值为 0。同时还有一系列的哈希函数（$h_1,h_2…,h_k$），这些哈希函数运算后的哈希值范围在 $[1, m]$ 内。</p><p>如下图，我们将 $x,y,z$ 三个元素作为一个集合插入到布隆过滤器中，并判断 $w$ 值是否在集合中的示意图。</p><p><img src="/blog-image/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.jpg"></p><p>在上图中，$m=18$，$k=3$，$h_1$、$h_2$ 和 $h_3$ 是三个哈希函数将输入值分别映射成比特向量上的某个位置上。插入 $x$值（对应红线），则将经过 $h_1$、$h_2$ 和 $h_3$ 三个哈希函数映射到的比特向量上的值改为 $1$。同理，对 $y$（对应绿线）和 $z$（对应蓝线）值也一样操作。</p><p>如果要查找 $x,y,z$，通过布隆过滤器可以找到对应的比特向量都为 $1$，我们只能确定想 $x,y,z$ 可能在集合中。这里我们我上图中，可以发现，$x$ 和 $z$ 在 $h_2$ 哈希函数映射后映射到的是同一个比特向量位置（<strong>第6个</strong>），同时 $x$ 和 $z$ 在经过 $h_3$ 映射后也是同一个比特向量位置（<strong>第12个</strong>）。也就是说，当我们通过布隆过滤器判断一个元素是否在集合中时，即使对应的比特向量位置全为 $1$，也可能是其他元素映射后导致的。如果要查找 $w$ 值，经过哈希映射后，可以发现有一个比特向量上的值不为 $1$ ，那就可以判断，$w$ 值一定不在集合中。</p><ul><li>如果这些点有任何一个 $0$，则被检元素一定不在</li><li>如果都是 $1$，则被检元素很可能在</li></ul><p>所以布隆过滤器只能判断一个元素可能在集合中。<strong>而且插入的数据越多，误报的概率也越大</strong>。具体关于误报概率的分析可以参考wiki文章：<a href="https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives">Probability of false positives</a></p><p>$$P_{error} \approx (1-e^{-kn/m})^k$$</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>布隆过滤器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hash 表</title>
    <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h1><p>哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做散列函数（Hash 函数），存放记录的数组称做散列表。</p><span id="more"></span><h2 id="1-查找过程"><a href="#1-查找过程" class="headerlink" title="1. 查找过程"></a>1. 查找过程</h2><ul><li>存储时: 通过 Hash 函数计算记录的 Hash 地址, 并按此散列地址存储该记录（先计算地址再储存）</li><li>查找记录时: 通过同样的 Hash 函数计算记录的 Hash 地址, 按此 Hash 地址访问该记录</li></ul><p>散列技术既是一种存储方法, 又是一种查找方法。散列的记录之间不存在什么逻辑关系, 它只与关键字有关。散列技术最适合的求解问题是查找与给定值相等的记录。</p><p>拥有同样关键字但是对应多重记录情况的不适合使用散列。比如利用性别查找一个学生, 相反, 利用学号或者身份证号来散列存储才比较合适。</p><h2 id="2-Hash-函数构造方法"><a href="#2-Hash-函数构造方法" class="headerlink" title="2. Hash 函数构造方法"></a>2. Hash 函数构造方法</h2><p>设计的原则：（1）计算简单（2）Hash 地址均匀分布</p><h3 id="2-1-直接定址法"><a href="#2-1-直接定址法" class="headerlink" title="2.1 直接定址法"></a>2.1 直接定址法</h3><p>取关键字的某个线性函数作为散列地址, 即<br>$$f_{hash}(key)=a*key+b$$</p><h3 id="2-2-除留余数法"><a href="#2-2-除留余数法" class="headerlink" title="2.2 除留余数法"></a>2.2 除留余数法</h3><p>对于散列表长度为 $m$ 的散列函数公式为：<br>$$f_{hash}(key)=key<del>\rm mod</del>p<del>(p\leq m)$$<br>例如：下表采用 $f(key) = key</del>\rm mod~12$</p><table><thead><tr><th align="center">关键字</th><th align="center">12</th><th align="center">25</th><th align="center">38</th><th align="center">15</th><th align="center">16</th><th align="center">29</th><th align="center">78</th><th align="center">67</th><th align="center">56</th><th align="center">21</th><th align="center">22</th></tr></thead><tbody><tr><td align="center">地址</td><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">10</td></tr></tbody></table><h3 id="2-3-随机数"><a href="#2-3-随机数" class="headerlink" title="2.3 随机数"></a>2.3 随机数</h3><p>取关键字的随机函数作为它的散列地址：<br>$$f_{hash}(key)=random(key)$$</p><h3 id="2-4-平方取中法"><a href="#2-4-平方取中法" class="headerlink" title="2.4 平方取中法"></a>2.4 平方取中法</h3><p>如果, 关键字是1234, 平方就是 1522756 , 取中间三位为 227, 用作散列地址。适合于不知道关键字分布, 位数也不是很大的方法。</p><h3 id="2-5-折叠法"><a href="#2-5-折叠法" class="headerlink" title="2.5 折叠法"></a>2.5 折叠法</h3><p>将关键字左右分割为相等的几部分, 将这几部分叠加求和, 按照散列表表长, 取最后几位作为地址。例如 9876543210, 987+654+321+0=1962, 以 962 作为地址。为保证分布均匀也可以将一端反转后再相加如 789+654+123+0=1566, 此时散列地址为 566。这种适合关键字较长的情况。</p><h2 id="3-Hash-冲突的处理办法"><a href="#3-Hash-冲突的处理办法" class="headerlink" title="3. Hash 冲突的处理办法"></a>3. Hash 冲突的处理办法</h2><p>Hash 函数设计的再优秀，还是又可能会出现不同的输入计算出相同 Hash 值的情况。Hash 冲突: 对于关键字 $$key_1\neq  key_2$$，却有 $$f_{hash}(key_1) = f_{hash}(key_2)$$。</p><h3 id="3-1-开地址法"><a href="#3-1-开地址法" class="headerlink" title="3.1 开地址法"></a>3.1 开地址法</h3><p>开地址法是指一旦发生了冲突，就去<strong>寻找</strong>下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，公式是:</p><p>$$f_i(key)=(f(key)+d_i)<del>\textrm{mod}</del>m~(d_i=1,2,3,…,m−1)$$</p><p>“寻找”下一个空的地址的方法有很多。</p><h4 id="3-1-1-线性探寻法"><a href="#3-1-1-线性探寻法" class="headerlink" title="3.1.1 线性探寻法"></a>3.1.1 线性探寻法</h4><p>比如我们采用散列函数 $f(key)=key<del>\textrm{mod}</del>12$ 可以发现 $f(25)=1$, 当 $key=37$ 时就出现了冲突，于是依照上面的公式有 $f(37)=(f(37)+1)<del>\textrm{mod}</del>12=2$。</p><p>假如 $key=48$ 也发生了冲突，那么按上述公式应该为 $f(48)=(f(48)+1)<del>\textrm{mod}12=1$，这又和 $25$ 所在位置冲突, 于是 $f(48)=(f(48)+2)</del>\textrm{mod}12=2$，还是冲突, 一直到 $f(48)=(f(48)+3)~\textrm{mod}12=3$，才出现空位。</p><p>像 $48$ 和 $37$ 这种本来不是同义词却要争夺相同地址的情况称为<strong>堆积</strong>。</p><h4 id="3-1-2-二次探寻法"><a href="#3-1-2-二次探寻法" class="headerlink" title="3.1.2 二次探寻法"></a>3.1.2 二次探寻法</h4><p>为了避免关键词都“堆积”在某一区域，可以对上述公式进行优化了，增加平方运算来改进 $d_i$:</p><p>$$f_i(key)=(f(key)+d_i)~ \textrm{mod} <del>m</del>(d_i=1^2,−1^2,2^2,−2^2,…,q^2,−q^2,q≤m/2)$$</p><h4 id="3-1-3-随机探寻法"><a href="#3-1-3-随机探寻法" class="headerlink" title="3.1.3 随机探寻法"></a>3.1.3 随机探寻法</h4><p>还有一种解决办法是，对于位移量 $d_i$ 采用随机函数得到，称为随机探测法：<br>$$f_i(key)=(f(key)+d_i)~ \textrm{mod} <del>m</del>$$</p><h3 id="3-2-再散列函数法"><a href="#3-2-再散列函数法" class="headerlink" title="3.2 再散列函数法"></a>3.2 再散列函数法</h3><p>$$f_i(key)=RH_i(key)~(i=1,2,3,…,k)$$<br>事先准备多个散列函数，这里的 $RH_i$ 就是不同的散列函数，每当发生散列冲突就换一个散列计算函数，当然也相应的增加了计算时间。</p><h3 id="3-3-链地址法"><a href="#3-3-链地址法" class="headerlink" title="3.3 链地址法"></a>3.3 链地址法</h3><p>不需要冲突换址，将所有关键词的同义词记录在一个单链表中，称为，<strong>同义词表</strong>，在哈希表中只存储同义词表的头指针。无论有多少冲突，都这是在当前位置给单链表增加节点。</p><p><img src="/blog-image/Hash%E8%A1%A8/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.jpg"></p><p>在哈希表每一个单元中设置链表，某个数据项对的关键字还是像通常一样映射到哈希表的单元中，而数据项本身插入到单元的链表中。简单理解如下：</p><ul><li><strong>优点</strong>：为所有冲突提供了地址保障。</li><li><strong>缺点</strong>：带来了查找时需要遍历单链表的性能损耗。</li></ul><h3 id="3-4-公共溢出区法"><a href="#3-4-公共溢出区法" class="headerlink" title="3.4 公共溢出区法"></a>3.4 公共溢出区法</h3><p>为有冲突的关键字提供公共溢出区来存放。</p><p>在查找时对给定值通过散列函数计算散列地址后，先与基本表对应位置进行对比，如果相等则查找成果，如果不相等则到溢出表去进行顺序查找。</p><h2 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h2><p>如果没有冲突, 那么 Hash 表查找的时间复杂度为 $O(1)$, 但是冲突往往无法避免，那么 Hash 查找的平均查找长度取决于：</p><ul><li>散列是否均匀</li><li>处理冲突的方法, 线性探测冲突可能产生堆积, 链地址法不产生任何堆积。因此后者平均性能更好.</li><li><strong>Hash 表的装填因子</strong>, $α=\frac{k}{m}$，其中 $k$ 是表中记录的个数，$m$ 是散列表长度。$α$ 越大越容易产生冲突。通常设置 Hash 表空间比集合大，以空间换时间。</li></ul><h3 id="4-1-查找成功-ASL"><a href="#4-1-查找成功-ASL" class="headerlink" title="4.1 查找成功 ASL"></a>4.1 查找成功 ASL</h3><ul><li>线性探测再散列<br>$$S \approx \frac{1}{2}(1+\frac{1}{1-α})$$</li><li>随机探测再散列<br>$$S \approx -\frac{1}{α}ln(1-α)$$</li><li>链地址法<br>$$S \approx 1+\frac{α}{2}$$</li></ul><h3 id="4-1-查找失败-ASL"><a href="#4-1-查找失败-ASL" class="headerlink" title="4.1 查找失败 ASL"></a>4.1 查找失败 ASL</h3><ul><li>线性探测再散列<br>$$U \approx \frac{1}{2}(1+\frac{1}{(1-α)^2})$$</li><li>随机探测再散列<br>$$U \approx \frac{1}{1-α}$$</li><li>链地址法<br>$$U \approx α+e^α$$</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>哈希表的平均查找长度是装填因子 $α$ 的函数，而不是 $k$ 的函数。这说明，用哈希表构造查找表时，可以选择一个适当的装填因子 $α$，使得平均查找长度限定在某个范围内。<strong>这是哈希表所特有的特点</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链如何运用 Merkle Tree</title>
    <link href="/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%20Merkle%20Tree/"/>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8%20Merkle%20Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="区块链如何运用-Merkle-Tree"><a href="#区块链如何运用-Merkle-Tree" class="headerlink" title="区块链如何运用 Merkle Tree"></a>区块链如何运用 Merkle Tree</h1><p><a href="/%E5%8C%BA%E5%9D%97%E9%93%BE/MerkleTree/">Merkle Tree</a> 被广泛应用于区块链中，但并不是只有区块链使用它进行校验。比如一些 P2P 下载（迅雷），就需要把文件分割成若干小文件，每块都是一个拥有一个 Hash 值，每块从不同的网络节点中下载，最后组成一个完成的文件，但是也需要Hash验证，他可以使用 Merkle Tree 进行验证。Merkle Tree 不一定是二叉树，可以是任意的树结构。在以太坊中，Merkle 验证还不够用，增加了 Patricia Tree 验证，合起来成为 “<strong>Merkle Patricia Tree</strong>”。</p><span id="more"></span><h2 id="简单支付认证-SPV"><a href="#简单支付认证-SPV" class="headerlink" title="简单支付认证 SPV"></a>简单支付认证 SPV</h2><p><img src="/blog-image/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8MerkleTree/blockStruct.png"></p><p>区块链中的每一个区块主要是两个部分：区块头 + 区块体。<br>区块体中包含了完整的交易信息，而一个区块体中包含的数据信息可能是成百上千的，所以这会消耗用户大量的存储空间。为了解决这个问题，<strong>中本聪就提出了 SPV(Simple Payment Verification) 的概念</strong>，即只保存每一个区块的区块头。 </p><p><strong>SPV</strong>: 不运行全节点也可以验证支付，用户只需要保存所有的区块头就可以了。虽然用户不能自己验证交易，但如果能够从区块链的某处找到符合的交易，就可以知道这笔交易已被网络确认，也可以确认该笔交易得到网络多少笔确认。</p><div class="note note-info">            <p>这里需要注意的是，SPV强调的是<strong>验证支付</strong>，不是验证交易，这两个概念是不同的。</p><ul><li>验证支付：比较简单，只需要判断用于支付的那笔交易是否被验证过，以及得到网络多少次确认（即有多少个区块叠加）。</li><li>验证交易：则复杂的多，需要验证账户余额是否足够支出、是否存在双重支付、交易脚本是否通过等问题，一般这个操作是由全节点的矿工来完成。全节点:包含钱包（支付验证）、矿工、完整区块链数据库、网络路由节点的功能。</li></ul>          </div><h2 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h2><p>在SPV节点上，不保存全部区块链数据，不下载区块全部交易，只保存区块头数据。所以这种节点不能验证全部交易，只能用于验证支付（确认支付是在区块链中，以及确认多少次）。</p><p>那么，从用户 $\rm A$ 在购买商品时通过比特币支付，并声称自己已经转了$\rm 1BTC$给商家，到商家验证支付有效（SPV验证），这个过程是怎样的呢？</p><ul><li>Step 1： SPV节点如果只关心某个支付到自己比特币地址的交易，则可以通过建立布隆过滤器限制只接收含有目标比特币地址的交易。</li><li>Step 2：一旦比特币网络中其他当节点探测到某个交易符合SPV节点设置的<a href="/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>条件时，其它节点将以 <strong>Merkle block</strong> 消息的形式发送该区块，Merkle block 消息包含区块头和一条连接目标交易与 Merkle root 的 Merkle 路径。</li><li>Step 3：接下来，SPV节点需要验证交易，需要做 $2$ 个检查，分别是：<ul><li>（1）<strong>交易的存在性检查</strong></li><li>（2）<strong>交易是否双花的检查</strong></li></ul></li><li>Step 4：SPV节点通过该Merkle路径找到跟该交易相关的区块，并验证对应区块中是否存在目标交易（该过程也被称为，<strong>Merkle Path Proof</strong>）。SPV节点所收到的 Merkleblock 数据量通常少于1KB，只有一个完整区块（大约1MB）大小的千分之一左右。</li><li>Step 5：现在通过 Merkle Path Proof，SPV 节点确认了交易确实存在于区块链中，但是这个还是无法保证这笔交易的Input（引用的上一笔UTXO）没有被双花（双重支付）。这时候 SPV 节点通过去看这笔交易所在区块之后的区块个数，<strong>Block 个数越多说明该区块被全网更多节点共识</strong>，一般来说，一笔交易所属区块之后的区块个数达到 <strong>6</strong> 个时，就说明这笔交易是被大家核准过（达成共识）的，没有双花，而且被篡改的可能性也很低。</li></ul><div class="note note-info">            <p><strong>分析</strong><br><strong>Q</strong>：Step 2 中为什么需要让别的节点告诉 SPV节点呢？<br><strong>A</strong>：因为 SPV 节点没有本地完整区块链数据，因此它需要向网络发起查询请求。</p><p><strong>Q</strong>：Step 5 中提到的 UTXO是什么？<br><strong>A</strong>：UTXO 是 Unspent Transaction Outputs 的缩写。实际可以理解为在一次转账时剩余没有转出的资金，举一个例子：</p><p><img src="/blog-image/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8MerkleTree/UTXO.jpg"></p><ul><li>假设当前用户 $A$ 余额是 $1000$ 元，如果用户 $A$ 给用户 $B$ 转 $100$ 元，这笔转账会被记录成：<ul><li>交易1：用户 $A$ 给用户 $B$ 转账 $100$ 元</li><li>交易2：用户 $A$ 给用户 $A$ 自己转账 $900$ 元 （UTXO）</li></ul></li></ul><p>这里的 交易2 虽然是一笔交易，但从功能上来说他担当了账户余额的作用，表示在完成这笔 100 元转账后A的账户上还剩余 900 元。</p><p>那么问题来了，为啥非要造一个这样的 UTXO 呢？因为在区块链上只能记录交易，没法记录账户余额。如果没有这个 UTXO 的话，要计算余额需要把一个账户的所有交易的入账和出账全部累加一遍，这是个非常消耗时间和计算资源的事情。<strong>而 UTXO 的出现巧妙的避免了在计算余额时要回溯所有交易的痛点问题</strong>。</p>          </div><h2 id="Merkle-路径"><a href="#Merkle-路径" class="headerlink" title="Merkle 路径"></a>Merkle 路径</h2><p>如果需要证明某个区块上是否存在一笔交易C，那么我们只需要N3和N4的哈希值构成的Merkle路径就可以证明，过程如下：</p><p><img src="/blog-image/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8MerkleTree/proof.jpg"></p><ul><li>获取交易C的哈希值，$T2 = Hash(C)$</li><li>通过 T2 和 T3 的哈希值，得到父节点的哈希值：$N5=Hash(T2+T3)$</li><li>同上，通过 T4 和 T5 的哈希值，得到根节点的哈希值：$Root=Hash(T4+T5)$</li><li>然后将上一步得到的根哈希值对比区块头中MerkleTree的根哈希值，如果相同，则证明该区块中存在交易C，否则说明不存在</li></ul><p>换句话说，对于一个包含 <strong>4</strong> 个交易的区块，我们只需要 <strong>2个哈希节点</strong> 就可以进行支付验证。</p><p>这里，由于区块中交易数量少，可能不能很明显地体现出 Merkle Tree 结构的优越性。假如，我们来逐渐增加区块中交易的数量：</p><ul><li>$16$ 笔交易，$\rm 4KB$，$log_2(16)=4$，$4*32=128$字节</li><li>$512$ 笔交易，$\rm 128KB$，$log_2(512)=9$，$9*32=288$字节</li><li>$2048$ 笔交易，$\rm 512KB$，$log_2(2048)=11$，$11*32=352$字节</li><li>$65536$ 笔交易，$\rm 16MB$，$log_2(65536)=16$，$16*32=512$字节</li></ul><div class="note note-info">            <p>一个 Hash 值大小为 32 字节</p>          </div><p>我们可以看到，当交易数量成几何速度成长时，Merkle 路径的开销增长就很缓慢。所以，通过 Merkle 路径，SPV 节点只需要很小的开销就可以快速定位一笔交易。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Merkle Tree</title>
    <link href="/%E5%8C%BA%E5%9D%97%E9%93%BE/MerkleTree/"/>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE/MerkleTree/</url>
    
    <content type="html"><![CDATA[<h1 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h1><p>在密码学及计算机科学中是一种树形数据结构，每个叶节点均以数据块的哈希作为标签，而除了叶节点以外的节点则以其子节点标签的加密哈希作为标签 。Merkle tree 能够高效、安全地验证大型数据结构的内容，是哈希链的推广形式。哈希树的概念由 Ralph Charles Merkle 于 1979 年申请专利，故亦称 Merkle tree。</p><span id="more"></span><h2 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h2><p>第一次接触 hash 函数是在数据结构的课上，之后在学习密码学的过程中也经常应用到了 hash 函数。hash 函数最大的特点就是：<strong>如果输入之间有一丝一毫的差距，那么输出大不相同</strong>。而且 hash 函数类似于一个单向阀门，计算输出很容易，但是从输出反推回去相当困难。</p><p><img src="/blog-image/MerkleTree/MerkleTree-1.png"></p><ul><li>正向容易算</li><li>反向不可逆性</li><li>很难找到具有相同输出的两个不同数据</li></ul><p>如果我们在传送数据的过程中，数据有丝毫的损坏，那么再次计算的 hash 值就会不同，所以我们可以使用 hash 函数验证数据的完整性。</p><h2 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h2><p>在网络中传输小数据时，如果数据被损害，我们重新传输一次也没什么关系。但是，如果是面对较大的数据呢？难道因为一个 bit 的误差而重新传输整个数据文件？这样的话除非网络或者机器具有很高的稳定性和可信性，否则能成功传输一个超大文件的概率就会很低。下面展示了成功传输 $\rm 1GB$ 数据的难度。<br>$$P_{success}(bit) = n, \rm 1GB = 8589934592bit$$<br>$$n = 0.99999999999,n^{8589934592}=0.917687$$<br>$$n = 0.9999999999,n^{8589934592}=0.423588$$<br>$$n = 0.999999999,n^{8589934592}=0.000185968$$</p><p>为了解决这个问题，我们会将比较大的数据切分成若干小数据块，这样如果一个数据块损坏了，我们只需要下载对应的小块而不用重现下载整个数据文件，每一个数据块都拥有自己的 hash 值。在下载真实数据时，我们会先下载一个 hash 表。那么问题在于，我们怎么保证 hash 表的数据就是完整的呢？</p><p><strong>Root Hash</strong>，我们把每一个小块的 hash 值拼接到一起，对于这个长长的字符串再做一次 hash 运算，最终得到了 hash 表的 Root hash。这样就可以验证 hash 表中的每一个数据是不是正确的了，进而可以保证下载的每一个数据块是正确的。</p><p><img src="/blog-image/MerkleTree/MerkleTree-2.png"></p><p>问题在于，hash 表可能本身就是一个较大的数据，这仿佛又回到了问题的起点。这时 $Merkle$ 看不下去了，灵机一动种了一棵“树”。</p><h2 id="Merkle-Tree-1"><a href="#Merkle-Tree-1" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h2><p><img src="/blog-image/MerkleTree/MerkleTree-3.png"></p><p>同样的，Merkle 树的所有的叶子节点都是数据块的 hash 值，不同之处在于，在处理 hash 值的时候，不像之前直接全部打包然后在一起计算，而是 <strong>“分而治之，两两结合”</strong> 。好处就在于，如果有一个数据块出错了导致 hash 值对不上，我们可以通过二分查找的方式快速锁定其位置。同理，当我们需要查询一个叶子节点是否在这棵树上时，只需要计算该叶子节点到根的路径上需要计算的 hash 值，并不需要所有的叶子都参与计算。</p><ul><li>快速比较大量数据：如果根相同，代表根下的叶子都相同</li><li>快速定位出错数据：顺藤摸瓜</li><li>零知识证明：证明某一个数据 $\rm A$ 在一组数据中，但又不想让对方知道数据 $\rm A$ 的具体内容，那么我们可以构建 Merkle 树。告诉对方包含数据 $\rm A$ 的分支上的部分hash值，对方就可以验证数据 $\rm A$ 的存在，但又不知道数据 $\rm A$ 的内容。</li></ul>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式计算视角下的区块链 阅读笔记</title>
    <link href="/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式计算视角下的区块链"><a href="#分布式计算视角下的区块链" class="headerlink" title="分布式计算视角下的区块链"></a>分布式计算视角下的区块链</h1><blockquote><p>《Blockchains from a Distributed Computing Perspective》</p></blockquote><p>这篇文章来自一位受人尊敬的分布式系统专家，$Maurice~Herlihy$。它写得通俗易懂，具有说明性。论文举了几个例子（越来越复杂）来具体解释区块链的概念。$Herlihy$ 说，<br>“colored by the perspective that much of the blockchain world is a disguised, sometimes distorted, mirror-image of the distributed computing world.”</p><span id="more"></span><h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><p>区块链的核心：<strong>账本（ledger）</strong> (这是意大利文艺复兴时期的一项发明，最初开发用于支持复式记账，现代加密货币的一个遥远的先驱)</p><div class="note note-info">            <p>账本只是各方之间发生的交易的不可磨灭的、仅可追加的日志。</p>          </div><p>账本确定发生了哪些交易：</p><ul><li>$Alice$ 将 $10$ 个硬币转移给 $Bob$</li><li>$Bob$ 将他的汽车的所有权转移给 $Alice$</li></ul><p>账本是 <strong>公开的</strong>，所有各方都可以访问，并且它们必须是 <strong>防篡改的</strong>，一旦记录下来，任何一方都不能添加、删除或修改账本的条目。简而言之，维护账本的算法必须是容错的。</p><h2 id="早期区块链账本"><a href="#早期区块链账本" class="headerlink" title="早期区块链账本"></a>早期区块链账本</h2><h3 id="原始情景"><a href="#原始情景" class="headerlink" title="原始情景"></a>原始情景</h3><p>$Alice$ 经营在线新闻服务，同时多个频道的文章被收集且放置在一个内存表中，在那里它们被索引以供检索（如下图所示）。</p><p><img src="/blog-image/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE-1-1.jpg"></p><p>起初，$Alice$ 使用 <strong>锁来同步对表的并发访问</strong>，但时不时地，持有锁的线程会出现页面错误或调度中断，导致文章无法访问太长时间。尽管有解决这种问题的教科书级的方法，但 $Alice$ 对定制的无锁算法 (lock-free algorithms) 不感兴趣，因此她需要一种简单的方法来消除基于锁的漏洞。</p><h3 id="Alice-的新方法"><a href="#Alice-的新方法" class="headerlink" title="Alice 的新方法"></a>Alice 的新方法</h3><p>她决定分两部分设计实现她的数据结构。</p><p><strong>基本结构</strong>：为了在文章到达时记录它们，她创建了一个作为简单链表实现的账本，其中每个列表条目都包含文章和指向它之前条目的链接。</p><p>当一篇文章到达时，它被放置在一个共享池中：</p><ul><li>矿工：专用线程共同遵守一个共识协议，“讨论”之后决定选择将哪篇文章附加到账本中。</li><li>共识协议：可以很简单，每个矿工创建一个列表条目，然后调用比较和交换指令来尝试使该条目成为列表的新头。</li></ul><p><strong>基本操作：</strong></p><ul><li>查询：为了查询最近的文章，一个线程扫描链表账本。</li><li>添加：线程将文章添加到池中，并等待矿工将其附加到账本中。</li></ul><p><img src="/blog-image/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE-1-2.jpg"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>这种结构（<strong>log-based system architecture</strong>）可能看起来很笨重，但它有两个引人注目的优点。</p><ol><li>通用性，它可以实现任何类型的数据结构，无论多么复杂。</li><li>所有并发性和容错性问题都在 <strong>共识协议</strong> 中进行了划分。</li></ol><h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p>那么共识协议就很重要，协议本身和执行者对于 $Alice$ 都很重要。所有执行协议的“人”中，可能有 “老实人” ，也可能有 “骗子，内鬼”。共识是一个适用于广泛计算模型的概念。“骗子” 可能会出现以下情况：</p><ul><li>各方可能只是随意停止（所谓的崩溃失败 $crash~failures$）</li><li>他们可能会表现出恶意（所谓的拜占庭失败 $Byzantine~ failures$）</li><li>各方通过共享内存中的对象进行通信，或者他们直接交换消息</li><li>有时会限制不诚实的各方的数量，而有些则不会。</li></ul><p>在协商一致的情况下，每一方都提出一项交易以附加到账本中，并选择这些提议交易中的一项。共识确保：</p><ol><li>协议：所有诚实方都同意选择哪一个交易</li><li>终止：所有诚实方最终都了解所选的交易</li><li>有效性：所选交易实际上是由某一方提出的</li></ol><p>共识协议一直是分布式计算几十年来研究的重点。各类文献包含许多不同计算模型的许多算法和不可能结果。由于账本是长期存在的，因此它们需要能够进行重复共识以将交易流附加到账本中。通常，共识是以离散的轮次组织的，各方在第 $r$ 轮完成后开始第 $r + 1$ 轮。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然，这种共享内存的通用构造还不是区块链，因为虽然是并发的，<strong>但不是分布式的</strong>。此外，它不能容忍真正的恶意行为（仅崩溃）。尽管如此，这里已经介绍了区块链底层的关键概念。</p><h2 id="私有区块链账本"><a href="#私有区块链账本" class="headerlink" title="私有区块链账本"></a>私有区块链账本</h2><h3 id="原始情景-1"><a href="#原始情景-1" class="headerlink" title="原始情景"></a>原始情景</h3><p>$Alice$ 还拥有一家冷冻酸奶店，她的生意陷入困境。最近几批冷冻酸奶已经变质，她的供应商 $Bob$ 否认对此负责。当她起诉时，$Bob$ 的律师成功地辩解称，$Bob$ 不仅从未处理过这些货物，而且这些货物在酸奶厂提货时就已经变质了，并且被完好无损地运送到 $Alice$ 的商店。</p><h3 id="Alice-的新方法2-0"><a href="#Alice-的新方法2-0" class="headerlink" title="Alice 的新方法2.0"></a>Alice 的新方法2.0</h3><p>$Alice$ 决定是时候对她的供应链进行区块链化了。她租了一些云存储设备来保存账本，并在每个冷冻酸奶容器中安装了联网的温度传感器。她担心传感器并不总是可靠的（而且 $Bob$ 可能会对一些传感器做手脚），所以她把传感器连接起来进行 <strong>拜占庭容错共识协议</strong>（$Byzantine~ fault-tolerant<del>consensus</del>protocol$） ，该协议使用几轮投票来确保温度读数不会被少数有问题或损坏的传感器所扭曲篡改。每隔一段时间，各传感器就当前温度达成共识。他们在温度记录上盖上时间戳，并添加先前记录的哈希值，这样，当哈希值不匹配时，任何试图篡改早期记录的行为都会被发现。他们给记录“签名”以建立真实性，然后将记录附加到云存储的记录列表中。</p><p>每次冻酸奶桶从 $Carol$ 的工厂转移到 $Bob$ 的卡车上时，$Bob$ 和 $Carol$ 都会签署一份证书，同意保管权的移交。(当桶被送到 $Alice$ 手中时， $Alice$ 和 $Bob$ 也做了同样的事情) 在每一次这样的转移中，带有数字签名的保管权移交证书都盖有时间戳以及先前记录的哈希值，然后当前的记录会被附加到云存储的列表中。</p><ul><li>$Alice$ 很高兴，因为她现在可以确定是谁保管的时候酸奶融化了。</li><li>$Bob$ 很高兴，因为如果这批货在他去 $Carol$ 的工厂取货之前就已经融化了，他就不用负责</li><li>$Carol$ 很高兴，他也得到了类似的保护。</li></ul><div class="note note-info">            <p><strong>值得一提的是</strong>：在每个阶段，$Alice$ 的供应链区块链都包括身份和访问控制。温度传感器在他们的选票上签名，因此选民欺诈 (voter fraud) 是不可能的。只有 $Alice$、$Bob$ 和 $Carol$（以及传感器）有权写入云存储，因此如果有人试图篡改账本，则可以追究各方的责任。</p>          </div><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>在之前的共享内存通用构造中，链表作为账本，原子级内存操作作为共识。</li><li>在这里，保存在云存储中的列表作为账本，拜占庭容错投票和个人数字签名的组合作为共识。虽然情况大不相同，但 <strong>“账本+共识”</strong> 的结构是一样的。</li></ul><h2 id="公有区块链账本"><a href="#公有区块链账本" class="headerlink" title="公有区块链账本"></a>公有区块链账本</h2><h3 id="原始情景-2"><a href="#原始情景-2" class="headerlink" title="原始情景"></a>原始情景</h3><p>$Alice$ 出售了她的冷冻酸奶业务，并决定开一家餐厅。由于租金高昂且风险投资家们总是贪得无厌，她决定通过发行吸引人的优惠券 (ICO) 来筹集自己的资金：她出售可在餐厅开业时兑换折扣套餐的数字优惠券。$Alice$ 希望她的 <strong>ICO</strong> 能够像病毒一样传播开来，很快全世界的人都会吵着要购买 $Alice$ 餐厅的优惠券（许多人打算以加价转售）。</p><h3 id="Alice-的新方法3-0"><a href="#Alice-的新方法3-0" class="headerlink" title="Alice 的新方法3.0"></a>Alice 的新方法3.0</h3><p>$Alice$ 很鸡贼，她认为如果她在区块链上将其作为加密优惠券发行，她的优惠券将更具吸引力。$Alice$ 的加密优惠券由三个部分组成：</p><ul><li>私钥：任何知道私钥的人都可以转让（“花费”）优惠券的所有权</li><li>公钥：任何人都可以验证用私钥加密的信息是否来自于优惠券的所有者</li><li>账本条目：它建立了公钥和优惠券之间的联系，并有一个条目说。”任何知道与以下公钥匹配的私钥的人都拥有一张加密优惠券”。</li></ul><p>假设 $Bob$ 拥有一张优惠券，并决定将其中的一半转给 $Carol$，另一半留给自己。</p><ul><li><strong>step 1</strong> $Bob$ 和 $Carol$ 各自生成一对私钥和公钥。</li><li><strong>step 2</strong> $Bob$ 用他当前的公钥、他的新公钥和 $Carol$ 的公钥创建了一个新的账本条目，并说：“我，即第一个公钥匹配的私钥的所有者，特此将相应优惠券的所有权转让给与接下来的两个公钥匹配的私钥的所有者”。</li></ul><p><img src="/blog-image/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE-1-3.jpg"></p><p>花费 $Alice$ 的一张加密优惠券就像将一张 $20$ 美元的钞票分成两张 $10$ 美元的钞票：旧优惠券被消费并被两张价值较小的不同优惠券取代。</p><h3 id="维护-amp-管理-区块链"><a href="#维护-amp-管理-区块链" class="headerlink" title="维护&amp;管理 区块链"></a>维护&amp;管理 区块链</h3><p>接下来，$Alice$ 必须决定如何管理她的区块链。$Alice$ 不想自己做，因为她知道潜在客户可能不信任她。她有一个聪明的想法：她将通过向任何自愿成为矿工的人提供额外的优惠券作为费用来众包区块链管理（<strong>类似于我们转账时交的手续费</strong>），即执行共识协议的工作。她建立了一个共享公告板（有时称为<strong>点对点网络</strong>）以允许所有优惠券爱好者共享数据。希望购买或出售优惠券的客户将其交易发布到此公告板。一群志愿矿工找到这些交易，将它们分批成打包成块以提高效率，并共同执行重复性共识协议，将这些块附加到共享账本中，该账本本身在公告板上广播。每个矿工，以及所有关心这件事的人都可以获得这个共享账本。</p><h3 id="如何保证区块链可信"><a href="#如何保证区块链可信" class="headerlink" title="如何保证区块链可信"></a>如何保证区块链可信</h3><p>$Alice$ 仍然担心“骗子”矿工会欺骗她的客户。大多数矿工可能是诚实的，满足于收取费用，勤勤恳恳的工作维护共享账本。但仍然存在一种威胁，即存在少数不诚实的矿工也可能相互勾结以欺骗 $Alice$。为了解决这个潜在的问题，$Alice$ 提出了一个想法。</p><h4 id="一个想法：基于IP地址验证身份"><a href="#一个想法：基于IP地址验证身份" class="headerlink" title="一个想法：基于IP地址验证身份"></a>一个想法：基于IP地址验证身份</h4><p>$Alice$ 的第一个想法是让通过 <strong>IP地址</strong> 识别的矿工（类似于冷冻酸奶例子中使用的拜占庭容错共识算法进行投票）。$Alice$ 很快意识到这是个坏主意。$Alice$ 有一个克星 $Sybil$，她擅长制造假 IP 地址。$Sybil$ 可以很容易地压倒任何投票方案，只需用 <strong>“傀儡”矿工充斥协议</strong>，这些矿工看起来是独立的，但实际上都是在 $Sybil$ 的控制之下。</p><div class="note note-info">            <p>前面我们注意到冷冻酸奶供应链区块链（私有区块链）不容易受到这种 <strong>“Sybil攻击”</strong> ，因为各方都有可靠的身份：只有 $Alice$、$Bob$ 和 $Carol$ 被允许参与，即使他们彼此不信任，每个人们知道，如果被发现作弊，他们将被追究责任。相比之下，为 $Alice$ 餐厅的加密优惠券服务的矿工们没有可靠的身份，因为 IP 地址很容易伪造，如果 $Sybil$ 窃取他的优惠券，受害者将无法找寻到真正的幕后黑手。</p>          </div><h4 id="Alice-反思一下"><a href="#Alice-反思一下" class="headerlink" title="Alice 反思一下"></a>Alice 反思一下</h4><p>在建立街头帮派时，本质上会出现同样的问题：如何确保想加入帮派的人不是便衣警察、报社记者，或者只是一个白手起家的人？一种方法是社会学家所说的 <strong>“投名状（costly signaling）”</strong>：要求候选人做一些代价很高且难以伪造的事情，例如（1）抢劫商店，或（2）获得帮派标志纹身。</p><p>在公有区块链世界中，最常见的“投名状”形式称为 <a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AD%89%E6%98%8E">工作量证明(PoW)</a>。在 <strong>PoW</strong> 中，通过持有的彩票来决定将哪一笔交易应该被附加到账本中以达成共识。这很机智：因为购买彩票是一种代价很高的事情，需要投入大量的成本。如果她的每个“傀儡”矿工都必须长期购买彩票，那么 $Sybil$ 伪造 $\rm IP$ 身份对她来说是入不敷出的，期望值太低。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>具体来说，在 PoW 彩票中，矿工们相互之间竞争解决一个非常困难且没有捷径的谜题，然而解决这个谜题很难，但证明一个人已经解决了这个谜题却很容易。</p><p><img src="/blog-image/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE-1-4.jpg"></p><p>把事情简单化一下，第一个解决谜题的矿工赢得了“共识”，并可以选择一个区块添加到账本中。该矿工也收到了他所付出的劳动费用（一张新的优惠券，作为他工作的回报），而其他矿工白忙活了，必须重新开始解决下一个新的谜题。</p><p>实际上，PoW 共识并不是真正的共识。如果两个矿工同时解开谜题，他们可以平行地向区块链追加区块，因此在区块链中没有一个区块先于另一个。当这种情况发生时，<strong>区块链被称为分叉</strong>。后续的矿工应该建立在哪个区块上？通常的答案是建立在链最长的区块上，尽管也有人提出了其他方法。</p><p>因此，区块链上的交易是否是永久的存在一些不确定性，尽管区块一旦在区块链上被替换的概率会随着其后的区块数量呈指数下降。如果 $Bob$ 使用 $Alice$ 的加密优惠券从 $Carol$ 那里购买汽车，$Carol$ 会谨慎地等待 $Bob$ 的交易在区块链中相当靠前，以尽量减少它被分叉取代的机会。</p><p>尽管 PoW 目前是最受欢迎的加密货币的基础，但它并不是唯一的策略。还有很多策略，将加密货币的所有权和不同类型代价高的事件绑定，例如以太坊的 Casper 或 Algorand。Cachin 和 Vukolic 对区块链共识协议进行了全面调查。</p><h2 id="讨论-私有链-amp-公有链"><a href="#讨论-私有链-amp-公有链" class="headerlink" title="讨论-私有链&amp;公有链"></a>讨论-私有链&amp;公有链</h2><p>私有（许可）区块链系统和公有（无许可）区块链系统之间的区别是至关重要的，在前者中，各方拥有可靠的身份信息，只有经过审查或实名认证的各方可以参与；而在后者中，各方无法被可靠地识别，任何人都可以参与。</p><ul><li><strong>私有区块链</strong>：更适合商业应用，特别是在受监管行业，如金融，受了解你的客户和反洗钱法规的约束。私有区块链也往往更擅长治理，例如，通过提供更新分类账协议的有序程序。大多数关于分布式算法的先前工作都集中在参与者具有可靠身份的系统上。</li><li><strong>公有区块链</strong>：对比特币等应用程序很有吸引力，这些应用程序旨在确保没有人可以控制谁可以参与，并且参与者可能不渴望知道他们的身份。尽管 PoW 是 Dwork 和 Naor 发明的一种控制垃圾邮件的方式，但中本聪将 PoW 应用于大规模共识是一项真正的创新，开创了整个区块链领域。</li></ul><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>大多数区块链系统还提供某种形式的脚本语言，以便更轻松地向账本添加功能。·比特币·提供了一种基本的脚本语言，而·以太坊·提供了一种图灵完备的脚本语言。此类程序通常被称为智能合约（或合约）（尽管可以说它们既不智能也不合约）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是一些简单合约功能的示例。<strong>哈希锁H</strong> 会防止资产被转移，直到合约收到了相匹配的秘密 $s$，其中<br>$$h = H(s)$$<br>其中 $H$ 是一个加密哈希函数。类似地，时间锁 $t$ 可防止资产在指定的未来时间 $t$ 之前被转移。</p><p>假设 $Alice$ 想用她的一些优惠券与 $Bob$ 交换一些比特币。$Alice$ 的优惠券存在于一个区块链上，而 $Bob$ 的比特币存在于另一个区块链上，因此他们需要设计一个<strong>原子级跨链交换协议</strong>来完成他们的交易。当然了，双方都不是完全信任对方，防人之心不可无。这是一个简单的协议。让我们大胆地假设 $24$ 小时足以让任何人在任一区块链上发布智能合约，并且让另一方检测到该合约已发布。</p><p><img src="/blog-image/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE-1-5.jpg"></p><p>如上图所示（顺序：红——橙——黄——绿）</p><ul><li>$Alice$ 创建一个秘密 $s$ 和 $h = H(s)$，并在未来 $48$ 小时内在优惠券区块链上发布一个带有哈希锁和时间锁的合约，将一些优惠券的所有权转让给 $Bob$</li><li>当 $Bob$ 确认 $Alice$ 的合约已经发布在优惠券区块链上时，他在比特币区块链上发布了一个具<strong>有相同哈希锁H</strong> 但具有 $24$ 小时后时间锁的合约，将他的比特币转移给 $Alice$</li><li>当 $Alice$ 确认 $Bob$ 的合约已经发布在比特币区块链上时，她将 $s$ 发送给 $Bob$ 发布的合约中进行验证，并获得了对方提前放置好的比特币，并将 $s$ 透露给 $Bob$</li><li>$Bob$ 向 $Alice$ 的合约发送 $s$ 也进行验证，获取优惠券并完成交换</li></ul><div class="note note-info">            <p>设计好的合约如果发布在区块链上，就等同于昭告天下了，P2P网络中所有的人都知道了这个合约的存在</p>          </div><p>如果 $Alice$ 或 $Bob$ 在第一步或第二步崩溃，则合约超时（到期之后）并将其资产退还给原始所有者。如果其中任何一方在第三步和第四步中崩溃，那么只有崩溃的一方会很惨、血亏。如果任何一方试图欺骗，例如通过发布不正确的合同，那么另一方可以简单地停止并且其资产将被全额退还。$Alice$ 的合同需要一个 $48$ 小时的时间锁，以便当她在 $24$ 小时之前发布她的秘密 $s$ 时，$Bob$ 有足够的时间根据 $s$ 发布合约。</p><p>这个例子说明了智能合约的力量。智能合约还有许多其他用途，包括链下交易。为了提高效率，资产在区块链外来回转移，只用区块链在不频繁的时间间隔内结算余额。</p><h3 id="智能合约-as-对象"><a href="#智能合约-as-对象" class="headerlink" title="智能合约 as 对象"></a>智能合约 as 对象</h3><p>智能合约类似于面向对象编程语言中的对象。合约封装了长期状态、初始化该状态的构造函数以及管理该状态的一个或多个函数（方法）。合约可以调用彼此的功能。</p><p>在以太坊中，所有合约都记录在区块链上，账本包括这些合约的当前状态。当矿工构建一个区块时，如果用智能合约填充该区块并一个一个地执行它们，其中每个合约的最终状态是下一个合约的初始状态。这些合约是按顺序执行的，所以<strong>看起来~不需要担心并发性</strong>。</p><h3 id="智能合约作为监视器"><a href="#智能合约作为监视器" class="headerlink" title="智能合约作为监视器"></a>智能合约作为监视器</h3><p>去中心化自治组织（DAO）是一个投资基金，成立于 $2016$ 年，完全由智能合约管理，没有直接的人工管理。投资者可以投票决定如何投资该基金的资金。当时，有令人窒息的新闻报道解释了 DAO 将如何永远改变投资的形态。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">function withdraw(unit amuount)&#123;<br>    <span class="hljs-keyword">client</span> = msg.sender:<br>    <span class="hljs-keyword">if</span> (balance[<span class="hljs-keyword">client</span>] &gt;= amount)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">client</span>.call.sendMoney(amount))&#123;<br>            balance[<span class="hljs-keyword">client</span>] -= amount;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面显示了一个类似 DAO 的合约片段，说明了一个允许投资者提取资金的功能。</p><ul><li>首先，该函数提取客户的地址（第 2 行）</li><li>然后检查客户是否有足够的资金来支付提款（第 3 行）</li><li>如果是，则通过外部函数调用将资金发送给客户（第 4 行）</li><li>如果转账成功，则减少客户的余额（第 5 行）。</li></ul><div class="note note-danger">            <p><strong>!!! 这段代码有致命的缺陷</strong></p>          </div><p>$2016$ 年 $6$ 月，有人利用该功能从 DAO 窃取了约 <strong>$5000$</strong> 万美元的资金。如前所述，第 3 行中的表达式是对客户端合约中函数的调用。下面显示了客户端的代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">sendMoney</span>(unit amount)&#123;<br>    victiom = msg.sender;<br>    balance += amount;<br>    victim.<span class="hljs-keyword">with</span>draw(amount) //再次调用 withdraw<br>&#125;<br></code></pre></td></tr></table></figure><p>客户的合约立即再次调用 withdraw()（第 4 行）。这个重入调用再次测试客户端是否有足够的资金来支付提款（第 3 行），并且 <strong>因为 withdraw() 仅在嵌套调用完成后才递减余额</strong>，因此测试错误地通过，函数会一直调用，依此类推，仅在调用堆栈溢出时停止。</p><p>这种重入攻击乍一看似乎是一种全新的编程风格带来的奇异危险，但如果我们稍微改变一下观点，我们就会发现一个学习过并发编程课程的本科生都熟悉的陷阱。</p><h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><p>监视器是由 $Hoare$ 和 $Brinch Hansen$ 发明的并发编程语言结构。监视器是一个带有内置互斥锁的对象，它在方法调用时自动获取并在方法返回时释放。（此类方法在 Java 中称为同步方法。）监视器还提供了一个 <strong>wait()</strong> 调用，允许线程释放监视器锁、挂起、最终唤醒和重新获取锁。例如，一个线程试图从一个空的缓冲区消费一个项目，可以调用 wait() 来暂停，直到有一个项目要消费。</p><p>推理监视器实现正确性的主要工具是监视器不变量，只要监视器中没有线程执行，该断言就成立。当线程持有监视器锁时，可以违反不变量，但是当线程释放锁时，必须通过从方法返回或通过 wait() 挂起来恢复不变量。</p><p>如果我们通过监视器和监视器不变量的视角来查看智能合约，那么可重入漏洞看起来非常熟悉。外部调用就像暂停，因为即使没有显式锁定，调用也可以让第二个程序计数器与第一个程序计数器同时执行该合约的代码。此处显示的类似 DAO 的合约隐含地假定每个客户在余额表中的条目反映其实际余额​​的不变性。当暂时违反的不变量在通过外部调用放弃（虚拟）监视器锁之前没有恢复时，就会发生错误。</p><p>这就是分布式计算视角为何有价值的原因。当用监视器和监视器不变量来解释时，可重入漏洞是一个熟悉的、经典的并发错误，但是当用智能合约来表达时，它让受人尊敬的专家程序员感到惊讶，导致 DAO 投资者的实质性中断和尴尬，并且基本上需要重启以太坊货币本身。</p><h3 id="智能合约作为读-修改-写操作"><a href="#智能合约作为读-修改-写操作" class="headerlink" title="智能合约作为读-修改-写操作"></a>智能合约作为读-修改-写操作</h3><p>ERC20 代币标准是最近许多首次代币发行 (ICO) 的基础，这是一种在不实际出售所有权的情况下为企业筹集资金的流行方式。ERC20 代币的发行者控制着代币的创建。代币可以交易或出售，就像前面讨论的爱丽丝餐厅的优惠券一样。ERC20 是一个标准，就像 Java 接口一样，而不是特定的实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">contract ERC20Example &#123;<br>    <span class="hljs-comment">// 每个账户的余额</span><br>    mapping(address =&gt; uint256 ) balances ;<br>    <span class="hljs-comment">// 账户所有者批准将一笔款项转入另一个账户</span><br>    mapping(address =&gt; mapping (address =&gt; uint256 )) allowed;<br>    <span class="hljs-comment">// 其他字段省略</span><br>    ...<br>    <span class="hljs-comment">// 允许 spender 多次从您的账户中提款，可多次提款。</span><br>    <span class="hljs-function">function <span class="hljs-title">approve</span>(<span class="hljs-params">address spender, <span class="hljs-built_in">uint</span> amount</span>) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span> success </span>)</span> &#123;<br>        allowed[msg.sender][spender] = amount; <span class="hljs-comment">// 更改 allowed</span><br>        Approval(msg.sender, spender, amount); <span class="hljs-comment">// 区块链事件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">function <span class="hljs-title">allowance</span>(<span class="hljs-params">address tokenOwner, address spender</span>) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"> <span class="hljs-built_in">uint</span> remaining</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> allowed[tokenOwner][spender];<br>    &#125;<br>    <span class="hljs-function">function <span class="hljs-title">transferFrom</span>(<span class="hljs-params">address <span class="hljs-keyword">from</span>, address to , <span class="hljs-built_in">uint</span> tokens</span>) <span class="hljs-keyword">public</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span> success </span>)</span> &#123;<br>        balances[<span class="hljs-keyword">from</span>] = balances[<span class="hljs-keyword">from</span>].sub(tokens );<br>        allowed[<span class="hljs-keyword">from</span>][msg.sender] = allowed[<span class="hljs-keyword">from</span>][msg.sender].sub(tokens );<br>        balances[to] = balances[to ]. <span class="hljs-keyword">add</span>(tokens );<br>        Transfer (<span class="hljs-keyword">from</span>, to , tokens );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    ... <span class="hljs-comment">// 其他功能省略</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ERC20 代币合约跟踪每个账户拥有多少代币（第 3 行的余额映射）</li><li>以及每个账户允许转移到其他账户的代币数量（第 5 行 allowed 的映射）</li><li>approve()函数（第 9-13 行）调整一次可以将多少代币转移到另一个帐户的限制。</li><li>它更新 allowed 表（第 10 行）</li><li>并生成区块链事件以使这些更改更容易跟踪（第 11 行）</li><li>allowance () 函数查询这个 allowance（第 14-16 行）</li><li>transferFrom 函数（第 17-23 行）将代币从一个帐户转移到另一个帐户，并将配额减少相应的金额。此函数假定接收方有足够的余量来进行转移。</li></ul><p>以下是此规范如何导致不良行为。$Alice$ 调用 permit() 来授权 $Bob$ 将多达 $1000$ 个代币从她的帐户转移到他的帐户。$Alice$ 改变了主意，并发出一笔交易，将 $Bob$ 的津贴减少到仅仅 $100$ 个代币。$Bob$ 了解到这一变化，在 $Alice$ 的交易进入区块链之前，$Bob$ 向友好的矿工发出 transferFrom() 调用，要求 $1000$ 个代币，矿工确保 $Bob$ 的交易在下一个区块中先于 $Alice$ 的交易。这样，$Bob$ 成功地收回了他的 $1000$ 个代币的旧配额，将他的授权设置为 $0$，然后，为了不理会 $Alice$，他收回了 $100$ 个令牌的新配额。最后，$Alice$ 试图将 $Bob$ 的配额从 $1000$ 减少到 $10$，这使得 $Bob$ 可以提取 $1100$ 个代币，这不是她的本意。</p><p>在实践中，ERC20 代币实现通常采用临时解决方法来避免此漏洞，最常见的是重新定义 allow() 的含义，以便它将允许值从正值重置为零，并在以后的调用中，从零到新的正值，但如果要求将允许值从一个正值重置为另一个正值，则会失败。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Counter&#123;<br>    private <span class="hljs-type">int</span> counter;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> <span class="hljs-type">dec</span>()&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = counter<br>        <span class="hljs-keyword">temp</span> = <span class="hljs-keyword">temp</span> - <span class="hljs-number">1</span>;<br>        counter = <span class="hljs-keyword">temp</span>;<br>    &#125;<br>    ···<br>&#125;<br></code></pre></td></tr></table></figure><p>问题在于，无论旧配额是否发生变化，approv() 都会盲目地用新配额覆盖旧配额。这种做法类似于尝试实现上面代码段所示的原子递减。这里，递减方法将共享计数器状态读入局部变量（第 4 行），增加局部变量（第 5 行），并将结果存回处于共享状态（第 6 行）。如果可以被并发线程调用，不难看出这个方法是不正确的，因为共享状态可以在第 4 行读取和第 6 行写入之间发生变化。编程，这个并发缺陷是显而易见的，但是当用表面上不需要并发模型的智能合约来表达时，</p><h3 id="讨论分析"><a href="#讨论分析" class="headerlink" title="讨论分析"></a>讨论分析</h3><p>我们已经看到，智能合约不需要并发模型，因为执行是单线程的，这是一种危险的幻觉。$Sergey$ 和 $Hobor$ 对智能合约中的陷阱和常见错误进行了出色的调查，这些陷阱和错误是熟悉的并发陷阱和错误的伪装版本。$Atzei$ 等人。对以太坊智能合约设计中的漏洞进行全面调查。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>激进的创新往往更容易从成熟的研究社区之外出现，而不是从内部出现。早在 $2008$ 年，中本聪的原始比特币论文会被一个主要的分布式会议接受吗？当然，我们永远不会知道，但该论文缺乏正式模型、缺乏严格的证明以及缺乏性能数据将是一个障碍。</p><p>今天，区块链研究是计算机科学中更有活力的领域之一，有可能彻底改变我们社会处理信任的方式。观察到许多区块链结构对分身（或至少是先驱）的认识不足，这并不是对任一研究社区的批评，而是呼吁双方更加关注对方。</p>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode72-编辑距离</title>
    <link href="/leetcode/leetcode72/"/>
    <url>/leetcode/leetcode72/</url>
    
    <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>编辑距离，又称 <strong>Levenshtein距离</strong> （也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括: </p><ul><li>将一个字符替换成另一个字符</li><li>插入一个字符</li><li>删除一个字符<span id="more"></span></li></ul><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>例如：计算 <strong>sailn</strong>，<strong>failing</strong> 之间的编辑距离 $\rm edit(i,j)$,该函数表示：长度为 $i$ 的字符串与长度为 $j$ 字符串之间的距离。动态规划：</p><ol><li>如果 $i=0$ 且 $j=0$，$\rm edit(i,j)=0$</li><li>如果 $i=0$ 且 $j&gt;0$，$\rm edit(i,j)=j$</li><li>如果 $i&gt;0$ 且 $j=0$，$\rm edit(i,j)=i$</li><li>如果 $i&gt;0$ 或 $j&gt;0$，<br>$$\rm edit(i, j) = \min{(\color{Red}{edit(i-1, j)+1}, \color{blue}{edit(i, j-1)+1}, \color{Green}{edit(i-1, j-1)+f(i, j)}<br>\color{black}{)}}$$<br>&nbsp;<br><strong>解释</strong>：<ul><li>$\color{red}{edit}$ : $i^{th}$ 为<strong>删除</strong>的字符，延续 $[0,i-1]$ 与 $[0,j]$ 的最优解。</li><li>$\color{blue}{edit}$ : $j^{th}$ 为<strong>删除</strong>的字符，延续 $[0,i]$ 与 $[0,j-1]$ 的最优解。</li><li>$\color{green}{edit}$ : $i^{th}$ 与 $j^{th}$ 为一对<strong>替换</strong>的字符，延续 $[0,i-1]$ 与 $[0,j-1]$ 的最优解。</li></ul></li></ol><div class="note note-info">            <p><strong>PS</strong>:插入和删除是一个相对的概念。 $A:apdt$ &nbsp; $B:apt$<br>以 $A$ 的角度看 $d$ 应该被删除的<br>以 $B$ 的角度看 $d$ 应该被插入的</p>          </div><p>这里当字符串 $1$ 的第 $i$ 个字符不等于字符串 $2$ 的第 $j$ 个字符时，$f(i, j)=1$；否则，$f(i, j)=0$。</p><p><img src="/blog-image/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.jpg"></p><p>从图上我们可以直观的看到利用动态规划计算编辑距离的过程，首先构造 DP 矩阵，然后执行第一步、第二步和第三步进行矩阵初始化的工作。最后，针对每一个元素使用第四步。</p><!-- **例如：**| |$0$|f|a|i|l|i|n|g|||:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:||$\bf 0$|$\color{Red}{0}$|$\color{blue}{1}$|$\color{blue}{2}$|$\color{blue}{3}$|$\color{blue}{4}$|$\color{blue}{5}$|$\color{blue}{6}$|$\color{blue}{7}$|||$\bf s$|$\color{green}{1}$|$\color{orange}{1}$|$\color{orange}{2}$|$\color{orange}{3}$|$\color{orange}{4}$|$\color{orange}{5}$|$\color{orange}{6}$|$\color{orange}{7}$|$\color{red}{step~1}$||$\bf a$|$\color{green}{2}$|$\color{orange}{2}$|$\color{orange}{1}$|$\color{orange}{2}$|$\color{orange}{3}$|$\color{orange}{4}$|$\color{orange}{5}$|$\color{orange}{6}$|$\color{green}{step~2}$||$\bf i$|$\color{green}{3}$|$\color{orange}{3}$|$\color{orange}{2}$|$\color{orange}{1}$|$\color{orange}{2}$|$\color{orange}{3}$|$\color{orange}{4}$|$\color{orange}{5}$|$\color{blue}{step~3}$||$\bf l$|$\color{green}{4}$|$\color{orange}{4}$|$\color{orange}{3}$|$\color{orange}{2}$|$\color{orange}{1}$|$\color{orange}{2}$|$\color{orange}{3}$|$\color{orange}{4}$|$\color{orange}{step~4}$||$\bf n$|$\color{green}{5}$|$\color{orange}{5}$|$\color{orange}{4}$|$\color{orange}{3}$|$\color{orange}{2}$|$\color{orange}{1}$|$\color{orange}{2}$|$\color{orange}{3}$|| --><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>基因分析（<a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1y1h06m0mg6t0610nu170xa0u7176035">基于隐私保护的基因相似度计算方法及基因信息获取方法</a>）</li><li>拼字检查</li><li>语音辨识</li><li>抄袭侦测</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">class</span> Solution:<br>    <span class="hljs-attribute">def</span> minDistance(self, word<span class="hljs-number">1</span>: str, word<span class="hljs-number">2</span>: str) -&gt; int:<br>        <span class="hljs-attribute">n</span> = len(word<span class="hljs-number">1</span>)<br>        <span class="hljs-attribute">m</span> = len(word<span class="hljs-number">2</span>)<br>        <br>        <span class="hljs-comment"># 有一个字符串为空串</span><br>        <span class="hljs-attribute">if</span> n * m == <span class="hljs-number">0</span>:<br>            <span class="hljs-attribute">return</span> n + m<br>        <br>        <span class="hljs-comment"># DP 数组</span><br>        <span class="hljs-attribute">D</span> =<span class="hljs-meta"> [ [0] * (m + 1) for _ in range(n + 1)]</span><br>        <br>        <span class="hljs-comment"># 边界状态初始化</span><br>        <span class="hljs-attribute">for</span> i in range(n + <span class="hljs-number">1</span>):<br>            <span class="hljs-attribute">D</span>[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-attribute">for</span> j in range(m + <span class="hljs-number">1</span>):<br>            <span class="hljs-attribute">D</span>[<span class="hljs-number">0</span>][j] = j<br>        <br>        <span class="hljs-comment"># 计算所有 DP 值</span><br>        <span class="hljs-attribute">for</span> i in range(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-attribute">for</span> j in range(<span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>):<br>               <br>               <span class="hljs-comment"># i 表示列， j 表示行</span><br>               <span class="hljs-attribute">left</span>    = D[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>   # 左边<br>               <span class="hljs-attribute">up</span>      = D[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>   # 上面 <br>               <span class="hljs-attribute">left_up</span> = D[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]   # 左上<br><br>               <span class="hljs-attribute">if</span> word<span class="hljs-number">1</span>[i - <span class="hljs-number">1</span>] != word<span class="hljs-number">2</span>[j - <span class="hljs-number">1</span>]:<br>                  <span class="hljs-attribute">left_down</span> += <span class="hljs-number">1</span><br>                  <br>               <span class="hljs-attribute">D</span>[i][j] = min(left, down, left_down)<br>        <br>        <span class="hljs-attribute">return</span> D[n][m]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>编辑距离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>驼峰式大小写</title>
    <link href="/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%86%99/"/>
    <url>/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="驼峰式大小写"><a href="#驼峰式大小写" class="headerlink" title="驼峰式大小写"></a>驼峰式大小写</h1><p>驼峰式大小写（Camel-Case，Camel Case，camel case），电脑程序编写时的一套命名规则（惯例）。</p><span id="more"></span><p>当变量名和函数名称是由二个或多个单字链接在一起，而构成的唯一识别字时，利用“驼峰式大小写”来表示，可以增加变量和函数的可读性。</p><p>“驼峰式大小写（Camel-Case）一词来自 <strong>Perl语言</strong> 中普遍使用的大小写混合格式，而Larry Wall等人所著的畅销书《Programming Perl》（O’Reilly出版）的封面图片正是一匹骆驼。”</p><p>“驼峰式大小写”命名规则可视为一种惯例，并无绝对与强制，为的是增加识别和可读性。一旦选用或设置好命名规则，在程序编写时应保持一致格式。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>单字之间不以空格断开（例：camel case）或连接号（-，例：camel-case）、下划线（_，例：camel_case）链接，有两种格式：</p><ul><li><strong>小驼峰式命名法（lower camel case）</strong>：<br>第一个单字以小写字母开始；第二个单字的首字母大写，例如：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">firstName、lastName<br></code></pre></td></tr></table></figure></li><li><strong>大驼峰式命名法（upper camel case）</strong>：<br>每一个单字的首字母都采用大写字母，例如：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">FirstName、LastName、CamelCase<br></code></pre></td></tr></table></figure>也被称为Pascal命名法（英语：Pascal Case）。</li></ul><h2 id="其他相关格式"><a href="#其他相关格式" class="headerlink" title="其他相关格式"></a>其他相关格式</h2><p><strong>StudlyCaps</strong> 是指大小写混用且不使用空格、连接号或下划线的格式，如sTuDlyCAps。StudlyCaps可以视为“驼峰式大小写”的变种。</p>]]></content>
    
    
    <categories>
      
      <category>编程规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML基础</title>
    <link href="/%E5%89%8D%E7%AB%AF/HTML%E5%9F%BA%E7%A1%80/"/>
    <url>/%E5%89%8D%E7%AB%AF/HTML%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p><strong>HTML</strong>（超文本标记语言——<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage）是构成 Web 世界的点点滴滴。它定义了网页内容的含义和结构。除 HTML 以外的其它技术则通常用来描述一个网页的表现与<strong>展示效果（如 CSS）</strong>，或<strong>功能与行为（如 JavaScript）</strong>。</p><span id="more"></span><h3 id="HTML-是什么"><a href="#HTML-是什么" class="headerlink" title="HTML 是什么"></a>HTML 是什么</h3><p>HTML 不是一门编程语言，而是一种用于定义内容结构的标记语言。HTML 由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对 <strong>标签（tags）</strong> 可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。</p><p>例如，键入下面一行内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">学习使我快乐<br></code></pre></td></tr></table></figure><p>可以将这行文字封装成一个 <strong>段落（paragraph）</strong> 元素来使其在单独一行呈现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>学习使我快乐<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="HTML-元素详解"><a href="#HTML-元素详解" class="headerlink" title="HTML 元素详解"></a>HTML 元素详解</h3><ol><li><strong>开始标签</strong>（Opening tag）：包含元素的名称（本例为 p），被大于号、小于号所包围。表示元素从这里开始或者开始起作用 —— 在本例中即段落由此开始。</li><li><strong>结束标签</strong>（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这表示着元素的结尾 —— 在本例中即段落在此结束。初学者常常会犯忘记包含结束标签的错误，这可能会产生一些奇怪的结果。</li><li><strong>内容</strong>（Content）：元素的内容，本例中就是所输入的文本本身。</li><li><strong>元素</strong>（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素。</li></ol><p>元素也可以有属性（Attribute）：</p><center>例如: &ltp&gt class = "editor-note" 学习使我快乐  &lt/p&gt </p>`</center>属性包含了关于元素的一些额外信息，这些信息本身不应显现在内容中。本例中，class 是属性名称，editor-note 是属性的值 。class 属性可为元素提供一个标识名称，以便进一步为元素指定样式或进行其他操作时使用。]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>距离度量方法</title>
    <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B7%9D%E7%A6%BB/"/>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="距离度量方法"><a href="#距离度量方法" class="headerlink" title="距离度量方法"></a>距离度量方法</h1><blockquote><p>五年是个长距离，在这个时代  ———《黑白李》老舍</p></blockquote><span id="more"></span><h2 id="个体间距离"><a href="#个体间距离" class="headerlink" title="个体间距离"></a>个体间距离</h2><h3 id="1-针对连续性数据"><a href="#1-针对连续性数据" class="headerlink" title="1. 针对连续性数据"></a>1. 针对连续性数据</h3><ul><li><p><strong>欧氏距离</strong><br>以古希腊数学家 <strong>Euclidean</strong> 命名的距离；也就是我们直观的两点之间直线最短的直线距离。欧氏距离是一个通常采用的距离定义，它是在 $p$ 维空间中两个点之间的真实距离。<br>$$EUCLID(x,y)=\sqrt{\sum_{i=1}^p(x_i-y_i)^2}$$</p></li><li><p><strong>欧式距离平方</strong><br>$$SEUCLID(x,y)=\sum_{i=1}^p(x_i-y_i)^2$$</p></li><li><p><strong>马氏距离</strong><br>马氏距离是对欧式距离的一种修正，将各个维度的分布进行标准化操作。<br>$$D_M(x)=\sqrt{(x-\mu)^T\Sigma^{-1}(x-\mu)}$$<br>其中 $\Sigma$ 是多维随机变量之间的协方差矩阵，$\mu$ 是样本均值。将主成分的偏转抵消掉，让各个维度独立，然后进行标准化，让各个维度同分布。<br>主成分分析：</p><ul><li>主成分 — 特征向量的方向</li><li>各个维度的方差 — 特征值<br>&nbsp;</li></ul></li><li><p><strong>切比雪夫距离</strong><br>国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动到相邻 $8$ 个方格中的任意一个。国王从格子 $(x_1,y_1)$ 走到格子 $(x_2,y_2)$ 最少需要多少步？这个距离就叫切比雪夫距离。<br>$$Chebychev(x,y)=\max_{1\le i\le p} \left| x_i-y_i \right|$$<br>以上这个公式等价于:<br>$$Chebychev(x,y)=\lim_{k \to\infty}(\sum_{i=1}^n|x_i-y_i|^k)^\frac{1}{k}$$</p></li><li><p><strong>曼哈顿距离</strong><br>在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离。这个实际驾驶距离就是“曼哈顿距离”。曼哈顿距离也称为“城市街区距离”(City Block distance)。<br>$$Manhattan(x,y)=\sum_{i=1}^p \left| x_i-y_i \right|$$</p></li><li><p><strong>明科夫斯基距离</strong><br>明氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。<br>以俄罗斯数学家明科夫斯基命名的距离；是欧式距离的推广，$p=2$ 时等价于欧氏距离，和 $\rm p$-范数 等值。<br>两个 $n$ 维变量 $a(x_1,x_2,…,x_n)$ 与 $b(y_1,y_2,…,y_n)$ 间的明科夫斯基距离定义为：<br>$$Minkowski(x,y)=\sqrt[k]{\sum_{i=1}^p {\left| x_i-y_i \right|}^k}$$<br>其中，$k$ 可以任意设置。容易看出，欧氏距离、切比雪夫距离和曼哈顿距离分别是 $k=2$、$k\to\infty$ 和 $k=1$时候的特例。<br>&nbsp;<br>缺点：<br>1.没有考虑各个分量的量纲(scale)之间的差异;<br>2.未考虑各个分量的分布（期望，方差等）可能是不同的情况。<br>&nbsp;</p></li><li><p><strong>自定义距离</strong><br>$$Customized(x,y)=\sqrt[k]{\sum_{i=1}^p {\left| x_i-y_i \right|}^r}$$</p><p>其中，$k$ 和 $r$ 都是可以任意设置的。容易看出，上面给出的所有距离都可以通过赋予 $k$ 和 $r$ 特定的值得到。</p></li></ul><hr><ul><li><p><strong>夹角距离</strong><br>几何中，夹角余弦可用来衡量两个向量方向的差异。<br>机器学习中，借用这一概念来衡量样本向量之间的差异。<br>$$Cosine(x,y)=\frac{\sum_{i=1}^p(x_iy_i)^2}{(\sum_{i=1}^px_i^2)(\sum_{i=1}^py_i^2)}$$</p></li><li><p><strong>皮尔逊相关系数</strong><br>皮尔森相关系数（Pearson correlation coefficient）也叫皮尔森积差相关系数（Pearson product-moment correlation coefficient），是用来反应两个变量相似程度的统计量。或者说可以用来计算两个向量的相似度（在<strong>基于向量空间模型的文本分类、用户喜好推荐系统</strong>中都有应用）。</p><p>$$r(x,y)=\frac{\sum_{i=1}^p(x_i-\overline{x}_i)(y_i-\overline{y}<em>i)}{\sqrt{\sum</em>{i=1}^p(x_i-\overline{x}<em>i)^2\sum</em>{i=1}^p(y_i-\overline{y}_i)^2}}$$<br>pearson是一个介于-1和1之间的值，用来描述两组线性的数据一同变化移动的趋势。<br>&nbsp;<br>当两个变量的线性关系增强时，相关系数趋于 $1$ 或 $-1$；当一个变量增大，另一个变量也增大时，表明它们之间是正相关的，相关系数大于 $0$ ；如果一个变量增大，另一个变量却减小，表明它们之间是负相关的，相关系数小于 $0$ ；如果相关系数等于 $0$ ，表明它们之间不存在线性相关关系。当两个变量独立时相关系统为 $0$ ，但反之不成立。比如对于 $y=x^2$ 次方，$\rm X$ 服从 $[-1,1]$ 上的均匀分布，此时 $E(XY)$ 为 $0$，$E(X)$ 也为 $0$，所以 $P(x,y)=0$，但 $x$ 和 $y$ 明显不独立。所以“不相关”和“独立”是两回事。当 $\rm Y$ 和 $\rm X$ 服从联合正态分布时，其相互独立和不相关是等价的。</p><p>如果，$E(X)=E(Y)=0$ ，此时有：<br>$$r(x,y)=\frac{E(XY)}{E(X^2)E(Y^2)}=\frac{X*Y}{|X||Y|}$$<br>即相关系数可以看作是两个随机变量中得到的样本集向量之间夹角的<strong>cosine函数</strong>。<br>进一步当 $\rm X$ 和 $\rm Y$ 向量归一化后，$\rm ||X||=||Y||=1$，相关系数即为<strong>两个向量的乘积</strong>。</p></li></ul><div class="note note-info">            <p><strong>PS</strong>:夹角余弦和皮尔逊相关系数其实是描述个体之间相似性的指标，所以，他们的值越大，表明个体之间的距离越小</p>          </div><h3 id="2-针对二值型数据"><a href="#2-针对二值型数据" class="headerlink" title="2. 针对二值型数据"></a>2. 针对二值型数据</h3><p>如果个体的 $k$ 个变量都是二值变量，则个体之间的距离测度将基于一个如下表所示的 $2\times2$ 的列联表。该表是根据原始数据转换而来的两个体取值的交叉列联表。表中， $a+b+c+d$ 等于变量的总个数，$a$ 为两个体取值都为 $1$ 的变量个数，$b$ 为个体 $x$ 取值为 $0$, 而个体 $y$ 取值为 $1$ 的变量个数，$c$ 为个体 $x$ 取值为 $1$ 而个体 $y$ 取值为 $0$ 的变量个数，$d$ 为两 个体取值都是 $0$ 的变量个数。显然:</p><ul><li>$a+d$ 的比重描述了两个体之间的相似程度;</li><li>$b+c$ 的比重反映了两个体之间的差异程度。    </li></ul><table><thead><tr><th align="center"></th><th align="center">$1$ &nbsp;</th><th align="center">$0$</th></tr></thead><tbody><tr><td align="center">$1$</td><td align="center">$a$</td><td align="center">$b$</td></tr><tr><td align="center">$0$</td><td align="center">$c$</td><td align="center">$d$</td></tr><tr><td align="center">几乎所有的二值变量的距离就是基于以上 $2\times2$ 列联表，例如：</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>二值欧氏距离<br>$$EUCLID(x,y)=\sqrt{b+c}$$</li><li>二值欧氏距离平方<br>$$SEUCLID(x,y)=b+c$$</li><li>不对称指数<br>$$SD(x,y)=\frac{b-c}{(a+b+c+d)^2}$$</li><li>不相似性测度<br>$$PD(x,y)=\frac{bc}{(a+b+c+d)^2}$$</li><li>方差<br>$$Var(x,y)=\frac{b+c}{4(a+b+c+d)}$$</li></ul><h3 id="3-针对计数型数据"><a href="#3-针对计数型数据" class="headerlink" title="3. 针对计数型数据"></a>3. 针对计数型数据</h3><p>所谓计数变量，是指个体在某个分类变量上的频数。针对计数变量的距离测度方法主要有卡方距离和Phi方距离。</p><ul><li><p>卡方距离<br>$$\chi^2(x,y)=\sqrt{\sum_{i=1}^p(\frac{x_i-E(x_i)}{E(x_i)})^2+\sum_{i=1}^p(\frac{y_i-E(y_i)}{E(y_i)})^2}$$<br>其中，$x_i$ 是个体 $x$ 的第 $i$ 个变量的取值（在第 $i$ 类上的频数），$E(x_i)$ 是个体 $x$ 在第 $i$ 类上的期望频数，个体 $y$ 同理。<br>&nbsp;</p></li><li><p>$\rm Phi^2$ 距离<br>$$Phi^2(x,y)=\sqrt{\frac{\sum_{i=1}^p(\frac{x_i-E(x_i)}{E(x_i)})^2+\sum_{i=1}^p(\frac{y_i-E(y_i)}{E(y_i)})^2}{n}}$$<br>其中，$n$ 为样本容量，其余符号的意义与卡方距离一样。</p></li></ul><h2 id="类间距离"><a href="#类间距离" class="headerlink" title="类间距离"></a>类间距离</h2><p><strong>SPSS</strong> 中提供了如下几种类间距离测度方法：</p><ul><li>组间平均连接距离（Between-group linkage）：以两类个体两两之间距离的平均数作为类间距离；</li><li>组内平均连接距离（Within-group linkage）：将两类个体合并为一类后，以合并后 类中所有个体之间的平均距离作为类间距离；</li><li>最近邻距离（Nearest neighbor）：以两类中距离最近的两个个体之间的距离作为类间距离；</li><li>最远邻距离（Furthest neighbor）：以两类中距离最远的两个个体之间的距离作为类间距离；</li><li>重心距离（Centroid cluster）：以两类变量均值之间的距离作为类间距离；</li><li>中位数距离（Median cluster）：以两类变量中位数之间的距离作为类间距离；</li><li>离差平方和法(Ward method): 该方法是 $Ward$ 提出来的，所以又称为 $Ward$ 法。具 体做法是先将 $n$ 个样品各自成一类，然后每次减少一类，随着类与类的不断聚合， 类内的离差平方和必然不断增大，选择使离差平方和增加最小的两类合并，直到所 有的样品归为一类为止。</li></ul><h2 id="字符串距离"><a href="#字符串距离" class="headerlink" title="字符串距离"></a>字符串距离</h2><h3 id="1-编辑距离"><a href="#1-编辑距离" class="headerlink" title="1. 编辑距离"></a>1. 编辑距离</h3><p>编辑距离，又称 <strong>Levenshtein距离</strong> （也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括:（1）将一个字符替换成另一个字符；（2）插入一个字符，（3）删除一个字符。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>基因分析（<a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=1y1h06m0mg6t0610nu170xa0u7176035">基于隐私保护的基因相似度计算方法及基因信息获取方法</a>）</li><li>拼字检查</li><li>语音辨识</li><li>抄袭侦测</li></ul><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>例如：计算 $”sailn”~~~”failing”$ 之间的编辑距离 $\rm edit(i,j)$,该函数表示：长度为 $i$ 的字符串与长度为 $j$ 字符串之间的距离。动态规划：</p><ol><li>如果 $i=0$ 且 $j=0$，$\rm edit(i,j)=0$</li><li>如果 $i=0$ 且 $j&gt;0$，$\rm edit(i,j)=j$</li><li>如果 $i&gt;0$ 且 $j=0$，$\rm edit(i,j)=i$</li><li>如果 $i&gt;0$ 或 $j&gt;0$，<br>$$\rm edit(i, j) = \min{(\color{Red}{edit(i-1, j)+1}, \color{blue}{edit(i, j-1)+1}, \color{Green}{edit(i-1, j-1)+f(i, j)}<br>\color{black}{)}}$$<br>这里当字符串 $1$ 的第 $i$ 个字符不等于字符串 $2$ 的第 $j$ 个字符时，$f(i, j)=1$；否则，$f(i, j)=0$。<br>&nbsp;</li></ol><p><img src="/blog-image/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.jpg"></p><p>从图上我们可以直观的看到利用动态规划计算编辑距离的过程，首先构造 DP 矩阵，然后执行第一步、第二步和第三步进行矩阵初始化的工作。最后，针对每一个元素使用第四步。</p><h3 id="2-Jaro-距离-amp-Jaro-Winkler相似度"><a href="#2-Jaro-距离-amp-Jaro-Winkler相似度" class="headerlink" title="2. Jaro 距离 &amp; Jaro-Winkler相似度"></a>2. Jaro 距离 &amp; Jaro-Winkler相似度</h3><p>Jaro-Winkler Distance是一个度量两个字符序列之间的编辑距离的字符串度量标准，是由William E. Winkler在 $1990$ 年提出的Jaro Distance度量标准的一种变体。Jaro Distance是两个单词之间由一个转换为另一个所需的单字符转换的最小数量。Jaro-Winkler Distance通过前缀因子 $p$ 使Jaro Distance相同时共同前缀长度 $l$ 越大的相似度越高。Jaro–Winkler Distance越小，两个字符串越相似。<br>如果分数是 $0$，则表示完全不同，分数为 $1$ 则表示完全匹配。</p><p><strong>Jaro 距离</strong></p><p>$$Sim_{jaro}= \begin{cases}0 &amp; \rm if ~m=0 \ \frac{1}{3}(\frac{m}{|S_1|}+\frac{m}{|S_2|}+\frac{m-t}{m}) &amp; \rm otherwise \end{cases} $$</p><p>其中：</p><ul><li>$|S_i|$ 是字符串 $S_i$ 的长度。</li><li>$m$ 是匹配的字符串数量。</li><li>$t$ 是字符转换的次数。</li></ul><p>只有当 $S_1$ 和 $S_2$ 的字符相同，且距离不超过 $Match~Window = ⌊\frac{max(|S_1|,|S_2|)}{2}⌋−1$ 时才认为两个字符是匹配的。将 $S_1$ 与 $S_2$ 匹配的字符进行比较，相同位置但字符不同的字符数除以 $2$ 就是要转换的次数 $t$.</p><div class="note note-info">            <p><strong>PS</strong>:相当于是在一个 <strong>窗口$\rm MW$</strong> 中进行搜索找到了相同的字符那就是 <strong>匹配</strong> 的。</p>          </div><p><strong>Jaro-Winkler相似度</strong></p><p>对于给定的两个字符串，相似度 $Sim_{winkler}$ 计算公式如下：<br>$$Sim_{winkler}=Sim_{jaro}+l·p~·(1-Sim_{jaro})$$</p><p>其中：</p><ul><li>$Sim_{jaro}$ 是 $S_1$ 和 $S_2$ 的 Jaro距离。</li><li>$l$ 是字符串公共的前缀长度，最大值为 $4$。</li><li>$p$ 是一个常量因子，对于有公共前缀的分数会向上调整，$p$ 不能超过 $0.25$，否则相似度会超过 $1$，常量 $p$ 的默认值为 $0.1$ 。 </li></ul><p><strong>例如：</strong><br>$$Sim_{winkler S_1 S_2} = \begin{cases}S_1<del>\rm aboard\S_2</del>\rm abroad \end{cases} $$<br>$$Sim_{winkler S_1 S_3} = \begin{cases}S_1<del>\rm aboard\S_3</del>\rm aborad \end{cases} $$</p><p><strong>计算 Jaro 距离：</strong><br>$$Sim_{Jaro S_1 S_2} = \frac{1}{3}(\frac{6}{6}+\frac{6}{6}+\frac{6-1}{6}) = 0.944 $$<br>其中，窗口$\rm MW=⌊\frac{6}{2}⌋−1=3$ ，所以，匹配的字符数为 $m$ 为 $6$，6个“匹配”的字符中，需要转换的字符为 $o，a，r$，所以转换次数 $t$ 为 $3/2=1$。<br>$$Sim_{Jaro S_1 S_3} = \frac{1}{3}(\frac{6}{6}+\frac{6}{6}+\frac{6-1}{6}) = 0.944 $$<br>需要转换的字符为 $a，r$，所以转换次数 $t$ 为 $2/2=1$。</p><p><strong>计算 Jaro-Winkler 相似度</strong></p><p>此时 $S_1$ 与 $S_2$ 和 $S_3$ 的Jaro距离相同，无法判断 $S_1$ 与哪个更相似，此时可以通过Jaro-Winkler 算法对 Jaro距离 进行调整，假设常量因子 $p$ 为 $0.25$。</p><ul><li><p>$S_1$，$S_2$ 匹配字符的共同前缀 $ab$ 的长度 $l$ 为 $2$ 小于 $4$，所以它们的Jaro-Winkler相似度为<br>$$Sim_{winkler S_1 S_2}=0.944+(2∗0.25*(1−0.944))=0.972$$</p></li><li><p>$S_1$，$S_3$ 匹配字符的共同前缀 $abo$ 的长度 $l$ 为 $3$ 小于 $4$，所以它们的Jaro-Winkler相似度为<br>$$Sim_{winkler S_1 S_3}=0.944+(3∗0.25*(1−0.944))=0.986$$</p></li></ul><p>Jaro相似度相同的通Jaro-Winkler 算法调整后可以比较出与哪个更相似。如上 $S_1$ 与 $S_3$ 更相似。</p><h2 id="概率分布距离"><a href="#概率分布距离" class="headerlink" title="概率分布距离"></a>概率分布距离</h2><h3 id="1-KL散度"><a href="#1-KL散度" class="headerlink" title="1. KL散度"></a>1. KL散度</h3><p>Kullback-Leibler Divergence，即KL散度，是一种量化两种概率分布 $P$ 和 $Q$ 之间差异的方式，又叫<strong>相对熵</strong>。在概率学和统计学上，我们经常会使用一种更简单的、近似的分布来替代观察数据或太复杂的分布。KL散度能帮助我们度量使用一个分布来近似另一个分布时所损失的信息。</p><p>相对熵又称互熵，交叉熵等。设 $p(x)$ 和 $q(x)$ 是 $x$ 取值的两个概率概率分布，则 $p$ 对 $q$ 的相对熵为:<br>$$D_{KL}(p||q)=\sum_{i=1}^np(x)\log\frac{p(x)}{q(x)}=-\sum_{i=1}^np(x)\log q(x)+\sum_{i=1}^np(x)\log p(x)=H(p,q)-H(q)$$</p><p>值得注意的是：$D_{KL}(p||q) \geq 0$</p><h2 id="集合距离"><a href="#集合距离" class="headerlink" title="集合距离"></a>集合距离</h2><h3 id="1-Jaccard-index"><a href="#1-Jaccard-index" class="headerlink" title="1. Jaccard index"></a>1. Jaccard index</h3><p>Jaccard index, 又称为Jaccard相似系数（Jaccard similarity coefficient）用于比较有限样本集之间的相似性与差异性。Jaccard系数值越大，样本相似度越高。</p><p>两个集合 $A$ 和 $B$ 交集元素的个数在 $A$、$B$ 并集中所占的比例，称为这两个集合的杰卡德系数，用符号 $J(A,B)$ 表示。杰卡德相似系数是衡量两个集合相似度的一种指标（余弦距离也可以用来衡量两个集合的相似度）。<br>$$J(A,B)=\frac{|A\bigcap B|}{|A\bigcup B|}$$</p><h3 id="2-Tanimoto-Coefficient"><a href="#2-Tanimoto-Coefficient" class="headerlink" title="2. Tanimoto Coefficient"></a>2. Tanimoto Coefficient</h3><p>Tanimoto系数由Jaccard系数扩展而来，又称为广义Jaccard相似系数，计算方式如下：<br>$$E_{Jaccard}(A,B)=\frac{A\cdot B}{||A||^2+||B||^2-A\cdot B}$$</p><p>其中 $A$、$B$ 分别表示为两个向量，集合中每个元素表示为向量中的一个维度，在每个维度上，取值通常是 $[0, 1]$ 之间的值（如果取值是二值向量，那么Tanimoto系数就等同Jaccard距离），$A\cdot B$表示向量乘积，$||A||^2$ 表示向量的模。</p><p>Tanimoto系数容易与余弦相似度混淆在Tanimoto系数计算公式中，如果把分母的 $A\cdot B$ 去掉，并将 $||A||^2+||B||^2$ 替换为 $||A||^2\cdot||B||^2$，就转成了余弦相似度。</p><h3 id="3-Dice-系数"><a href="#3-Dice-系数" class="headerlink" title="3. Dice 系数"></a>3. Dice 系数</h3><p>Dice距离用于度量两个集合的相似性，因为可以把字符串理解为一种集合，因此Dice距离也会用于度量字符串的相似性。此外，Dice系数的一个非常著名的使用即实验性能评测的F1值。Dice系数定义如下：<br>$$Dice(A,B)=\frac{2|A\bigcap B|}{|A|+|B|}$$</p><p>其中分子是 $A$ 与 $B$ 的交集数量的两倍，分母为 $A$ 和 $B$ 的长度之和，所以他的范围也在 $0$ 到 $1$ 之间。从公式看，Dice系数和Jaccard非常的类似。Jaccard是在分子和分母上都减去了$|A\bigcap B|$。<br>$$J(A,B)=\frac{|A\bigcap B|}{|A\bigcup B|}=\frac{|A\bigcap B|}{|A|+|B|-|A\bigcap B|}$$</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>距离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>法人和非法人组织</title>
    <link href="/%E6%B3%95%E5%AD%A6/DH%E6%B3%95%E5%AD%A6-1/"/>
    <url>/%E6%B3%95%E5%AD%A6/DH%E6%B3%95%E5%AD%A6-1/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章-法人和非法人组织"><a href="#第三章-法人和非法人组织" class="headerlink" title="第三章 法人和非法人组织"></a>第三章 法人和非法人组织</h2><h3 id="一、法人的分类"><a href="#一、法人的分类" class="headerlink" title="一、法人的分类"></a>一、法人的分类</h3><ul><li>社团法人不同于社会团体法人。</li><li>法人：公法人、私法人（社团法人：营利和非营利、财团法人：非营利）。</li><li><strong>基金会法人均属公益法人</strong>，只有管理机关没有意思机关。理事会是决策机构，重要事项的决议，须经出席理事表决，2/3以上通过方为有效。对于章程的修改，应当征得其业务主管部门的同意，并报登记管理机关核准。</li><li>民办非企业单位：如民办学校。营利性与非营利性并存。</li><li>银行不一定是营利法人。如：中国人民银行是行政机关，归为机关法人。</li></ul><h3 id="二、格式条款"><a href="#二、格式条款" class="headerlink" title="二、格式条款"></a>二、格式条款</h3><ul><li>格式条款：是指当事人预先拟定，并在订立合同时未与对方协商的条款。</li><li>无效格式条款：是指提供格式条款的一方免除其责任、加重对方责任、排除对方主要权利。</li></ul><h3 id="三、法人分立"><a href="#三、法人分立" class="headerlink" title="三、法人分立"></a>三、法人分立</h3><ul><li>法人分立的，分立后的法人享有连带债权、承担连带债务，但是债权人和债务人另有约定的除外。</li></ul><h3 id="四、履行治愈规则"><a href="#四、履行治愈规则" class="headerlink" title="四、履行治愈规则"></a>四、履行治愈规则</h3><ul><li>采用合同书订立合同，在签字或者盖章之前，当事人一方已经履行主要义务，对方接受的，该合同成立。</li></ul><h3 id="五、事业单位"><a href="#五、事业单位" class="headerlink" title="五、事业单位"></a>五、事业单位</h3><ul><li><p>事业单位的全部经费或来源于财政拨款，或自负盈亏。</p></li><li><p>事业单位法人资格的确定从成立之日起、或者登记之日起设立。</p></li><li><p>国家举办的事业单位对其直接支配的不动产和动产，享有占有、使用以及按照法律或者国务院的有关规定收益、处分的权利。</p></li><li><p>法人（包括事业单位）不得主张精神损害赔偿。</p><blockquote><p>《民法典》第1183条：侵害自然人人身权益造成严重精神损害的，被侵权人有权请求精神损害赔偿。因故意或者重大过失侵害自然人具有人身意义的特定物造成严重精神损害的，被侵权人有权请求精神损害赔偿。 </p></blockquote></li></ul><hr><h2 id="第四章-民事法律行为"><a href="#第四章-民事法律行为" class="headerlink" title="第四章 民事法律行为"></a>第四章 民事法律行为</h2><h3 id="一、胁迫的认定"><a href="#一、胁迫的认定" class="headerlink" title="一、胁迫的认定"></a>一、胁迫的认定</h3><ul><li>胁迫：是指以给公民及其亲友的生命健康、荣誉、名誉、财产造成损害或者以给法人的荣誉、名誉、财产造成损害为要挟，迫使对方做出违背真实的意思表示的行为。</li></ul><h3 id="二、无效的民事法律行为"><a href="#二、无效的民事法律行为" class="headerlink" title="二、无效的民事法律行为"></a>二、无效的民事法律行为</h3><ul><li>强制性规定</li><li>公序良俗</li><li>无民事行为能力人独立实施</li><li>虚假意思表示</li><li>恶意串通</li></ul><h3 id="三、赠予合同任意撤销权的例外"><a href="#三、赠予合同任意撤销权的例外" class="headerlink" title="三、赠予合同任意撤销权的例外"></a>三、赠予合同任意撤销权的例外</h3><ul><li>赠与合同经过公证</li><li>依法不得撤销的具有救灾、扶贫、助残等公益、道德义务性质的赠与合同。</li></ul><h3 id="四、重大误解"><a href="#四、重大误解" class="headerlink" title="四、重大误解"></a>四、重大误解</h3><ul><li>本质系对合同内容的认识错误<ul><li>对行为的性质认识错误（错把有偿当无偿）</li><li>对对方当事人认识错误</li><li>对标的物认识错误</li></ul></li></ul><h3 id="五、抵押物"><a href="#五、抵押物" class="headerlink" title="五、抵押物"></a>五、抵押物</h3><ul><li>宅基地属于法律禁止抵押的财产</li></ul><h3 id="六、效力竞合"><a href="#六、效力竞合" class="headerlink" title="六、效力竞合"></a>六、效力竞合</h3><ul><li>效力竞合：是指“一行为两效力”。法考主要考查的是效力待定的民事法律行为和可撤销的民事法律行为。</li></ul>]]></content>
    
    
    <categories>
      
      <category>法学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>法学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>民法概述</title>
    <link href="/%E6%B3%95%E5%AD%A6/DH%E6%B3%95%E5%AD%A6-2/"/>
    <url>/%E6%B3%95%E5%AD%A6/DH%E6%B3%95%E5%AD%A6-2/</url>
    
    <content type="html"><![CDATA[<h3 id="一、非营利法人剩余财产的处理"><a href="#一、非营利法人剩余财产的处理" class="headerlink" title="一、非营利法人剩余财产的处理"></a>一、非营利法人剩余财产的处理</h3><ul><li>以公益为目的设立的非营利法人终止时，其出资人、设立人或者会员不想有剩余财产分配请求权。剩余财产采用英国衡平法上的“近似原则”，即转给宗旨相同或者近似的法人，并向社会公告。<blockquote><p>本知识点来源于：为救治他人的捐款存放于一个专门账户，这种行为区别于赠予。应当注意。</p></blockquote></li></ul><h3 id="二、债权人撤销权"><a href="#二、债权人撤销权" class="headerlink" title="二、债权人撤销权"></a>二、债权人撤销权</h3><ul><li>因债务人无偿转让财产，对债权人造成损害的，债权人可以请求人民法院撤销债务人的行为。撤销权自债务人知道或者应当知道撤销事由之日起1年内行使。自债务人的行为发生之日起五年内没有行使撤销权的，该撤销权消灭。<strong>【注】</strong> 债权人撤销权受除斥期间限制，不受诉讼时效限制。</li></ul><h3 id="三、不当得利与适当让利"><a href="#三、不当得利与适当让利" class="headerlink" title="三、不当得利与适当让利"></a>三、不当得利与适当让利</h3><h3 id="四、-死者人格利益的保护和精神损害的赔偿"><a href="#四、-死者人格利益的保护和精神损害的赔偿" class="headerlink" title="四、 死者人格利益的保护和精神损害的赔偿"></a>四、 死者人格利益的保护和精神损害的赔偿</h3><ul><li>自然人死亡后，行为人非法利用、损害遗体、遗骨，或以违法社会公共利益、社会公德的其他方式侵害遗体的，其近亲属向法院起诉主张请求精神损害赔偿的，法院应当依法予以受理。【需要有适格的原告】</li></ul><h3 id="五、诉讼时效"><a href="#五、诉讼时效" class="headerlink" title="五、诉讼时效"></a>五、诉讼时效</h3><ul><li>限制民事行为能力人向其法定代理人主张损害赔偿的诉讼时效期间，自该法定代理终止之日起计算而非年满18周岁之日起计算。</li></ul><h3 id="六、监护人制度"><a href="#六、监护人制度" class="headerlink" title="六、监护人制度"></a>六、监护人制度</h3><h4 id="（一）监护人资格的撤销与恢复"><a href="#（一）监护人资格的撤销与恢复" class="headerlink" title="（一）监护人资格的撤销与恢复"></a>（一）监护人资格的撤销与恢复</h4><ul><li>个人和民政部门以外的组织未及时向人民法院申请撤销监护人资格的，民政部门应当向人民法院申请。</li><li>依法负担被监护人抚养费、赡养费、扶养费的父母、子女、配偶等，被人民法院撤销监护人资格后，，应当继续履行负担的义务。</li><li>恢复监护人资格，对被监护人实施故意犯罪的除外。</li><li>未成年人遭受性侵害的损害赔偿请求权的诉讼时效，自受害人年满18周岁之日起计算。<h4 id="（二）监护人的职责"><a href="#（二）监护人的职责" class="headerlink" title="（二）监护人的职责"></a>（二）监护人的职责</h4></li><li>精神病人（无民事行为能力人）决定将自己的肾脏捐出去的行为（实施的民事法律行为）无效。</li><li>自然人（完全民事行为能力人）生前未表示不同意捐献器官的，该自然人死亡后，其配偶、成年子女、父母可以共同决定捐献，决定捐献应当采用书面形式。</li></ul><h3 id="七、收养关系的解除"><a href="#七、收养关系的解除" class="headerlink" title="七、收养关系的解除"></a>七、收养关系的解除</h3><ul><li>收养人在被收养人成年以前，不的解除收养关系；但是收养人与送养人协议解除收养关系的除外。养子女若8周岁以上，还需征得其同意。</li></ul><h3 id="八、宣告死亡"><a href="#八、宣告死亡" class="headerlink" title="八、宣告死亡"></a>八、宣告死亡</h3><ul><li>死亡宣告被撤销后，婚姻关系自动回复。但一方再婚或者向婚姻登记机关书面声明不愿意恢复婚姻关系的除外。</li></ul>]]></content>
    
    
    <categories>
      
      <category>法学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>法学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>民法习题总结</title>
    <link href="/%E6%B3%95%E5%AD%A6/DH%E6%B3%95%E5%AD%A6-3/"/>
    <url>/%E6%B3%95%E5%AD%A6/DH%E6%B3%95%E5%AD%A6-3/</url>
    
    <content type="html"><![CDATA[<h3 id="一、债的相对性原理和债务免除的性质"><a href="#一、债的相对性原理和债务免除的性质" class="headerlink" title="一、债的相对性原理和债务免除的性质"></a>一、债的相对性原理和债务免除的性质</h3><ul><li>根据债的相对性原理，债权人免除债务人的债务需要向债务人做出意思表示，而非第三人。</li><li>我国的债务免除适用的是“修正的单独行为说”，即<blockquote><p>《民法典》第575条规定：债权人免除债务人部分或者全部债务的，债权债务部分或者全部终止，但是债务人在合理期限内拒绝的除外。</p></blockquote></li></ul><h3 id="二、收养关系的解除和法定继承"><a href="#二、收养关系的解除和法定继承" class="headerlink" title="二、收养关系的解除和法定继承"></a>二、收养关系的解除和法定继承</h3><ul><li>养子女仍系养父母第一顺位继承人     </li><li>收养关系的解除方式<ul><li>协议解除</li><li>诉讼解除</li></ul></li></ul><h3 id="三、按份共有的外部关系和产品责任"><a href="#三、按份共有的外部关系和产品责任" class="headerlink" title="三、按份共有的外部关系和产品责任"></a>三、按份共有的外部关系和产品责任</h3><ul><li>产品责任属于典型的“不真正连带责任”。</li><li>产品缺陷造成的侵权责任，消费者（合同当事人）的救济途径（追究谁的责任）：<ul><li>生产者（生产商/制造商）的侵权责任</li><li>销售者的违约责任</li><li>销售者的侵权责任</li></ul></li><li>产品缺陷造成的侵权责任，第三人（非合同当事人）的救济途径（追究谁的责任）：<ul><li>生产者（生产商/制造商）的侵权责任</li><li>销售者的侵权责任</li></ul></li><li>按份共有物对外造成第三人损害的，依法承担连带责任</li></ul><h3 id="四、遗嘱"><a href="#四、遗嘱" class="headerlink" title="四、遗嘱"></a>四、遗嘱</h3><ul><li>立遗嘱人必须为未成年子女留有必要的遗产份额，否则，遗嘱部分无效</li><li>遗嘱为单方民事法律行为，仅有两种效能：无效和有效，不可能出现可撤销。</li></ul><h3 id="五、不当得利"><a href="#五、不当得利" class="headerlink" title="五、不当得利"></a>五、不当得利</h3><ul><li>构成要件<ul><li>没有法定或者约定的原因</li><li>一方获益</li><li>一方受损</li><li>获益于受损之间存在因果关系</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>法学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>法学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>段子</title>
    <link href="/%E7%94%9F%E6%B4%BB/%E6%9C%89%E8%B6%A3/"/>
    <url>/%E7%94%9F%E6%B4%BB/%E6%9C%89%E8%B6%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="记录一些平常生活中看得到的段子"><a href="#记录一些平常生活中看得到的段子" class="headerlink" title="记录一些平常生活中看得到的段子"></a>记录一些平常生活中看得到的段子</h2><h3 id="希望为生活多加一点欢乐"><a href="#希望为生活多加一点欢乐" class="headerlink" title="希望为生活多加一点欢乐"></a>希望为生活多加一点欢乐</h3><span id="more"></span><h4 id=""><a href="#" class="headerlink" title="-"></a>-</h4><p>女人会离开你<br>兄弟会背叛你<br>数学不会<br>数学不会就是不会</p><h4 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h4><p>打车的时候我问司机：从这到机场要多久？<br>司机：要很久的<br>我：起码要多久？<br>司机：骑马要更久</p><h4 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h4><p>我：“明天的考试，你复习的怎么样了？”<br>朋友：“我在做作业啊，什么考试？”<br>我：“考试？”</p><h4 id="-3"><a href="#-3" class="headerlink" title="-"></a>-</h4><p>你喜欢的女生回嗯嗯怎么办？你就回：“你嗯你妈呢？”<br>你看这不是又聊起来了，气氛还越来越激烈了</p><h4 id="-4"><a href="#-4" class="headerlink" title="-"></a>-</h4><p>问：有没有人曾经给你说过“别走好吗”<br>答：我教练，他今天对我说：“别走好吗？快快快，跑起来跑起来”</p><h4 id="-5"><a href="#-5" class="headerlink" title="-"></a>-</h4><p>哪里不会考哪里，背的都在题干里</p><h4 id="-6"><a href="#-6" class="headerlink" title="-"></a>-</h4><p>我：拖延症杀了我吧<br>拖延症：明天吧<br>我：好的</p><h4 id="-7"><a href="#-7" class="headerlink" title="-"></a>-</h4><p>啄木鸟：哒哒哒哒哒哒哒哒<br>树：“我没病，你别啄了”<br>啄木鸟：“没病走两步”<br>树：“滚”</p><h4 id="-8"><a href="#-8" class="headerlink" title="-"></a>-</h4><p>《紧急通知》洗面奶千万不要抹到发迹线上，否则发际线以为这是脸，会自觉退后，长此以往，不堪设想。</p><h4 id="-9"><a href="#-9" class="headerlink" title="-"></a>-</h4><p>朋友：“我昨晚哭到12点”<br>我：“是哭到12点立马停的吗？12点整吗？”<br>我：“你为什么看着表哭？”</p><h4 id="-10"><a href="#-10" class="headerlink" title="-"></a>-</h4><p>游戏可以输，但是嘴一定要臭，我输得是游戏，他死的是亲妈，别说；路人不路人的，我也是路人，我是nmd黄泉引路人</p><h4 id="-11"><a href="#-11" class="headerlink" title="-"></a>-</h4><p>我：“你人呢？怎么不见了？”<br>朋友：“我在计程车上”<br>我：“你是不是喝多了”<br>朋友：“就喝多了才搭计程车，不然我TM走路回家吗？”<br>我：“我们TM就是在你家喝的啊”</p><h4 id="-12"><a href="#-12" class="headerlink" title="-"></a>-</h4><p>我：“张师傅，今天早晨送的包子咋没有昨天好吃了”<br>张：“不可能吧？这就是昨天的包子啊”</p><h4 id="-13"><a href="#-13" class="headerlink" title="-"></a>-</h4><p>我吃饭中<br>我的白衬衫：让我也尝尝</p><h4 id="-14"><a href="#-14" class="headerlink" title="-"></a>-</h4><p>我发现，江浙人还是比较喜欢玩捆绑，比如大闸蟹，比如粽子</p><h4 id="-15"><a href="#-15" class="headerlink" title="-"></a>-</h4><p>重庆本没有人，迷路的多了，便成了本地人</p><h4 id="-16"><a href="#-16" class="headerlink" title="-"></a>-</h4><p>晚上的我：没有人喜欢我<br>蚊子：我喜欢我喜欢我喜欢我喜欢我来了我来了我来了我来了</p><h4 id="-17"><a href="#-17" class="headerlink" title="-"></a>-</h4><p>好评：红烧肉炖的真烂；差评：红烧肉炖的真烂</p><h4 id="-18"><a href="#-18" class="headerlink" title="-"></a>-</h4><p>“你们现在很多年轻人，都搞不清自己的定位是什么”<br>滴滴司机在电话里对我说。</p><h4 id="-19"><a href="#-19" class="headerlink" title="-"></a>-</h4><p>洗衣服：<br>洗衣服洗—30min<br>烘干衣服—60min<br>叠好衣服—大概7到10个工作日</p><h4 id="-20"><a href="#-20" class="headerlink" title="-"></a>-</h4><p>我很菜，但我还是很讨厌答辩的时候老师拿论文当扇子使</p><h4 id="-21"><a href="#-21" class="headerlink" title="-"></a>-</h4><p>本人女大学生，家中一直是爸爸做饭，那天妈妈要做，看着教学弄好了四个菜，下决心，不管什么味道，一定要吃完，要鼓励她！当我将筷子伸向一只螃蟹时，螃蟹突然主动夹住了我的筷子。<br>螃蟹：“很熟吗？就动手动脚的”</p><h4 id="-22"><a href="#-22" class="headerlink" title="-"></a>-</h4><p>太尴尬了，打完疫苗在留观区睡着了，志愿者以为我死了围过来好多</p><h4 id="-23"><a href="#-23" class="headerlink" title="-"></a>-</h4><p>不小心踩死一只蚂蚁，小蚂蚁委屈地说那是蚁后，我们没有蚁后了呜呜呜我们没有蚁后了</p><h4 id="-24"><a href="#-24" class="headerlink" title="-"></a>-</h4><p>川普一直在焦急地等消息，一位朋友劝他早点睡，说“拜登啦，等也是拜登。”<br>问：这位朋友最可能是什么人？</p><ul><li>A 一位共和党朋友</li><li>B 一位民主党朋友</li><li>C 一位河南朋友</li></ul><h4 id="-25"><a href="#-25" class="headerlink" title="-"></a>-</h4><p>女主在洗碗<br>弹幕：帮你开个二倍速洗快一点</p><h4 id="-26"><a href="#-26" class="headerlink" title="-"></a>-</h4><p>老师：XXX家长你好，孩子要开家长会了，给你打电话通知你，你怎么直接骂人挂电话什么意思？<br>家长：我没有骂人，我的原话是：我现在有事，你打他妈的电话</p><h4 id="-27"><a href="#-27" class="headerlink" title="-"></a>-</h4><p>人：免疫系统，我为什么发烧啊？<br>免疫：因为生病了<br>人：那为什么会发烧啊？<br>免疫：因为病毒在40度活不长<br>人：可是我在40度也活不长啊<br>免疫：我承认我有赌的成分，但是今天你和病毒必须死一个</p><h4 id="-28"><a href="#-28" class="headerlink" title="-"></a>-</h4><p>虚假的大学生：课余生活丰富多彩<br>真是的大学生：“这个加分吗？”</p><h4 id="-29"><a href="#-29" class="headerlink" title="-"></a>-</h4><p>半夜头疼 我说：“头啊，你能不能别疼了”<br>头回答到：“我不疼就没人疼你了”</p><h4 id="-30"><a href="#-30" class="headerlink" title="-"></a>-</h4><p>别人的电动车后面是女朋友<br>我的电动车后面是水蜜桃，等个红绿灯还被顺走俩</p><h4 id="-31"><a href="#-31" class="headerlink" title="-"></a>-</h4><p>我是一个及其自律的人，既然说了不熬夜，那就每天说一遍</p><h4 id="-32"><a href="#-32" class="headerlink" title="-"></a>-</h4><p>最后一个上床的我在卫生间洗漱<br>舍友上完厕所，关（锁）上了门，“我们都睡了，老张你一会儿出来小声点啊”</p><h4 id="-33"><a href="#-33" class="headerlink" title="-"></a>-</h4><p>昨晚做梦梦到我死了<br>进了阎王殿<br>阎王叫我给他的生死簿做个后台管理系统</p><h4 id="-34"><a href="#-34" class="headerlink" title="-"></a>-</h4><p>凡是多在自己身上找原因，坚持下去，人就抑郁了</p><h4 id="-35"><a href="#-35" class="headerlink" title="-"></a>-</h4><p>我的电脑：文件已保存<br>我：嗯，然后呢？我的文件呢保存到哪里了？<br>我的电脑：Good question</p><h4 id="-36"><a href="#-36" class="headerlink" title="-"></a>-</h4>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
